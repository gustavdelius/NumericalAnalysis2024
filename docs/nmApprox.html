<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Numerical Analysis - 2&nbsp; Approximations</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./nmAlgebra.html" rel="next">
<link href="./nmPython.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="Numerical Analysis - 2&nbsp; Approximations">
<meta property="og:description" content="">
<meta property="og:site_name" content="Numerical Analysis">
<meta name="twitter:title" content="Numerical Analysis - 2&nbsp; Approximations">
<meta name="twitter:description" content="">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./nmApprox.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Approximations</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Numerical Analysis</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://maths.york.ac.uk/moodle/course/view.php?id=2652" title="Moodle page" class="quarto-navigation-tool px-1" aria-label="Moodle page"><i class="bi bi-mortarboard-fill"></i></a>
    <a href="https://forms.gle/Z8nYvVonGN98L7nv5" title="Submit a correction" class="quarto-navigation-tool px-1" aria-label="Submit a correction"><i class="bi bi-bug-fill"></i></a>
    <a href="https://github.com/gustavdelius/NumericalAnalysis2024/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="./Numerical-Analysis.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmPython.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Essential Python</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmApprox.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Approximations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmAlgebra.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Algebra</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmCalculus.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Calculus</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmOptimization.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Optimization</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmODE.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Ordinary Differential Equations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmPDE.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Partial Differential Equations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmLinAlg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Linear Algebra</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#binary-numbers" id="toc-binary-numbers" class="nav-link active" data-scroll-target="#binary-numbers"><span class="header-section-number">2.1</span> Binary Numbers</a></li>
  <li><a href="#floating-point-numbers" id="toc-floating-point-numbers" class="nav-link" data-scroll-target="#floating-point-numbers"><span class="header-section-number">2.2</span> Floating Point Numbers</a></li>
  <li><a href="#loss-of-significant-digits" id="toc-loss-of-significant-digits" class="nav-link" data-scroll-target="#loss-of-significant-digits"><span class="header-section-number">2.3</span> Loss of significant digits</a></li>
  <li><a href="#sec-Taylor" id="toc-sec-Taylor" class="nav-link" data-scroll-target="#sec-Taylor"><span class="header-section-number">2.4</span> Approximating Functions</a></li>
  <li><a href="#truncation-error" id="toc-truncation-error" class="nav-link" data-scroll-target="#truncation-error"><span class="header-section-number">2.5</span> Truncation Error</a></li>
  <li><a href="#problems" id="toc-problems" class="nav-link" data-scroll-target="#problems"><span class="header-section-number">2.6</span> Problems</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/gustavdelius/NumericalAnalysis2024/edit/main/nmApprox.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-approx" class="quarto-section-identifier"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Approximations</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<blockquote class="blockquote">
<p><em>We think in generalities, but we live in details.</em><br>
–<a href="https://en.wikipedia.org/wiki/Alfred_North_Whitehead">Alfred North Whitehead</a></p>
</blockquote>
<p>Have you ever wondered how computers, which operate in a realm of zeros and ones, manage to perform mathematical calculations with real numbers? The secret lies in approximation.</p>
<p>In this chapter we will investigate the foundations that allow a computer to do mathematical calculations at all. How can it store real numbers? How can it calculate the values of mathematical functions? We will understand that the computer can do these things only approximately and will thus always make errors. Numerical Analysis is all about keeping these errors as small as possible while still being able to do efficient calculations.</p>
<p>We will meet the two kinds of errors that a computer makes: <strong>rounding errors</strong> and <strong>truncation errors</strong>. Rounding errors arise from the way the computer needs to approximate real numbers by binary floating point numbers, which are the numbers it know how to add, subtract, multiply and divide. Truncation errors arise from the way the computer needs to reduce all calculations to a finite number of these four basic arithmetic operations. We see that in this chapter when we discuss how computers approximate functions by power series and then have to truncate these at some finite order.</p>
<section id="binary-numbers" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="binary-numbers"><span class="header-section-number">2.1</span> Binary Numbers</h2>
<div id="exr-1.1" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.1</strong></span> By hand (no computers!) compute the first 50 terms of this sequence with the initial condition <span class="math inline">\(x_0 = 1/10\)</span>.</p>
<p><span class="math display">\[\begin{equation}
x_{n+1} = \left\{ \begin{array}{ll} 2x_n, &amp; x_n \in [0,\frac{1}{2}] \\ 2x_n - 1, &amp; x_n \in (\frac{1}{2},1] \end{array} \right.
\end{equation}\]</span></p>
</div>
<hr>
<div id="exr-1.2" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.2</strong></span> Now use a spreadsheet and to do the computations. Do you get the same answers?</p>
</div>
<hr>
<div id="exr-1.3" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.3</strong></span> Finally, solve this problem with Python. Some starter code is given to you below.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="fl">1.0</span><span class="op">/</span><span class="dv">10</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">50</span>):</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> x<span class="op">&lt;=</span> <span class="fl">0.5</span>:</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="co"># put the correct assignment here</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># put the correct assigment here</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr>
<div id="exr-1.4" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.4</strong></span> It seems like the computer has failed you! What do you think happened on the computer and why did it give you a different answer? What, do you suppose, is the cautionary tale hiding behind the scenes with this problem?</p>
</div>
<hr>
<div id="exr-1.5" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.5</strong></span> Now what happens with this problem when you start with <span class="math inline">\(x_0 = 1/8\)</span>? Why does this new initial condition work better?</p>
</div>
<hr>
<p>A computer circuit knows two states: on and off. As such, anything saved in computer memory is stored using base-2 numbers. This is called a binary number system. To fully understand a binary number system it is worth while to pause and reflect on our base-10 number system for a few moments.</p>
<p>What do the digits in the number “735” really mean? The position of each digit tells us something particular about the magnitude of the overall number. The number 735 can be represented as a sum of powers of 10 as</p>
<p><span class="math display">\[\begin{equation}
735 = 700 + 30 + 5 = 7 \times 10^2 + 3 \times 10^1 + 5 \times 10^0
\end{equation}\]</span></p>
<p>and we can read this number as 7 hundreds, 3 tens, and 5 ones. As you can see, in a “positional number system” such as our base-10 system, the position of the number indicates the power of the base, and the value of the digit itself tells you the multiplier of that power. This is contrary to number systems like Roman Numerals where the symbols themselves give us the number, and meaning of the position is somewhat flexible. The number “48,329” can therefore be interpreted as</p>
<p><span class="math display">\[\begin{equation}
\begin{split}
48,329 &amp;= 40,000 + 8,000 + 300 + 20 + 9 \\
&amp;= 4 \times 10^4 + 8 \times 10^3 + 3 \times 10^2 + 2 \times 10^1 + 9 \times 10^0,
\end{split}
\end{equation}\]</span></p>
<p>four ten thousands, eight thousands, three hundreds, two tens, and nine ones.</p>
<p>Now let us switch to the number system used by computers: the binary number system. In a binary number system the base is 2 so the only allowable digits are 0 and 1 (just like in base-10 the allowable digits were 0 through 9). In binary (base-2), the number “101,101” can be interpreted as</p>
<p><span class="math display">\[\begin{equation}
101,101_2 = 1 \times 2^5 + 0 \times 2^4 + 1 \times 2^3 + 1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0
\end{equation}\]</span></p>
<p>(where the subscript “2” indicates the base to the reader). If we put this back into base 10, so that we can read it more comfortably, we get</p>
<p><span class="math display">\[101,101_2 = 32 + 0 + 8 + 4 + 0 + 1 = 45_{10}.\]</span></p>
<p>The reader should take note that the commas in the numbers are only to allow for greater readability – we can easily see groups of three digits and mentally keep track of what we are reading.</p>
<hr>
<div id="exr-1.6" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.6</strong></span> Express the following binary numbers in base-10.</p>
<ol type="1">
<li><p><span class="math inline">\(111_2\)</span></p></li>
<li><p><span class="math inline">\(10,101_2\)</span></p></li>
<li><p><span class="math inline">\(1,111,111,111_2\)</span></p></li>
</ol>
</div>
<hr>
<div id="exr-1.7" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.7</strong></span> Explain the joke: <em>There are 10 types of people. Those who understand binary and those who do not.</em></p>
</div>
<hr>
<div id="exr-1.8" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.8</strong></span> Discussion: With your group, discuss how you would convert a base-10 number into its binary representation. Once you have a proposed method put it into action on the number <span class="math inline">\(237_{10}\)</span> to show that the base-2 expression is <span class="math inline">\(11,101,101_2\)</span>.</p>
</div>
<hr>
<div id="exr-1.9" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.9</strong></span> Convert the following numbers from base 10 to base 2 or visa versa.</p>
<ul>
<li><p>Write <span class="math inline">\(12_{10}\)</span> in binary</p></li>
<li><p>Write <span class="math inline">\(11_{10}\)</span> in binary</p></li>
<li><p>Write <span class="math inline">\(23_{10}\)</span> in binary</p></li>
<li><p>Write <span class="math inline">\(11_2\)</span> in base <span class="math inline">\(10\)</span></p></li>
<li><p>What is <span class="math inline">\(100101_2\)</span> in base <span class="math inline">\(10\)</span>?</p></li>
</ul>
</div>
<hr>
<div id="exr-1.10" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.10</strong></span> Now that you have converted several base-10 numbers to base-2, summarize an efficient technique to do the conversion.</p>
</div>
<hr>
<div id="exm-1.1" class="theorem example">
<p><span class="theorem-title"><strong>Example 2.1</strong></span> Convert the number <span class="math inline">\(137\)</span> from base <span class="math inline">\(10\)</span> to base <span class="math inline">\(2\)</span>.<br>
</p>
</div>
<div class="proof solution">
<p><span class="proof-title"><em>Solution</em>. </span>One way to do the conversion is to first look for the largest power of <span class="math inline">\(2\)</span> less than or equal to your number. In this case, <span class="math inline">\(128=2^7\)</span> is the largest power of <span class="math inline">\(2\)</span> that is less than <span class="math inline">\(137\)</span>. Then looking at the remainder, <span class="math inline">\(9\)</span>, look for the largest power of <span class="math inline">\(2\)</span> that is less than this remainder. Repeat until you have the number.</p>
<p><span class="math display">\[\begin{aligned} 137_{10} &amp;= 128 + 8 + 1 \\ &amp;= 2^7 + 2^3 + 2^0 \\ &amp;= 1 \times 2^7 + 0 \times 2^6 + 0 \times 2^5 + 0 \times 2^4 + 1 \times 2^3 + 0 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 \\ &amp;= 10001001_2 \end{aligned}\]</span></p>
</div>
<hr>
<p>Next we will work with fractions and decimals.</p>
<div id="exm-1.b" class="theorem example">
<p><span class="theorem-title"><strong>Example 2.2</strong></span> Let us take the base <span class="math inline">\(10\)</span> number <span class="math inline">\(5.341_{10}\)</span> and expand it out to get</p>
<p><span class="math display">\[5.341_{10} = 5 + \frac{3}{10} + \frac{4}{100} + \frac{1}{1000} = 5 \times 10^0 + 3 \times 10^{-1} + 4 \times 10^{-2} + 1 \times 10^{-3}.\]</span></p>
<p>The position to the right of the decimal point is the negative power of 10 for the given position.</p>
</div>
<p>We can do a similar thing with binary decimals.</p>
<hr>
<div id="exr-1.11" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.11</strong></span> The base-2 number <span class="math inline">\(1,101.01_2\)</span> can be expanded in powers of <span class="math inline">\(2\)</span>. Fill in the question marks below and observe the pattern in the powers.</p>
<p><span class="math display">\[1,101.01_2 = ? \times 2^3 + 1 \times 2^2 + 0 \times 2^1 + ? \times 2^0 + 0 \times 2^{?} + 1 \times 2^{-2}.\]</span></p>
</div>
<hr>
<div id="exm-1.2" class="theorem example">
<p><span class="theorem-title"><strong>Example 2.3</strong></span> Convert <span class="math inline">\(11.01011_2\)</span> to base <span class="math inline">\(10\)</span>.<br>
<strong>Solution:</strong></p>
<p><span class="math display">\[\begin{aligned} 11.01011_2 &amp;= 2 + 1 + \frac{0}{2} + \frac{1}{4} + \frac{0}{8} + \frac{1}{16} + \frac{1}{32} \\ &amp;= 1 \times 2^1 + 1 \times 2^0 + 0 \times 2^{-1} + 1 \times 2^{-2} + 0 \times 2^{-3} + 1 \times 2^{-4} + 1 \times 2^{-5}\\ &amp;= 3.34375_{10}. \end{aligned}\]</span></p>
</div>
<hr>
<div id="exr-1.12" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.12</strong></span> Repeating digits in binary numbers are rather intriguing. The number <span class="math inline">\(0.\overline{0111} = 0.01110111011101110111\ldots\)</span> surely also has a decimal representation. I will get you started:</p>
<p><span class="math display">\[\begin{aligned} 0.0_2 &amp;= 0 \times 2^0 + 0 \times 2^{-1} = 0.0_{10} \\ 0.01_2 &amp;= 0.0_{10} + 1 \times 2^{-2} = 0.25_{10} \\ 0.011_2 &amp;= 0.25_{10} + 1 \times 2^{-3} = 0.25_{10} + 0.125_{10} = 0.375_{10} \\ 0.0111_2 &amp;= 0.375_{10} + 1 \times 2^{-4} = 0.4375_{10} \\ 0.01110_2 &amp;= 0.4375_{10} + 0 \times 2^{-5} = 0.4375_{10} \\ 0.011101_2 &amp;= 0.4375_{10} + 1 \times 2^{-6} = 0.453125_{10} \\ \vdots &amp; \qquad \qquad \vdots \qquad \qquad \qquad \vdots \end{aligned}\]</span></p>
<p>We want to know what this series converges to in base 10. Work with your partners to approximate the base-10 number.</p>
</div>
<hr>
<div id="exr-1.13" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.13</strong></span> Convert the following numbers from base 10 to binary.</p>
<ol type="1">
<li><p>What is <span class="math inline">\(1/2\)</span> in binary?</p></li>
<li><p>What is <span class="math inline">\(1/8\)</span> in binary?</p></li>
<li><p>What is <span class="math inline">\(4.125\)</span> in binary?</p></li>
<li><p>What is <span class="math inline">\(0.15625\)</span> in binary?</p></li>
</ol>
</div>
<hr>
<div id="exr-1.14" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.14</strong></span> Convert the base <span class="math inline">\(10\)</span> decimal <span class="math inline">\(0.635\)</span> to binary using the following steps.</p>
<ol type="1">
<li><p>Multiply <span class="math inline">\(0.635\)</span> by <span class="math inline">\(2\)</span>. The whole number part of the result is the first binary digit to the right of the decimal point.</p></li>
<li><p>Take the result of the previous multiplication and ignore the digit to the left of the decimal point. Multiply the remaining decimal by <span class="math inline">\(2\)</span>. The whole number part is the second binary decimal digit.</p></li>
<li><p>Repeat the previous step until you have nothing left, until a repeating pattern has revealed itself, or until your precision is close enough.</p></li>
</ol>
<p>Explain why each step gives the binary digit that it does.</p>
</div>
<hr>
<div id="exr-1.15" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.15</strong></span> Based on your previous problem write an algorithm that will convert base-10 decimals (less than 1) to binary.</p>
</div>
<hr>
<div id="exr-1.16" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.16</strong></span> Convert the base <span class="math inline">\(10\)</span> fraction <span class="math inline">\(1/10\)</span> into binary. Use your solution to fully describe what went wrong in the <a href="#exr-1.1" class="quarto-xref">Exercise&nbsp;<span>2.1</span></a>.</p>
</div>
<hr>
</section>
<section id="floating-point-numbers" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="floating-point-numbers"><span class="header-section-number">2.2</span> Floating Point Numbers</h2>
<p>Everything stored in the memory of a computer is a number, but how does a computer actually store a number. More specifically, since computers only have finite memory we would really like to know the full range of numbers that are possible to store in a computer. Clearly, given the uncountable nature of the real numbers, there will be gaps between the numbers that can be stored. We would like to know what gaps in our number system to expect when using a computer to store and do computations on numbers.</p>
<hr>
<div id="exr-1.17" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.17</strong></span> Let us start the discussion with a very concrete example. Consider the number <span class="math inline">\(x = -123.15625\)</span> (in base 10). As we have seen this number can be converted into binary. Indeed</p>
<p><span class="math display">\[x = -123.15625_{10} = -1111011.00101_2\]</span></p>
<p>(you should check this).</p>
<ol type="a">
<li><p>If a computer needs to store this number then first they put in the binary version of scientific notation. In this case we write</p>
<p><span class="math display">\[x = -1. \underline{\hspace{1in}} \times 2^{\underline{\hspace{0.25in}}}\]</span></p></li>
<li><p>Based on the fact that every binary number, other than 0, can be written in this way, what three things do you suppose a computer needs to store for any given number?</p></li>
<li><p>Using your answer to part (b), what would a computer need to store for the binary number <span class="math inline">\(x=10001001.1100110011_2\)</span>?</p></li>
</ol>
</div>
<hr>
<div id="def-1.0" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 2.1</strong></span> For any base-2 number <span class="math inline">\(x\)</span> we can write</p>
<p><span class="math display">\[x = (-1)^{s} \times (1+ m) \times 2^E\]</span></p>
<p>where <span class="math inline">\(s \in \{0,1\}\)</span> and <span class="math inline">\(m\)</span> is a binary number such that <span class="math inline">\(0 \le m &lt; 1\)</span>.</p>
<p>The number <span class="math inline">\(m\)</span> is called the <strong>mantissa</strong> or the <strong>significand</strong>, <span class="math inline">\(s\)</span> is known as the <strong>sign bit</strong>, and <span class="math inline">\(E\)</span> is known as the <strong>exponent</strong>.</p>
</div>
<hr>
<div id="exm-1.3" class="theorem example">
<p><span class="theorem-title"><strong>Example 2.4</strong></span> What are the mantissa, sign bit, and exponent for the numbers <span class="math inline">\(7_{10}, -7_{10}\)</span>, and <span class="math inline">\((0.1)_{10}\)</span>?<br>
<strong>Solution:</strong></p>
<ul>
<li><p>For the number <span class="math inline">\(7_{10}=111_2 = 1.11 \times 2^2\)</span> we have <span class="math inline">\(s=0, m=0.11\)</span> and <span class="math inline">\(E=2\)</span>.</p></li>
<li><p>For the number <span class="math inline">\(-7_{10}=111_2 = -1.11 \times 2^2\)</span> we have <span class="math inline">\(s=1, m=0.11\)</span> and <span class="math inline">\(E=2\)</span>.</p></li>
<li><p>For the number <span class="math inline">\(\frac{1}{10} = 0.000110011001100\cdots = 1.100110011 \times 2^{-4}\)</span> we have <span class="math inline">\(s=0, m=0.100110011\cdots\)</span>, and <span class="math inline">\(E = -4\)</span>.</p></li>
</ul>
</div>
<hr>
<p>In the last part of the previous example we saw that the number <span class="math inline">\((0.1)_{10}\)</span> is actually a repeating decimal in base-2. This means that in order to completely represent the number <span class="math inline">\((0.1)_{10}\)</span> in base-2 we need infinitely many decimal places. Obviously that cannot happen since we are dealing with computers with finite memory. Over the course of the past several decades there have been many systems developed to properly store numbers. The IEEE standard that we now use is the accumulated effort of many computer scientists, much trial and error, and deep scientific research. We now have three standard precisions for storing numbers on a computer: single, double, and extended precision. The double precision standard is what most of our modern computers use.</p>
<hr>
<div id="def-1.1" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 2.2</strong></span> There are two common precisions for storing numbers in a computer.</p>
<ul>
<li><p>A <strong>single-precision</strong> number consists of 32 bits, with 1 bit for the sign, 8 for the exponent, and 23 for the significand.</p></li>
<li><p>A <strong>double-precision</strong> number consists of 64 bits with 1 bit for the sign, 11 for the exponent, and 52 for the significand.</p></li>
</ul>
</div>
<hr>
<div id="def-1.2" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 2.3 (Machine precision)</strong></span> Machine precision is the gap between the number 1 and the next larger floating point number. Often it is represented by the symbol <span class="math inline">\(\epsilon\)</span>. To clarify, the number 1 can always be stored in a computer system exactly and if <span class="math inline">\(\epsilon\)</span> is machine precision for that computer then <span class="math inline">\(1+\epsilon\)</span> is the next largest number that can be stored with that machine.</p>
</div>
<hr>
<p>For all practical purposes the computer cannot tell the difference between two numbers if the difference is smaller than machine precision. This is of the utmost important when you want to check that something is “zero” since a computer just cannot know the difference between <span class="math inline">\(0\)</span> and <span class="math inline">\(\epsilon\)</span>.</p>
<div id="exr-1.18" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.18</strong></span> To make all of these ideas concrete let us play with a small computer system where each number is stored in the following format:</p>
<p><span class="math display">\[s \, E \, b_1 \, b_2 \, b_3\]</span></p>
<p>The first entry is a bit for the sign (<span class="math inline">\(0=+\)</span> and <span class="math inline">\(1=-\)</span>). The second entry, <span class="math inline">\(E\)</span> is for the exponent, and we will assume in this example that the exponent can be 0, 1, or <span class="math inline">\(-1\)</span>. The three bits on the right represent the significand of the number. Hence, every number in this number system takes the form</p>
<p><span class="math display">\[(-1)^s \times (1+ 0.b_1b_2b_3) \times 2^{E}\]</span></p>
<ul>
<li><p>What is the smallest positive number that can be represented in this form?</p></li>
<li><p>What is the largest positive number that can be represented in this form?</p></li>
<li><p>What is the machine precision in this number system?</p></li>
<li><p>What would change if we allowed <span class="math inline">\(E \in \{-2,-1,0,1,2\}\)</span>?</p></li>
</ul>
</div>
<hr>
<div id="exr-1.19" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.19</strong></span> What are the largest and smallest numbers that can be stored in single and double precision?</p>
</div>
<hr>
<div id="exr-1.20" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.20</strong></span> What is machine precision for the single and double precision standard?</p>
</div>
<hr>
<div id="exr-1.20b" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.21</strong></span> What is the gap between <span class="math inline">\(2^n\)</span> and the next largest number that can be stored in double precision?</p>
</div>
<hr>
<!--
::: {#exr-1.21}
Explain the behaviour of the sequence from @exr-1.1 using what you know about how computers store numbers in double precision.

\begin{equation}
x_{n+1} = \left\{ \begin{array}{ll} 2x_n, & x_n \in [0,\frac{1}{2}] \\ 2x_n - 1, & x_n \in
        (\frac{1}{2},1] \end{array} \right. \quad \text{with} \quad x_0 = \frac{1}{10}.
\end{equation}

In particular, now that you know about how numbers are stored in a computer, how long do you expect it to take until the truncation error creeps into the computation?
:::

------------------------------------------------------------------------
-->
<p>Much more can be said about floating point numbers such as how we store infinity, how we store NaN, and how we store 0. The <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic">Wikipedia page for floating point arithmetic</a> might be of interest for the curious reader. It is beyond the scope of this module to go into all of those details here. Instead, the biggest takeaway points from this section and the previous are:</p>
<ul>
<li><p>All numbers in a computer are stored with finite precision.</p></li>
<li><p>Nice numbers like 0.1 are sometimes not machine representable in binary.</p></li>
<li><p>Machine precision is the gap between 1 and the next largest number that can be stored.</p></li>
<li><p>The gap between one number and the next grows in proportion to the number.</p></li>
</ul>
</section>
<section id="loss-of-significant-digits" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="loss-of-significant-digits"><span class="header-section-number">2.3</span> Loss of significant digits</h2>
<p>As we have discussed, when representing real numbers by floating point numbers in the computer, rounding errors will usually occur. However each individual rounding error is only a tiny fraction of the actual number, so should not really matter. However, calculations usually involve a number of steps, and if we are not careful then the rounding errors can get magnified if we perform the steps in an unfortunate way. The following exercises will illustrate this.</p>
<hr>
<div id="exm-r.0" class="theorem example">
<p><span class="theorem-title"><strong>Example 2.5</strong></span> Consider the expression <span class="math display">\[
(10^{10} + 0.123456789) - 10^{10}.
\]</span> Mathematically the two terms of <span class="math inline">\(10^{10}\)</span> simply cancel out leaving just <span class="math inline">\(0.123456789\)</span>. However, let us evaluate this in Python:</p>
<div id="710d834f" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span><span class="op">**</span><span class="dv">10</span> <span class="op">+</span> <span class="fl">0.123456789</span> <span class="op">-</span> <span class="dv">10</span><span class="op">**</span><span class="dv">10</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>0.12345695495605469</code></pre>
</div>
</div>
<p>Only the first six digits after the decimal point were preserved, the other digits were replaced by something seemingly random. The reason should be clear. The computer makes a rounding error when it tries to store the <span class="math inline">\(10000000000.123456789\)</span>. This is known as the loss of significant digits. It occurs whenever you subtract two almost equal numbers from each other.</p>
</div>
<hr>
<div id="exr-r.1" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.22</strong></span> Consider the trigonometric idenity <span class="math display">\[
2\sin^2(x/2) = 1 - \cos(x).
\]</span> It gives us two different methods to calculate the same quantity. Ask Python to evaluate both sides of the identity. If you want to calculate <span class="math inline">\(1 - \cos(x)\)</span> with the highest precision, which expression would you use? Discuss.</p>
</div>
<hr>
<div id="exr-r.2" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.23</strong></span> You know how fo find the solutions to the quadratic equation <span class="math display">\[
a x^2+bx+c=0.
\]</span> You know the quadratic formula. For the larger of the two solutions the formula is <span class="math display">\[
x = \frac{-b+\sqrt{b^2-4ac}}.
\]</span> Let’s assume that the parameters are given as <span class="math display">\[ a = 1,~~~b = 1000000, ~~~ c = 1.\]</span> Use the quadratic formula to find the larger of the two solutions, by coding the formula up in Python. You should get a solution slightly larger than 1. Then check whether your value for <span class="math inline">\(x\)</span> really does solve the quadratic equation by evaluating <span class="math inline">\(ax^2+bx+c\)</span> with your value of <span class="math inline">\(x\)</span>. You will notice that it does not work. Discuss the cause of the error.</p>
<p>Now rearrange the quadratic formula for the larger solution by multiplying both the numerator and denominator by <span class="math inline">\(-b-\sqrt{b^2-4ac}\)</span> and then simplify by multiplying out the resulting numerator. This should give you the alternative formula <span class="math display">\[
x = \frac{2c}{-b-\sqrt{b^2-4ac}}.
\]</span> Can you see why this expression will work better for the given parameter values? Again evaluate <span class="math inline">\(x\)</span> with Python and then check it by substituting into the quadratic expression. What do you find?</p>
</div>
<p>These exercises should suffice to make you sensitive to the issue of loss of significant figures.</p>
<hr>
</section>
<section id="sec-Taylor" class="level2 page-columns page-full" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="sec-Taylor"><span class="header-section-number">2.4</span> Approximating Functions</h2>
<p>How does a computer <em>understand</em> a function like <span class="math inline">\(f(x) = e^x\)</span> or <span class="math inline">\(f(x) = \sin(x)\)</span> or <span class="math inline">\(f(x) = \log(x)\)</span>? What happens under the hood, so to speak, when you ask a computer to do a computation with one of these functions? A computer is darn good at arithmetic, but working with transcendental functions like these, or really any other sufficiently complicated functions for that matter, is not something that comes naturally to a computer. What is actually happening under the hood is that the computer only approximates the functions.</p>
<hr>
<div id="exr-1.22" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.24</strong></span> In this problem we are going to make a bit of a wish list for all of the things that a computer will do when approximating a function. We are going to complete the following sentence:<br>
<em>If we are going to approximate</em> a smooth function <span class="math inline">\(f(x)\)</span> near the point <span class="math inline">\(x=x_0\)</span> with a simpler function <span class="math inline">\(g(x)\)</span> then …</p>
<p>(I will get us started with the first two things that seems natural to wish for. The rest of the wish list is for you to complete.)</p>
<ul>
<li><p>the functions <span class="math inline">\(f(x)\)</span> and <span class="math inline">\(g(x)\)</span> should agree at <span class="math inline">\(x=x_0\)</span>. In other words, <span class="math inline">\(f(x_0) = g(x_0)\)</span></p></li>
<li><p>the function <span class="math inline">\(g(x)\)</span> should only involve addition, subtraction, multiplication, division, and integer exponents since computer are very good at those sorts of operations.</p></li>
<li><p>if <span class="math inline">\(f(x)\)</span> is increasing / decreasing near <span class="math inline">\(x=x_0\)</span> then <span class="math inline">\(g(x)\)</span> …</p></li>
<li><p>if <span class="math inline">\(f(x)\)</span> is concave up / down near <span class="math inline">\(x=x_0\)</span> then <span class="math inline">\(g(x)\)</span>…</p></li>
<li><p>if we zoom into plots of the functions <span class="math inline">\(f(x)\)</span> and <span class="math inline">\(g(x)\)</span> near <span class="math inline">\(x=x_0\)</span> then …</p></li>
<li><p>… is there anything else that you would add?</p></li>
</ul>
</div>
<hr>
<div id="exr-1.23" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.25</strong></span> Discuss: Could a polynomial function with a high enough degree satisfy everything in the wish list from the previous problem? Explain your reasoning.</p>
</div>
<hr>
<div id="exr-1.24" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.26</strong></span> Let us put some parts of the wish list into action. If <span class="math inline">\(f(x)\)</span> is a differentiable function at <span class="math inline">\(x=x_0\)</span> and if <span class="math inline">\(g(x) = A + B (x-x_0) + C (x-x_0)^2 + D (x-x_0)^3\)</span> then</p>
<ol type="1">
<li><p>What is the value of <span class="math inline">\(A\)</span> such that <span class="math inline">\(f(x_0) = g(x_0)\)</span>? <em>(Hint: substitute</em> <span class="math inline">\(x=x_0\)</span> into the <span class="math inline">\(g(x)\)</span> function)</p></li>
<li><p>What is the value of <span class="math inline">\(B\)</span> such that <span class="math inline">\(f'(x_0) = g'(x_0)\)</span>? <em>(Hint: Start by taking the derivative of</em> <span class="math inline">\(g(x)\)</span>)</p></li>
<li><p>What is the value of <span class="math inline">\(C\)</span> such that <span class="math inline">\(f''(x_0) = g''(x_0)\)</span>?</p></li>
<li><p>What is the value of <span class="math inline">\(D\)</span> such that <span class="math inline">\(f'''(x_0) = g'''(x_0)\)</span>?</p></li>
</ol>
</div>
<hr>
<div id="exr-1.25" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.27</strong></span> Let <span class="math inline">\(f(x) = e^x\)</span>. Put the answers to the previous question into action and build a cubic polynomial that approximates <span class="math inline">\(f(x) = e^x\)</span> near <span class="math inline">\(x_0=0\)</span>.</p>
</div>
<hr>
<p>In the previous 4 exercises you have built up some basic intuition for what we would want out of a mathematical operation that might build an approximation of a complicated function. What we have built is actually a way to get better and better approximations for functions out to pretty much any arbitrary accuracy that we like so long as we are near some anchor point (which we called <span class="math inline">\(x_0\)</span> in the previous exercises).</p>
<p>In the next several problems you will unpack the approximations of <span class="math inline">\(f(x) = e^x\)</span> a bit more carefully and we will wrap the whole discussion with a little bit of formal mathematical language. Then we will examine other functions like sine, cosine, logarithms, etc. One of the points of this whole discussion is to give you a little glimpse as to what is happening behind the scenes in scientific programming languages when you do computations with these functions. A bigger point is to start getting a feel for how we might go in reverse and approximate an unknown function out of much simpler parts. This last goal is one of the big takeaways from numerical analysis: <em>we can mathematically model highly complicated functions out of fairly simple pieces.</em></p>
<hr>
<div id="exr-1.26" class="theorem exercise page-columns page-full">
<p><span class="theorem-title"><strong>Exercise 2.28</strong></span> What is Euler’s number <span class="math inline">\(e\)</span>? You likely remember using this number often in Calculus and Differential Equations. Do you know the decimal approximation for this number? Moreover, is there a way that we could approximate something like <span class="math inline">\(\sqrt{e} = e^{0.5}\)</span> or <span class="math inline">\(e^{-1}\)</span> without actually having access to the full decimal expansion?</p>
<p>For all of the questions below let us work with the function <span class="math inline">\(f(x) = e^x\)</span>.</p>
<ol type="1">
<li><p>The function <span class="math inline">\(g(x) = 1\)</span> matches <span class="math inline">\(f(x) = e^x\)</span> exactly at the point <span class="math inline">\(x=0\)</span> since <span class="math inline">\(f(0) = e^0 = 1\)</span>. Furthermore if <span class="math inline">\(x\)</span> is very very close to <span class="math inline">\(0\)</span> then the functions <span class="math inline">\(f(x)\)</span> and <span class="math inline">\(g(x)\)</span> are really close to each other. Hence we could say that <span class="math inline">\(g(x) = 1\)</span> is an approximation of the function <span class="math inline">\(f(x) = e^x\)</span> for values of <span class="math inline">\(x\)</span> very very close to <span class="math inline">\(x=0\)</span>. Admittedly, though, it is probably pretty clear that this is a horrible approximation for any <span class="math inline">\(x\)</span> just a little bit away from <span class="math inline">\(x=0\)</span>.</p></li>
<li><p>Let us get a better approximation. What if we insist that our approximation <span class="math inline">\(g(x)\)</span> matches <span class="math inline">\(f(x) = e^x\)</span> exactly at <span class="math inline">\(x=0\)</span> and ALSO has exactly the same first derivative as <span class="math inline">\(f(x)\)</span> at <span class="math inline">\(x=0\)</span>.</p>
<ol type="1">
<li><p>What is the first derivative of <span class="math inline">\(f(x)\)</span>?</p></li>
<li><p>What is <span class="math inline">\(f'(0)\)</span>?</p></li>
<li><p>Use the point-slope form of a line to write the equation of the function <span class="math inline">\(g(x)\)</span> that goes through the point <span class="math inline">\((0,f(0))\)</span> and has slope <span class="math inline">\(f'(0)\)</span>. Recall from algebra that the point-slope form of a line is <span class="math inline">\(y = f(x_0) + m(x-x_0).\)</span> In this case we are taking <span class="math inline">\(x_0 = 0\)</span> so we are using the formula <span class="math inline">\(g(x) = f(0) + f'(0) (x-0)\)</span> to get the equation of the line.</p></li>
</ol></li>
<li><p>Write Python code to build a plot like <a href="#fig-1.1" class="quarto-xref">Figure&nbsp;<span>2.1</span></a>. This plot shows <span class="math inline">\(f(x) = e^x\)</span>, our first approximation <span class="math inline">\(g(x) = 1\)</span> and our second approximation <span class="math inline">\(g(x) = 1+x\)</span>. You may want to refer back to <a href="nmPython.html#exr-A.19" class="quarto-xref">Exercise&nbsp;<span>1.22</span></a> in the Python chapter.</p></li>
</ol>
<div id="cell-fig-1.1" class="cell page-columns page-full" data-execution_count="3">
<div class="cell-output cell-output-display page-columns page-full">
<div id="fig-1.1" class="quarto-figure quarto-figure-left quarto-float anchored page-columns page-full" alt="The first two polynomial approximations of the exponential function.">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-1.1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca" class="page-columns page-full">
<img src="nmApprox_files/figure-html/fig-1.1-output-1.png" alt="The first two polynomial approximations of the exponential function." width="571" height="433" class="figure-img column-page-right">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-1.1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.1: The first two polynomial approximations of the exponential function.
</figcaption>
</figure>
</div>
</div>
</div>
</div>
<div id="exr-1.27" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.29</strong></span> Let us extend the idea from the previous problem to much better approximations of the function <span class="math inline">\(f(x) = e^x\)</span>.</p>
<ol type="1">
<li><p>Let us build a function <span class="math inline">\(g(x)\)</span> that matches <span class="math inline">\(f(x)\)</span> exactly at <span class="math inline">\(x=0\)</span>, has exactly the same first derivative as <span class="math inline">\(f(x)\)</span> at <span class="math inline">\(x=0\)</span>, AND has exactly the same second derivative as <span class="math inline">\(f(x)\)</span> at <span class="math inline">\(x=0\)</span>. To do this we will use a quadratic function. For a quadratic approximation of a function we just take a slight extension to the point-slope form of a line and use the equation <span class="math display">\[\begin{equation}
y = f(x_0) + f'(x_0) (x-x_0) + \frac{f''(x_0)}{2} (x-x_0)^2.
\end{equation}\]</span> In this case we are using <span class="math inline">\(x_0 = 0\)</span> so the quadratic approximation function looks like <span class="math display">\[\begin{equation}
y = f(0) + f'(0) x + \frac{f''(0)}{2} x^2.
\end{equation}\]</span></p>
<ol type="1">
<li><p>Find the quadratic approximation for <span class="math inline">\(f(x) = e^x\)</span>.</p></li>
<li><p>How do you know that this function matches <span class="math inline">\(f(x)\)</span> is all of the ways described above at <span class="math inline">\(x=0\)</span>?</p></li>
<li><p>Add your new function to the plot you created in the previous problem.</p></li>
</ol></li>
<li><p>Let us keep going!! Next we will do a cubic approximation. A cubic approximation takes the form <span class="math display">\[\begin{equation}
y = f(x_0) + f'(0) (x-x_0) + \frac{f''(0)}{2}(x-x_0)^2 + \frac{f'''(0)}{3!}(x-x_0)^3
\end{equation}\]</span></p>
<ol type="1">
<li><p>Find the cubic approximation for <span class="math inline">\(f(x) = e^x\)</span>.</p></li>
<li><p>How do we know that this function matches the first, second, and third derivatives of <span class="math inline">\(f(x)\)</span> at <span class="math inline">\(x=0\)</span>?</p></li>
<li><p>Add your function to the plot.</p></li>
<li><p>Pause and think: What’s the deal with the <span class="math inline">\(3!\)</span> on the cubic term?</p></li>
</ol></li>
<li><p>Your turn: Build the next several approximations of <span class="math inline">\(f(x) = e^x\)</span> at <span class="math inline">\(x=0\)</span>. Add these plots to the plot that we have been building all along.</p></li>
</ol>
</div>
<hr>
<div id="exr-1.30" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.30</strong></span> Use the functions that you have built to approximate <span class="math inline">\(\frac{1}{e} = e^{-1}\)</span>. Check the accuracy of your answer using <code>np.exp(-1)</code> in Python.</p>
</div>
<hr>
<p>What we have been exploring so far in this section is the <strong>Taylor Series</strong> of a function.</p>
<div id="def-1.3" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 2.4 (Taylor Series)</strong></span> If <span class="math inline">\(f(x)\)</span> is an infinitely differentiable function at the point <span class="math inline">\(x_0\)</span> then <span class="math display">\[\begin{equation}
f(x) = f(x_0) + f'(x_0)(x-x_0) + \frac{f''(x_0)}{2}(x-x_0)^2 + \cdots \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n + \cdots
\end{equation}\]</span> for any reasonably small interval around <span class="math inline">\(x_0\)</span>. The infinite polynomial expansion is called the <strong>Taylor Series</strong> of the function <span class="math inline">\(f(x)\)</span>. Taylor Series are named for the mathematician <a href="https://en.wikipedia.org/wiki/Brook_Taylor">Brook Taylor</a>.</p>
</div>
<hr>
<p>The Taylor Series of a function is often written with summation notation as <span class="math display">\[\begin{equation}
f(x) = \sum_{k=0}^\infty \frac{f^{(k)}(x_0)}{k!} (x-x_0)^k.
\end{equation}\]</span> Do not let the notation scare you. In a Taylor Series you are just saying: <em>give me a function that</em></p>
<ul>
<li><p><em>matches</em> <span class="math inline">\(f(x)\)</span> at <span class="math inline">\(x=x_0\)</span> exactly,</p></li>
<li><p><em>matches</em> <span class="math inline">\(f'(x)\)</span> at <span class="math inline">\(x=x_0\)</span> exactly,</p></li>
<li><p><em>matches</em> <span class="math inline">\(f''(x)\)</span> at <span class="math inline">\(x=x_0\)</span> exactly,</p></li>
<li><p><em>matches</em> <span class="math inline">\(f'''(x)\)</span> at <span class="math inline">\(x=x_0\)</span> exactly,</p></li>
<li><p>etc.</p></li>
</ul>
<p>(Take a moment and make sure that the summation notation makes sense to you.)</p>
<p>Moreover, Taylor Series are built out of the easiest types of functions: polynomials. Computers are rather good at doing computations with addition, subtraction, multiplication, division, and integer exponents, so Taylor Series are a natural way to express functions in a computer. The down side is that we can only get true equality in the Taylor Series if we have infinitely many terms in the series. A computer cannot do infinitely many computations. So, in practice, we truncate Taylor Series after many terms and think of the new polynomial function as being <em>close enough</em> to the actual function so far as we do not stray too far from the anchor <span class="math inline">\(x_0\)</span>.</p>
<hr>
<div id="exr-1.31" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.31</strong></span> Verify from your previous work that the Taylor Series centred at <span class="math inline">\(x_0 = 0\)</span> for <span class="math inline">\(f(x) = e^x\)</span> is indeed <span class="math display">\[\begin{equation}
e^x = 1 + x + \frac{x^2}{2} + \frac{x^3}{3!} + \frac{x^4}{4!} + \frac{x^5}{5!} + \cdots.
\end{equation}\]</span></p>
</div>
<hr>
<div id="exr-1.32" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.32</strong></span> Do all of the calculations to show that the Taylor Series centred at <span class="math inline">\(x_0 = 0\)</span> for the function <span class="math inline">\(f(x) = \sin(x)\)</span> is indeed <span class="math display">\[\begin{equation}
\sin(x) = x - \frac{x^3}{3!} + \frac{x^5}{5!} - \frac{x^7}{7!} + \cdots
\end{equation}\]</span></p>
</div>
<hr>
<div id="exr-1.33" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.33</strong></span> Do all of the calculations to show that the Taylor Series centred at <span class="math inline">\(x_0 = 0\)</span> for the function <span class="math inline">\(f(x) = \cos(x)\)</span> is indeed <span class="math display">\[\begin{equation}
\cos(x) = 1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \frac{x^6}{6!} + \cdots
\end{equation}\]</span></p>
</div>
<hr>
<div id="exr-1.34" class="theorem exercise page-columns page-full">
<p><span class="theorem-title"><strong>Exercise 2.34</strong></span> Let us compute a few Taylor Series that are not centred at <span class="math inline">\(x_0 = 0\)</span>. For example, let us approximate the function <span class="math inline">\(f(x) = \sin(x)\)</span> near <span class="math inline">\(x_0 = \frac{\pi}{2}\)</span>. Near the point <span class="math inline">\(x_0 = \frac{\pi}{2}\)</span>, the Taylor Series approximation will take the form <span class="math display">\[\begin{equation}
f(x) = f\left( \frac{\pi}{2} \right) + f'\left( \frac{\pi}{2} \right)\left( x - \frac{\pi}{2} \right) + \frac{f''\left( \frac{\pi}{2} \right)}{2!}\left( x - \frac{\pi}{2} \right)^2 + \frac{f'''\left( \frac{\pi}{2} \right)}{3!}\left( x - \frac{\pi}{2} \right)^3 + \cdots
\end{equation}\]</span></p>
<p>Write the first several terms of the Taylor Series for <span class="math inline">\(f(x) = \sin(x)\)</span> centred at <span class="math inline">\(x_0 = \frac{\pi}{2}\)</span>. Then write Python code to build the plot below showing successive approximations for <span class="math inline">\(f(x) = \sin(x)\)</span> centred at <span class="math inline">\(\pi/2\)</span>.</p>
<div id="cell-fig-1.2" class="cell page-columns page-full" data-execution_count="4">
<div class="cell-output cell-output-display page-columns page-full">
<div id="fig-1.2" class="quarto-figure quarto-figure-left quarto-float anchored page-columns page-full" alt="Taylor series approximation of the sine function.">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-1.2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca" class="page-columns page-full">
<img src="nmApprox_files/figure-html/fig-1.2-output-1.png" alt="Taylor series approximation of the sine function." width="582" height="432" class="figure-img column-page-right">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-1.2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.2: Taylor series approximation of the sine function.
</figcaption>
</figure>
</div>
</div>
</div>
</div>
<hr>
<div id="exr-1.35" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.35</strong></span> Repeat the previous exercise for the function <span class="math display">\[
f(x) = \log(x) \text{ centered at } x_0 = 1.
\]</span> Use this to give an approximate value for <span class="math inline">\(\log(1.1)\)</span>.</p>
</div>
<hr>
<div id="exm-1.4" class="theorem example page-columns page-full">
<p><span class="theorem-title"><strong>Example 2.6</strong></span> Let us conclude this brief section by examining an interesting example. Consider the function <span class="math display">\[\begin{equation}
f(x) = \frac{1}{1-x}.
\end{equation}\]</span> If we build a Taylor Series centred at <span class="math inline">\(x_0 = 0\)</span> it is not too hard to show that we get <span class="math display">\[\begin{equation}
f(x) = 1 + x + x^2 + x^3 + x^4 + x^5 + \cdots
\end{equation}\]</span> (you should stop now and verify this!). However, if we plot the function <span class="math inline">\(f(x)\)</span> along with several successive approximations for <span class="math inline">\(f(x)\)</span> we find that beyond <span class="math inline">\(x=1\)</span> we do not get the correct behaviour of the function (see <a href="#fig-1.3" class="quarto-xref">Figure&nbsp;<span>2.3</span></a>). More specifically, we cannot get the Taylor Series to change behaviour across the vertical asymptote of the function at <span class="math inline">\(x=1\)</span>. This example is meant to point out the fact that a Taylor Series will only ever make sense <em>near</em> the point at which you centre the expansion. For the function <span class="math inline">\(f(x) = \frac{1}{1-x}\)</span> centred at <span class="math inline">\(x_0 = 0\)</span> we can only get good approximations within the interval <span class="math inline">\(x \in (-1,1)\)</span> and no further.</p>
<div id="cell-fig-1.3" class="cell page-columns page-full" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math <span class="im">as</span> ma</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co"># build the x and y values</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">101</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>y0 <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>(<span class="dv">1</span><span class="op">-</span>x)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>y1 <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">0</span><span class="op">*</span>x</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>y2 <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> x</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>y3 <span class="op">=</span> y2 <span class="op">+</span> x<span class="op">**</span><span class="dv">2</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>y4 <span class="op">=</span> y3 <span class="op">+</span> x<span class="op">**</span><span class="dv">3</span> <span class="op">+</span> x<span class="op">**</span><span class="dv">4</span> <span class="op">+</span> x<span class="op">**</span><span class="dv">5</span> <span class="op">+</span> x<span class="op">**</span><span class="dv">6</span> <span class="op">+</span> x<span class="op">**</span><span class="dv">7</span> <span class="op">+</span> x<span class="op">**</span><span class="dv">8</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co"># plot each of the functions </span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>plt.plot(x, y0, <span class="st">'r-'</span>, label<span class="op">=</span><span class="vs">r"$f(x)=\sin(x)"</span>)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>plt.plot(x, y1, <span class="st">'c-'</span>, label<span class="op">=</span><span class="vs">r"constant"</span>)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>plt.plot(x, y2, <span class="st">'g:'</span>, label<span class="op">=</span><span class="vs">r"linear"</span>)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>plt.plot(x, y3, <span class="st">'b-.'</span>, label<span class="op">=</span><span class="vs">r"quadratic"</span>)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>plt.plot(x, y4, <span class="st">'k--'</span>, label<span class="op">=</span><span class="vs">r"8th order"</span>)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="co"># set limits on the y axis</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="op">-</span><span class="dv">3</span>,<span class="dv">5</span>)</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="co"># put in a grid, legend, title, and axis labels</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Taylor approximations of $f(x)=1/(1-x)$ around $x=0$"</span>)</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display page-columns page-full">
<div id="fig-1.3" class="quarto-figure quarto-figure-left quarto-float anchored page-columns page-full" alt="Several Taylor Series approximations of the function $f(x) = 1/(1-x)$.">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-1.3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca" class="page-columns page-full">
<img src="nmApprox_files/figure-html/fig-1.3-output-1.png" alt="Several Taylor Series approximations of the function $f(x) = 1/(1-x)$." width="569" height="432" class="figure-img column-page-right">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-1.3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.3: Several Taylor Series approximations of the function <span class="math inline">\(f(x) = 1/(1-x)\)</span>.
</figcaption>
</figure>
</div>
</div>
</div>
</div>
<hr>
<p>In the previous example we saw that we cannot always get approximations from Taylor Series that are good everywhere. For every Taylor Series there is a <strong>domain of convergence</strong> where the Taylor Series actually makes sense and gives good approximations. While it is beyond the scope of this section to give all of the details for finding the domain of convergence for a Taylor Series, a good heuristic is to observe that a Taylor Series will only give reasonable approximations of a function from the centre of the series to the nearest asymptote. The domain of convergence is typically symmetric about the centre as well. For example:</p>
<ul>
<li><p>If we were to build a Taylor Series approximation for the function <span class="math inline">\(f(x) = \log(x)\)</span> centred at the point <span class="math inline">\(x_0 = 1\)</span> then the domain of convergence should be <span class="math inline">\(x \in (0,2)\)</span> since there is a vertical asymptote for the natural logarithm function at <span class="math inline">\(x=0\)</span>.</p></li>
<li><p>If we were to build a Taylor Series approximation for the function <span class="math inline">\(f(x) = \frac{5}{2x-3}\)</span> centred at the point <span class="math inline">\(x_0 = 4\)</span> then the domain of convergence should be <span class="math inline">\(x \in (1.5, 6.5)\)</span> since there is a vertical asymptote at <span class="math inline">\(x=1.5\)</span> and the distance from <span class="math inline">\(x_0 = 4\)</span> to <span class="math inline">\(x=1.5\)</span> is 2.5 units.</p></li>
<li><p>If we were to build a Taylor Series approximation for the function <span class="math inline">\(f(x) = \frac{1}{1+x^2}\)</span> centred at the point <span class="math inline">\(x_0 = 0\)</span> then the domain of convergence should be <span class="math inline">\(x \in (-1,1)\)</span>. This may seem quite odd (and perhaps quite surprising!) but let us think about where the nearest asymptote might be. To find the asymptote we need to solve <span class="math inline">\(1+x^2 = 0\)</span> but this gives us the values <span class="math inline">\(x = \pm i\)</span>. In the complex plane, the numbers <span class="math inline">\(i\)</span> and <span class="math inline">\(-i\)</span> are 1 unit away from <span class="math inline">\(x_0 = 0\)</span>, so the “asymptote” is not visible in a real-valued plot but it is still only one unit away. Hence the domain of convergence is <span class="math inline">\(x \in (-1,1)\)</span>. You may want to pause now and build some plots to show yourself that this indeed appears to be true.</p></li>
</ul>
<p>A Taylor Series will give good approximations to the function within the domain of convergence, but will give garbage outside of it. For more details about the domain of convergence of a Taylor Series you can refer to the <a href="https://activecalculus.org/single/sec-8-5-taylor.html">Taylor Series section of the online Active Calculus Textbook</a> [2].</p>
</section>
<section id="truncation-error" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="truncation-error"><span class="header-section-number">2.5</span> Truncation Error</h2>
<p>The great thing about Taylor Series is that they allow for the representation of potentially very complicated functions as polynomials – and polynomials are easily dealt with on a computer since they involve only addition, subtraction, multiplication, division, and integer powers. The down side is that the order of the polynomial is infinite. Hence, every time we use a Taylor series on a computer we are actually going to be using is a <strong>Truncated Taylor Series</strong> where we only take a finite number of terms. The idea here is simple in principle:</p>
<ul>
<li><p>If a function <span class="math inline">\(f(x)\)</span> has a Taylor Series representation it can be written as an infinite sum.</p></li>
<li><p>Computers cannot do infinite sums.</p></li>
<li><p>So stop the sum at some point <span class="math inline">\(n\)</span> and throw away the rest of the infinite sum.</p></li>
<li><p>Now <span class="math inline">\(f(x)\)</span> is approximated by some finite sum so long as you stay pretty close to <span class="math inline">\(x = x_0\)</span>,</p></li>
<li><p>and everything that we just chopped off of the end is called the <strong>remainder</strong> for the finite sum.</p></li>
</ul>
<p>Let us be a bit more concrete about it. The Taylor Series for <span class="math inline">\(f(x) = e^x\)</span> centred at <span class="math inline">\(x_0 = 0\)</span> is <span class="math display">\[\begin{equation}
e^x = 1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \frac{x^4}{4!} + \cdots.
\end{equation}\]</span></p>
<dl>
<dt><span class="math inline">\(0^{th}\)</span> Order Approximation of <span class="math inline">\(f(x) = e^x\)</span>:</dt>
<dd>
<p>If we want to use a zeroth-order (constant) approximation <span class="math inline">\(f_0(x)\)</span> of the function <span class="math inline">\(f(x) = e^x\)</span> then we only take the first term in the Taylor Series and the rest is not used for the approximation <span class="math display">\[\begin{equation}
e^x = \underbrace{1}_{\text{$0^{th}$ order approximation}} + \underbrace{x + \frac{x^2}{2!} + \frac{x^3}{3!} + \frac{x^4}{4!} + \cdots}_{\text{remainder}}.
\end{equation}\]</span> Therefore we would approximate <span class="math inline">\(e^x\)</span> as <span class="math inline">\(e^x \approx 1=f_0(x)\)</span> for values of <span class="math inline">\(x\)</span> that are close to <span class="math inline">\(x_0 = 0\)</span>. Furthermore, for small values of <span class="math inline">\(x\)</span> that are close to <span class="math inline">\(x_0 = 0\)</span> the largest term in the remainder is <span class="math inline">\(x\)</span> (since for small values of <span class="math inline">\(x\)</span> like 0.01, <span class="math inline">\(x^2\)</span> will be even smaller, <span class="math inline">\(x^3\)</span> even smaller than that, etc). This means that if we use a <span class="math inline">\(0^{th}\)</span> order approximation for <span class="math inline">\(e^x\)</span> then we expect our error to be about the same size as <span class="math inline">\(x\)</span>. It is common to then rewrite the truncated Taylor Series as <span class="math display">\[\begin{equation}
\text{$0^{th}$ order approximation: } e^x \approx 1 + \mathcal{O}(x)
\end{equation}\]</span> where <span class="math inline">\(\mathcal{O}(x)\)</span> (read “Big-O of <span class="math inline">\(x\)</span>”) tells us that the expected error for approximations close to <span class="math inline">\(x_0 = 0\)</span> is about the same size as <span class="math inline">\(x\)</span>.</p>
</dd>
<dt><span class="math inline">\(1^{st}\)</span> Order Approximation of <span class="math inline">\(f(x) = e^x\)</span>:</dt>
<dd>
<p>If we want to use a first-order (linear) approximation <span class="math inline">\(f_1(x)\)</span> of the function <span class="math inline">\(f(x) = e^x\)</span> then we gather the <span class="math inline">\(0^{th}\)</span> order and <span class="math inline">\(1^{st}\)</span> order terms together as our approximation and the rest is the remainder <span class="math display">\[\begin{equation}
e^x = \underbrace{1 + x}_{\text{$1^{st}$ order approximation}} + \underbrace{\frac{x^2}{2!} + \frac{x^3}{3!} + \frac{x^4}{4!} + \cdots}_{\text{remainder}}.
\end{equation}\]</span> Therefore we would approximate <span class="math inline">\(e^x\)</span> as <span class="math inline">\(e^x \approx 1+x=f_1(x)\)</span> for values of <span class="math inline">\(x\)</span> that are close to <span class="math inline">\(x_0 = 0\)</span>. Furthermore, for values of <span class="math inline">\(x\)</span> very close to <span class="math inline">\(x_0 = 0\)</span> the largest term in the remainder is the <span class="math inline">\(x^2\)</span> term. Using Big-O notation we can write the approximation as <span class="math display">\[\begin{equation}
\text{$1^{st}$ order approximation: } e^x \approx 1 + x + \mathcal{O}(x^2).
\end{equation}\]</span> Notice that we do not explicitly say what the coefficient is for the <span class="math inline">\(x^2\)</span> term. Instead we are just saying that <em>using the linear function</em> <span class="math inline">\(y=1+x\)</span> to approximate <span class="math inline">\(e^x\)</span> for values of <span class="math inline">\(x\)</span> near <span class="math inline">\(x_0=0\)</span> will result in errors that are of the order of <span class="math inline">\(x^2\)</span>.</p>
</dd>
<dt><span class="math inline">\(2^{nd}\)</span> Order Approximation of <span class="math inline">\(f(x) = e^x\)</span>:</dt>
<dd>
<p>If we want to use a second-order (quadratic) approximation <span class="math inline">\(f_2(x)\)</span> of the function of <span class="math inline">\(f(x) = e^x\)</span> then we gather the <span class="math inline">\(0^{th}\)</span> order, <span class="math inline">\(1^{st}\)</span> order, and <span class="math inline">\(2^{nd}\)</span> order terms together as our approximation and the rest is the remainder <span class="math display">\[\begin{equation}
e^x = \underbrace{1 + x + \frac{x^2}{2!}}_{\text{$2^{nd}$ order approximation}} + \underbrace{\frac{x^3}{3!} + \frac{x^4}{4!} + \cdots}_{\text{remainder}}.
\end{equation}\]</span> Therefore we would approximate <span class="math inline">\(e^x\)</span> as <span class="math inline">\(e^x \approx 1+x+\frac{x^2}{2}=f_2(x)\)</span> for values of <span class="math inline">\(x\)</span> that are close to <span class="math inline">\(x_0 = 0\)</span>. Furthermore, for values of <span class="math inline">\(x\)</span> very close to <span class="math inline">\(x_0 = 0\)</span> the largest term in the remainder is the <span class="math inline">\(x^3\)</span> term. Using Big-O notation we can write the approximation as <span class="math display">\[\begin{equation}
\text{$2^{nd}$ order approximation: } e^x \approx 1 + x + \frac{x^2}{2} + \mathcal{O}(x^3).
\end{equation}\]</span> Again notice that we do not explicitly say what the coefficient is for the <span class="math inline">\(x^3\)</span> term. Instead we are just saying that <em>using the quadratic function</em> <span class="math inline">\(y=1+x+\frac{x^2}{2}\)</span> to approximate <span class="math inline">\(e^x\)</span> for values of <span class="math inline">\(x\)</span> near <span class="math inline">\(x_0=0\)</span> will result in errors that are of the order of <span class="math inline">\(x^3\)</span>.</p>
</dd>
</dl>
<p>Keep in mind that this sort of analysis is only good for values of <span class="math inline">\(x\)</span> that are very close to the centre of the Taylor Series. If you are making approximations that are too far away then all bets are off.</p>
<p>For the function <span class="math inline">\(f(x) = e^x\)</span> the idea of approximating the amount of approximation error by truncating the Taylor Series is relatively straight forward: if we want an <span class="math inline">\(n^{th}\)</span> order polynomial approximation <span class="math inline">\(f_n(x)\)</span> of the function of <span class="math inline">\(f(x)=e^x\)</span> near <span class="math inline">\(x_0 = 0\)</span> then <span class="math display">\[\begin{equation}
e^x = 1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \frac{x^4}{4!} + \cdots + \frac{x^n}{n!} + \mathcal{O}(x^{n+1}),
\end{equation}\]</span> meaning that we expect the error to be of the order of <span class="math inline">\(x^{n+1}\)</span>.</p>
<hr>
<div id="exr-1.38" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.36</strong></span> Now make the previous discussion a bit more concrete. You know the Taylor Series for <span class="math inline">\(f(x) = e^x\)</span> around <span class="math inline">\(x=0\)</span> quite well at this point so use it to approximate the values of <span class="math inline">\(f(0.1) = e^{0.1}\)</span> and <span class="math inline">\(f(0.2)=e^{0.2}\)</span> by truncating the Taylor series at different orders. Because <span class="math inline">\(x=0.1\)</span> and <span class="math inline">\(x=0.2\)</span> are pretty close to the centre of the Taylor Series <span class="math inline">\(x_0 = 0\)</span>, this sort of approximation is reasonable.</p>
<p>Then compare your approximate values to Python’s values <span class="math inline">\(f(0.1)=e^{0.1} \approx\)</span> <code>np.exp(0.1)</code> <span class="math inline">\(=1.1051709180756477\)</span> and <span class="math inline">\(f(0.2)=e^{0.2} \approx\)</span> <code>np.exp(0.2)</code> <span class="math inline">\(=1.2214027581601699\)</span> to calculate the truncation errors <span class="math inline">\(\epsilon_n(0.1)=|f(0.1)-f_n(0.1)|\)</span> and <span class="math inline">\(\epsilon_n(0.2)=|f(0.2)-f_n(0.2)|\)</span>.</p>
<p>Fill in the blanks in the table. If you want to create the table in your jupyter notebook, you can use Pandas as described in <a href="nmPython.html#sec-pandas" class="quarto-xref"><span>Section 1.7</span></a>. Alternatively feel free to use a spreadsheet instead of using Python.</p>
<table class="table">
<colgroup>
<col style="width: 19%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th>Order <span class="math inline">\(n\)</span></th>
<th><span class="math inline">\(f_n(0.1)\)</span></th>
<th><span class="math inline">\(\epsilon_n(0.1)=|f(0.1)-f_n(0.1)|\)</span></th>
<th><span class="math inline">\(f_n(0.2)\)</span></th>
<th><span class="math inline">\(\epsilon_n(0.2)=|f(0.2)-f_n(0.2)|\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>1.051709e-01</td>
<td>1</td>
<td>2.214028e-01</td>
</tr>
<tr class="even">
<td>1</td>
<td>1.1</td>
<td>5.170918e-03</td>
<td>1.2</td>
<td></td>
</tr>
<tr class="odd">
<td>2</td>
<td>1.105</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>You will find that, as expected, the truncation errors <span class="math inline">\(\epsilon_n(x)\)</span> decrease with <span class="math inline">\(n\)</span> but increase with <span class="math inline">\(x\)</span>.</p>
<hr>
<div id="exr-1.39b" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.37</strong></span> To investigate the dependence of the truncation error <span class="math inline">\(\epsilon_n(x)\)</span> on <span class="math inline">\(n\)</span> and <span class="math inline">\(x\)</span> a bit more, add an extra column to the table from the previous exercise with the ratio <span class="math inline">\(\epsilon_n(0.2) / \epsilon_n(0.1)\)</span>.</p>
<table class="table">
<colgroup>
<col style="width: 23%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>Order <span class="math inline">\(n\)</span></th>
<th><span class="math inline">\(\epsilon_n(0.1)\)</span></th>
<th><span class="math inline">\(\epsilon_n(0.2)\)</span></th>
<th><span class="math inline">\(\epsilon_n(0.2) / \epsilon_n(0.1)\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>1.051709e-01</td>
<td>2.214028e-01</td>
<td>2.105171</td>
</tr>
<tr class="even">
<td>1</td>
<td>5.170918e-03</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>4</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>5</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Formulate a conjecture about how <span class="math inline">\(\epsilon_n\)</span> changes as <span class="math inline">\(x\)</span> changes.</p>
</div>
<hr>
<div id="exr-1.39" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.38</strong></span> To test your conjecture, examine the truncation error for the sine function near <span class="math inline">\(x_0 = 0\)</span>. You know that the sine function has the Taylor Series centred at <span class="math inline">\(x_0 = 0\)</span> as <span class="math display">\[\begin{equation}
f(x) = \sin(x) = x - \frac{x^3}{3!} + \frac{x^5}{5!} - \frac{x^7}{7!} + \cdots.
\end{equation}\]</span> So there are only approximations of odd order. Use the truncated Taylor series to approximate <span class="math inline">\(f(0.1)=\sin(0.1)\)</span> and <span class="math inline">\(f(0.2)=\sin(0.2)\)</span> and use Python’s values <code>np.sin(0.1)</code> and <code>np.sin(0.2)</code> to calculate the truncation errors <span class="math inline">\(\epsilon_n(0.1)=|f(0.1)-f_n(0.1)|\)</span> and <span class="math inline">\(\epsilon_n(0.2)=|f(0.2)-f_n(0.2)|\)</span>.</p>
<p>Complete the following table:</p>
<table class="table">
<colgroup>
<col style="width: 19%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th>Order <span class="math inline">\(n\)</span></th>
<th><span class="math inline">\(\epsilon_n(0.1)\)</span></th>
<th><span class="math inline">\(\epsilon_n(0.2)\)</span></th>
<th><span class="math inline">\(\epsilon_n(0.2)/ \epsilon_n(0.1)\)</span></th>
<th>Your Conjecture</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>1.665834e-04</td>
<td>1.330669e-03</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>3</td>
<td>8.331349e-08</td>
<td>2.664128e-06</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>5</td>
<td>1.983852e-11</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>7</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>9</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>The entry in the last row of the table will almost certainly not agree with your conjecture. That is okay! That discrepancy has a different explanation. Can you figure out what it is? Hint: does <code>np.sin(x)</code> give you the exact value of <span class="math inline">\(\sin(x)\)</span>?</p>
<hr>
<div id="exr-1.40" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.39</strong></span> Perform another check of your conjecture by approximating <span class="math inline">\(\log(1.02)\)</span> and <span class="math inline">\(\log(1.1)\)</span> from truncations of the Taylor series around <span class="math inline">\(x=1\)</span>: <span class="math display">\[
\log(1+x) = x - \frac{x^2}{2} + \frac{x^3}{3} - \frac{x^4}{4} + \frac{x^5}{5} - \cdots.
\]</span></p>
</div>
<hr>
<div id="exr-1.40" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.40</strong></span> Write down your observations about how the truncation error at order <span class="math inline">\(n\)</span> changes as <span class="math inline">\(x\)</span> changes. Explain this in terms of the form of the remainder of the truncated Taylor series.</p>
</div>
<hr>
</section>
<section id="problems" class="level2" data-number="2.6">
<h2 data-number="2.6" class="anchored" data-anchor-id="problems"><span class="header-section-number">2.6</span> Problems</h2>
<p>These problem exercises will let you consolidate what you have learned so far and combine it with the coding skills you picked up in <a href="nmPython.html" class="quarto-xref"><span>Chapter 1</span></a>.</p>
<hr>
<div id="exr-1.51" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.41</strong></span> (This problem is modified from <span class="citation" data-cites="Greenbaum">(<a href="references.html#ref-Greenbaum" role="doc-biblioref">Greenbaum and Chartier 2012</a>)</span>)<br>
Sometimes floating point arithmetic does not work like we would expect (and hope) as compared to by-hand mathematics. In each of the following problems we have a mathematical problem that the computer gets wrong. Explain why the computer is getting these wrong.</p>
<ol type="1">
<li><p>Mathematically we know that <span class="math inline">\(\sqrt{5}^2\)</span> should just give us 5 back. In Python type <code>np.sqrt(5)**2 == 5</code>. What do you get and why do you get it?</p></li>
<li><p>Mathematically we know that <span class="math inline">\(\left( \frac{1}{49} \right) \cdot 49\)</span> should just be 1. In Python type <code>(1/49)*49 == 1</code>. What do you get and why do you get it?</p></li>
<li><p>Mathematically we know that <span class="math inline">\(e^{\log(3)}\)</span> should just give us 3 back. In Python type <code>np.exp(np.log(3)) == 3</code>. What do you get and why do you get it?</p></li>
<li><p>Create your own example of where Python gets something incorrect because of floating point arithmetic.</p></li>
</ol>
</div>
<hr>
<div id="exr-1.52" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.42</strong></span> (This problem is modified from <span class="citation" data-cites="Greenbaum">(<a href="references.html#ref-Greenbaum" role="doc-biblioref">Greenbaum and Chartier 2012</a>)</span>)<br>
In the 1999 film <em>Office Space</em>, a character creates a program that takes fractions of cents that are truncated in a bank’s transactions and deposits them to his own account. This idea has been attempted in the past and now banks look for this sort of thing. In this problem you will build a simulation of the program to see how long it takes to become a millionaire.</p>
<p><strong>Assumptions:</strong></p>
<ul>
<li><p>Assume that you have access to 50,000 bank accounts.</p></li>
<li><p>Assume that the account balances are uniformly distributed between $100 and $100,000.</p></li>
<li><p>Assume that the annual interest rate on the accounts is 5% and the interest is compounded daily and added to the accounts, except that fractions of cents are truncated.</p></li>
<li><p>Assume that your <code>illegal</code> account initially has a $0 balance.</p></li>
</ul>
<p><strong>Your Tasks:</strong></p>
<ol type="1">
<li>Explain what the code below does.</li>
</ol>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>accounts <span class="op">=</span> <span class="dv">100</span> <span class="op">+</span> (<span class="dv">100000</span><span class="op">-</span><span class="dv">100</span>) <span class="op">*</span> np.random.rand(<span class="dv">50000</span>,<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>accounts <span class="op">=</span> np.floor(<span class="dv">100</span><span class="op">*</span>accounts)<span class="op">/</span><span class="dv">100</span><span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="2" type="1">
<li><p>By hand (no computer) write the mathematical steps necessary to increase the accounts by (5/365)% per day, truncate the accounts to the nearest penny, and add the truncated amount into an account titled “illegal.”</p></li>
<li><p>Write code to complete your plan from part (b).</p></li>
<li><p>Using a <code>while</code> loop, iterate over your code until the illegal account has accumulated $1,000,000. How long does it take?</p></li>
</ol>
</div>
<hr>
<div id="exr-1.53" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.43</strong></span> (This problem is modified from <span class="citation" data-cites="Greenbaum">(<a href="references.html#ref-Greenbaum" role="doc-biblioref">Greenbaum and Chartier 2012</a>)</span>)<br>
In the 1991 Gulf War, the Patriot missile defence system failed due to roundoff error. The troubles stemmed from a computer that performed the tracking calculations with an internal clock whose integer values in tenths of a second were converted to seconds by multiplying by a 24-bit binary approximation to <span class="math inline">\(\frac{1}{10}\)</span>: <span class="math display">\[\begin{equation}
0.1_{10} \approx 0.00011001100110011001100_2.
\end{equation}\]</span></p>
<ol type="1">
<li><p>Convert the binary number above to a fraction by hand (common denominators would be helpful).</p></li>
<li><p>The approximation of <span class="math inline">\(\frac{1}{10}\)</span> given above is clearly not equal to <span class="math inline">\(\frac{1}{10}\)</span>. What is the absolute error in this value?</p></li>
<li><p>What is the time error, in seconds, after 100 hours of operation?</p></li>
<li><p>During the 1991 war, a Scud missile travelled at approximately Mach 5 (3750 mph). Find the distance that the Scud missile would travel during the time error computed in (c).</p></li>
</ol>
</div>
<hr>
<div id="exr-1.54" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.44</strong></span> Find the Taylor Series for <span class="math inline">\(f(x) = \frac{1}{\log(x)}\)</span> centred at the point <span class="math inline">\(x_0 = e\)</span>. Then use the Taylor Series to approximate the number <span class="math inline">\(\frac{1}{\log(3)}\)</span> to 4 decimal places.</p>
</div>
<hr>
<div id="exr-1.55" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.45</strong></span> In this problem we will use Taylor Series to build approximations for the irrational number <span class="math inline">\(\pi\)</span>.</p>
<ol type="1">
<li><p>Write the Taylor series centred at <span class="math inline">\(x_0=0\)</span> for the function <span class="math display">\[\begin{equation}
f(x) = \frac{1}{1+x}.
\end{equation}\]</span></p></li>
<li><p>Now we want to get the Taylor Series for the function <span class="math inline">\(g(x) = \frac{1}{1+x^2}\)</span>. It would be quite time consuming to take all of the necessary derivatives to get this Taylor Series. Instead we will use our answer from part (a) of this problem to shortcut the whole process.</p>
<ol type="1">
<li><p>Substitute <span class="math inline">\(x^2\)</span> for every <span class="math inline">\(x\)</span> in the Taylor Series for <span class="math inline">\(f(x) = \frac{1}{1+x}\)</span>.</p></li>
<li><p>Make a few plots to verify that we indeed now have a Taylor Series for the function <span class="math inline">\(g(x) = \frac{1}{1+x^2}\)</span>.</p></li>
</ol></li>
<li><p>Recall from Calculus that <span class="math display">\[\begin{equation}
\int \frac{1}{1+x^2} dx = \arctan(x).
\end{equation}\]</span> Hence, if we integrate each term of the Taylor Series that results from part (b) we should have a Taylor Series for <span class="math inline">\(\arctan(x)\)</span>.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p></li>
<li><p>Now recall the following from Calculus:</p></li>
</ol>
<ul>
<li><p><span class="math inline">\(\tan(\pi/4) = 1\)</span></p></li>
<li><p>so <span class="math inline">\(\arctan(1) = \pi/4\)</span></p></li>
<li><p>and therefore <span class="math inline">\(\pi = 4\arctan(1)\)</span>.</p>
<p>Let us use these facts along with the Taylor Series for <span class="math inline">\(\arctan(x)\)</span> to approximate <span class="math inline">\(\pi\)</span>: we can just plug in <span class="math inline">\(x=1\)</span> to the series, add up a bunch of terms, and then multiply by 4. Write a loop in Python that builds successively better and better approximations of <span class="math inline">\(\pi\)</span>. Stop the loop when you have an approximation that is correct to 6 decimal places.</p></li>
</ul>
</div>
<hr>
<div id="exr-1.56" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.46</strong></span> In this problem we will prove the famous (and the author’s favourite) formula <span class="math display">\[\begin{equation}
e^{i\theta} = \cos(\theta) + i \sin(\theta).
\end{equation}\]</span> This is known as Euler’s formula after the famous mathematician Leonard Euler. Show all of your work for the following tasks.</p>
<ol type="1">
<li><p>Write the Taylor series for the functions <span class="math inline">\(e^x\)</span>, <span class="math inline">\(\sin(x)\)</span>, and <span class="math inline">\(\cos(x)\)</span>.</p></li>
<li><p>Replace <span class="math inline">\(x\)</span> with <span class="math inline">\(i\theta\)</span> in the Taylor expansion of <span class="math inline">\(e^x\)</span>. Recall that <span class="math inline">\(i = \sqrt{-1}\)</span> so <span class="math inline">\(i^2 = -1\)</span>, <span class="math inline">\(i^3 = -i\)</span>, and <span class="math inline">\(i^4 = 1\)</span>. Simplify all of the powers of <span class="math inline">\(i\theta\)</span> that arise in the Taylor expansion. I will get you started: <span class="math display">\[\begin{equation}
\begin{aligned} e^x &amp;= 1 + x + \frac{x^2}{2} + \frac{x^3}{3!} + \frac{x^4}{4!} + \frac{x^5}{5!} + \cdots \\ e^{i\theta} &amp;= 1 + (i\theta) + \frac{(i\theta)^2}{2!} + \frac{(i\theta)^3}{3!} + \frac{(i\theta)^4}{4!} + \frac{(i\theta)^5}{5!} + \cdots \\ &amp;= 1 + i\theta + i^2 \frac{\theta^2}{2!} + i^3 \frac{\theta^3}{3!} + i^4 \frac{\theta^4}{4!} + i^5 \frac{\theta^5}{5!} + \cdots \\ &amp;= \ldots \text{ keep simplifying ... } \ldots \end{aligned}
\end{equation}\]</span></p></li>
<li><p>Gather all of the real terms and all of the imaginary terms together. Factor the <span class="math inline">\(i\)</span> out of the imaginary terms. What do you notice?</p></li>
<li><p>Use your result from part (c) to prove that <span class="math inline">\(e^{i\pi} + 1 = 0\)</span>.</p></li>
</ol>
</div>
<hr>
<div id="exr-1.57" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.47</strong></span> In physics, the <em>relativistic energy</em> of an object is defined as <span class="math display">\[\begin{equation}
E_{rel} = \gamma mc^2
\end{equation}\]</span> where <span class="math display">\[\begin{equation}
\gamma = \frac{1}{\sqrt{1 - \frac{v^2}{c^2}}}.
\end{equation}\]</span> In these equations, <span class="math inline">\(m\)</span> is the mass of the object, <span class="math inline">\(c\)</span> is the speed of light (<span class="math inline">\(c \approx 3 \times 10^8\)</span>m/s), and <span class="math inline">\(v\)</span> is the velocity of the object. For an object of fixed mass (m) we can expand the Taylor Series centred at <span class="math inline">\(v=0\)</span> for <span class="math inline">\(E_{rel}\)</span> to get <span class="math display">\[\begin{equation}
E_{rel} = mc^2 + \frac{1}{2} mv^2 + \frac{3}{8} \frac{mv^4}{c^2} + \frac{5}{16} \frac{mv^6}{c^4} + \cdots.
\end{equation}\]</span></p>
<ol type="1">
<li><p>What do we recover if we consider an object with zero velocity?</p></li>
<li><p>Why might it be completely reasonable to only use the quadratic approximation <span class="math display">\[\begin{equation}
E_{rel} = mc^2 + \frac{1}{2} mv^2
\end{equation}\]</span> for the relativistic energy equation?<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p></li>
<li><p>(some physics knowledge required) What do you notice about the second term in the Taylor Series approximation of the relativistic energy function?</p></li>
<li><p>Show all of the work to derive the Taylor Series centred at <span class="math inline">\(v = 0\)</span> given above.</p></li>
</ol>
</div>
<hr>
<div id="exr-1.58" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2.48 (The Python Caret Operator)</strong></span> Now that you’re used to using Python to do some basic computations you are probably comfortable with the fact that the caret, <code>^</code>, does NOT do exponentiation like it does in many other programming languages. But what does the caret operator do? That’s what we explore here.</p>
<ol type="1">
<li><p>Consider the numbers <span class="math inline">\(9\)</span> and <span class="math inline">\(5\)</span>. Write these numbers in binary representation. We are going to use four bits to represent each number (it is OK if the first bit happens to be zero). <span class="math display">\[\begin{equation}
\begin{aligned} 9 &amp;=&amp; \underline{\hspace{0.2in}} \, \underline{\hspace{0.2in}} \, \underline{\hspace{0.2in}} \, \underline{\hspace{0.2in}} \\ 5 &amp;=&amp; \underline{\hspace{0.2in}} \, \underline{\hspace{0.2in}} \, \underline{\hspace{0.2in}} \, \underline{\hspace{0.2in}} \end{aligned}
\end{equation}\]</span></p></li>
<li><p>Now go to Python and evaluate the expression <code>9^5</code>. Convert Python’s answer to a binary representation (again using four bits).</p></li>
<li><p>Make a conjecture: How do we go from the binary representations of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> to the binary representation for Python’s <code>a^b</code> for numbers <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>? Test and verify your conjecture on several different examples and then write a few sentences explaining what the caret operator does in Python.</p></li>
</ol>
</div>
<hr>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-Greenbaum" class="csl-entry" role="listitem">
Greenbaum, Anne, and Tim P. Chartier. 2012. <em>Numerical Methods: Design, Analysis, and Computer Implementation of Algorithms</em>. Princeton University Press.
</div>
</div>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>There are many reasons why integrating an infinite series term by term should give you a moment of pause. For the sake of this problem we are doing this operation a little blindly, but in reality we should have verified that the infinite series actually converges uniformly.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>This is something that people in physics and engineering do all the time – there is some complicated nonlinear relationship that they wish to use, but the first few terms of the Taylor Series captures almost all of the behaviour since the higher-order terms are very very small.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./nmPython.html" class="pagination-link  aria-label=" &lt;span="" python&lt;="" span&gt;"="">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Essential Python</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./nmAlgebra.html" class="pagination-link" aria-label="<span class='chapter-number'>3</span>&nbsp; <span class='chapter-title'>Algebra</span>">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Algebra</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/gustavdelius/NumericalAnalysis2024/edit/main/nmApprox.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li></ul></div></div></div></footer></body></html>