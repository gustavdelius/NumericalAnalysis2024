[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Numerical Analysis",
    "section": "",
    "text": "Introduction\nMathematics is not just an abstract pursuit; it is an essential tool that powers a vast array of applications. From weather forecasting to black hole simulations, from urban planning to medical research, the application of mathematics has become indispensable. Central to this applied force is Numerical Analysis.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#what-is-numerical-analysis",
    "href": "index.html#what-is-numerical-analysis",
    "title": "Numerical Analysis",
    "section": "What Is Numerical Analysis?",
    "text": "What Is Numerical Analysis?\nNumerical Analysis is the discipline that bridges continuous mathematical theories with their concrete implementation on digital computers. These computers, by design, work with discrete quantities, and translating continuous problems into this discrete realm is not always straightforward.\nIn this module, we will explore the key techniques, algorithms, and principles of Numerical Analysis that enable us to translate mathematical problems into computational solutions. We will delve into the challenges that arise in this translation, the strategies to overcome them, and the interaction of theory and practice.\nMany mathematical problems cannot be solved analytically in closed form. In Numerical Analysis, we aim to find approximation algorithms for mathematical problems, i.e., schemes that allow us to compute the solution approximately. These algorithms use only elementary operations (\\(+,-,\\times,/\\)) but often a long sequence of them, so that in practice they need to be run on computers.to\n\nExample from Algebra\nSolve the equation \\(\\log(x) = \\sin(x)\\) for \\(x\\) in the interval \\(x \\in (0,\\pi)\\). Stop and think about all of the algebra that you ever learned. you will quickly realize that there are no by-hand techniques that can solve this problem! A numerical approximation, however, is not so hard to come by. The following graph shows that there is a unique solution to this equation in the interval \\((0,\\pi)\\).\n\n\nCode\n# plot the function cos(x) and the line y=x\nimport matplotlib.pyplot as plt\nimport numpy as np\nx = np.linspace(1, 4, 100)\nplt.plot(x, np.log(x), label=\"log(x)\")\nplt.plot(x, np.sin(x), label=\"sin(x)\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1: The functions \\(\\log(x)\\) and \\(\\sin(x)\\) intersect at exactly one point, giving the solution to the equation \\(\\log(x) = \\sin(x)\\).\n\n\n\n\n\n\n\nExample from Calculus\nWhat if we want to evaluate\n\\[\n    \\int_0^\\pi \\sin(x^2) dx?\n\\]\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef f(x):\n    return np.sin(x**2)\n\na = 0\nb = np.pi\nn = 1000  # Number of points for numerical integration\n\nx = np.linspace(a, b, n)\ny = f(x)\n\n# Calculate the numerical integral using the trapezoidal rule\nintegral = np.trapz(y, x)\n\n# Shade the positive and negative regions differently\nplt.fill_between(x, y, where=y&gt;=0, color='green', alpha=0.5, label=\"Positive\")\nplt.fill_between(x, y, where=y&lt;0, color='red', alpha=0.5, label=\"Negative\")\n\n# Plot the curve\nplt.plot(x, y, color='black', label=r\"sin(x^2)\")\n\n# Set labels and title\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.title(\"Integral of sin(x^2) from 0 to pi\")\n\n# Add legend\nplt.legend()\n\n# Show the plot\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2: Visual representation of the integral of \\(\\sin(x^2)\\) from \\(0\\) to \\(\\pi\\).\n\n\n\n\n\nAgain, trying to use any of the possible techniques for using the Fundamental Theorem of Calculus, and hence finding an antiderivative, on the function \\(\\sin(x^2)\\) is completely hopeless. Substitution, integration by parts, and all of the other techniques that you know will all fail. Again, a numerical approximation is not so difficult and is very fast and gives the value\n\n\nCode\n# Use Simpson's rule to approximate the integral of sin(x^2) from 0 to pi\nfrom scipy.integrate import simpson\nsimpson(y, x = x)\n\n\n0.7726517138019184\n\n\nBy the way, this integral (called the Fresnel Sine Integral) actually shows up naturally in the field of optics and electromagnetism, so it is not just some arbitrary integral that I cooked up just for fun.\n\n\nExample from Linear Algebra\nYou have probably never row reduced a matrix larger than \\(3\\times 3\\) or perhaps \\(4 \\times 4\\) by hand. Instead, you often turn to technology to do the row reduction for you. You would be surprised to find that the standard row reduction algorithm (RREF) that you do by hand is not what a computer uses. Instead, there are efficient algorithms to do the basic operations of linear algebra (e.g. Gaussian elimination, matrix factorization, or eigenvalue decomposition)\n\n\nExample from Differential Equations\nSay we needed to solve the differential equation\n\\[\\frac{dy}{dt} = \\sin(y^2) + t.\\]\nThe nonlinear nature of the problem precludes us from using most of the typical techniques (e.g. separation of variables, undetermined coefficients, Laplace Transforms, etc). However, computational methods that result in a plot of an approximate solution can be made very quickly and likely give enough of a solution to be usable. Here is a plot of the solution up to time \\(t=2.5\\) with initial condition \\(y(0)=0.1\\):\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef f(t, y):\n    return np.sin(y**2) + t\n\n# Initial condition\ny0 = 0.1\n\n# Time span for the solution\nt_span = (0, 2.5)\n\n# Solve the differential equation using SciPy's solver\nsol = solve_ivp(f, t_span, [y0], max_step=0.1, dense_output=True)\n\n# Extract the time values and solution\nt = sol.t\ny = sol.sol(t)[0]  \n\n# Plot the numerical solution\nplt.plot(t, y)\n\n# Labels and title\nplt.xlabel('t')\nplt.ylabel('y')\n\n# Show the plot\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 3: Plot of numerical solution of \\(dy/dt=\\sin(y^2)+t\\) with \\(y(0)=0.1\\).\n\n\n\n\n\nThis was an artificial example, but differential equations are central to modelling the real world in order to predict the future. They are the closest thing we have to a crystal ball. Here is a plot of a numerical solution of the SIR model of the evolution of an epidemic over time:\n\n\nCode\nimport numpy as np\nfrom scipy.integrate import odeint\nimport matplotlib.pyplot as plt\n\n# SIR model differential equations\ndef sir_model(y, t, N, beta, gamma):\n    S, I, R = y\n    dSdt = -beta * S * I / N\n    dIdt = beta * S * I / N - gamma * I\n    dRdt = gamma * I\n    return dSdt, dIdt, dRdt\n\n# Total population, N\nN = 1000\n# Initial number of infected and recovered individuals\nI0, R0 = 1, 0\n# Everyone else is susceptible to infection initially\nS0 = N - I0 - R0\n# Contact rate, beta, and mean recovery rate, gamma, (in 1/days)\nbeta, gamma = 0.25, 1./20 \n# A grid of time points (in days)\nt = np.linspace(0, 160, 160)\n\n# Initial conditions vector\ny0 = S0, I0, R0\n# Integrate the SIR equations over the time grid, t\nret = odeint(sir_model, y0, t, args=(N, beta, gamma))\nS, I, R = ret.T\n\n# Plot the data on three separate curves for S(t), I(t) and R(t)\nplt.figure(figsize=(10,6))\nplt.plot(t, S, 'b', alpha=0.7, linewidth=2, label='Susceptible')\nplt.plot(t, I, 'y', alpha=0.7, linewidth=2, label='Infected')\nplt.plot(t, R, 'g', alpha=0.7, linewidth=2, label='Recovered')\nplt.xlabel('Time /days')\nplt.ylabel('Number (1000s)')\nplt.ylim(0, N)\nplt.title('SIR Model Simulation')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 4: Plot of a numerical solution of the SIR model\n\n\n\n\n\n\n\nReasons to study Numerical Analysis\nSo why should you want to venture into Numerical Analysis rather than just use the computer as a black box?\n\nPrecision and Stability: Computers, despite their power, can introduce significant errors if mathematical problems are implemented without care. Numerical Analysis offers techniques to ensure we obtain results that are both accurate and stable.\nEfficiency: Real-world applications often demand not just correctness, but efficiency. By grasping the methods of Numerical Analysis, we can design algorithms that are both accurate and resource-efficient.\nBroad Applications: Whether your interest lies in physics, engineering, biology, finance, or many other scientific fields, Numerical Analysis provides the computational tools to tackle complex problems in these areas.\nBasis for Modern Technologies: Core principles of Numerical Analysis are foundational in emerging fields such as artificial intelligence, quantum computing, and data science.\n\nThe prerequisites for this material include a firm understanding of single variable calculus (though multivariable calculus does not hurt), a good understanding of the basics of linear algebra, a good understanding of the basics of differential equations, and some exposure to scientific computing.\nBy the end, you will not merely understand the methods of Numerical Analysis; you will be equipped to apply them efficiently and effectively in diverse scenarios: you will be able to tackle problems in physics, engineering, biology, finance, and many other fields; you will be able to design algorithms that are both accurate and resource-efficient; you will be able to ensure that your computational solutions are both accurate and stable; you will be able to leverage the power of computers to solve complex problems.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#the-inquiry-based-approach",
    "href": "index.html#the-inquiry-based-approach",
    "title": "Numerical Analysis",
    "section": "The Inquiry-Based Approach",
    "text": "The Inquiry-Based Approach\nThis material is written with an Inquiry-Based Learning (IBL) flavor. In that sense, these notes are not a traditional textbook containing all of the expected theorems, proofs, code, examples, and exposition. You are encouraged to work through exercises, problems and projects, present your findings, and work together when appropriate.\nIn our first session we will start off right away with an exercise designed for groups, discussion, disagreement, and deep critical thinking. This exercise is inspired by Dana Ernst’s first day IBL activity titled: Setting the Stage.\n\n\nExercise 1  \n\nGet in groups of size 3-4.\nGroup members should introduce themselves.\nFor each of the questions that follow I will ask you to:\n\n\nThink about a possible answer on your own\nDiscuss your answers with the rest of the group\nShare a summary of each group’s discussion\n\nQuestions:\nQuestion 1: What are the goals of a university education?\nQuestion 2: How does a person learn something new?\nQuestion 3: What do you reasonably expect to remember from your courses in 20 years?\nQuestion 4: What is the value of making mistakes in the learning process?\nQuestion 5: How do we create a safe environment where risk taking is encouraged and productive failure is valued?",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#how-this-module-works",
    "href": "index.html#how-this-module-works",
    "title": "Numerical Analysis",
    "section": "How this module works",
    "text": "How this module works\nThere are 4 one-hour whole-class sessions every week. Three of these are listed on your timetable as “Lecture” and one as “Computer Practical”. However, in all these sessions you, the student, are the one that is doing the work; discovering methods, writing code, working problems, leading discussions, and pushing the pace. I, the lecturer, will act as a guide who only steps in to redirect conversations or to provide necessary insight. You will use the whole-class sessions to share and discuss your work with the other members of your group. There will also be some whole-class discussions moderated by your lecturer.\nYou will find that this text is not a set of lecture notes. Instead it mostly just contains collections of exercises with minimal interweaving exposition. It is expected that you do every one of the exercises in the main body of each chapter and use the sequencing of the exercises to guide your learning and understanding.\nTherefore the whole-class sessions form only a very small part of your work on this module. For each hour of whole-class work you should timetable yourself about two and a half hours of work outside class for working through the exercises on your own. I strongly recommend that you put those two and a half hours (ten hours spread throughout the week) into your timetable. Of course I hope that your explorations will be so satisfying that you will want to spend more than those ten hours every week. This is a module where you will develop amazing skills that it will be fun to exploit in your own investigations. Your lecturer will be very interested to hear about your experiences.\nAt the end of each chapter there is a section entitled “Problems” that contains additional exercises aimed at consolidating your new understanding and skills. Of these you should aim to do as many as you can but you will not have time to do them all. As the module progresses I will give advice on which of those problems to attack. There are no traditional problem sheets in this module. In this module you will be working on exercises continuously throughout the week rather than working through a problem sheet only every other week.\nMany of the chapters also have a section entitled “Projects”. These projects are more open-ended investigations, designed to encourage creative mathematics, to push your coding skills and to require you to write and communicate mathematics. These projects are entirely optional and perhaps you will like to return to one of these even after the module has finished. If you do work on one of the projects, be sure to share your work with your lecturer at gustav.delius@york.ac.uk who will be very interested, also after the end of the module.\nYou will need two notebooks for working through the exercises in this guide: one in paper form and one electronic. Some of the exercises are pen-and-paper exercises while others are coding exercises and some require both writing or sketching and coding. The two notebooks will be linked through the numbering of the exercises.\nFor the coding notebook I highly recommend using Google Colab (or Jupyter Notebook). This will be discussed more in 1  Essential Python that introduces Python. Most students find it easiest to have one dedicated Colab notebook (or Jupyter notebook) per section, but some students will want to have one per chapter. You are highly encouraged to write explanatory text into your Google Colab notebooks as you go so that future-you can tell what it is that you were doing, which problem(s) you were solving, and what your thought processes were.\nIn the end, your collection of notebooks will contain solutions to every exercise in the guide and can serve as a reference manual for future numerical analysis problems. At the end of each of your notebooks you may also want to add a summary of what you have learned, which will both consolidate your learning and make it easier for you to remind yourself of your new skills later.\nOne request: do not share your notebooks publicly on the internet because that would create temptation for future students to not put in the work themselves, thereby robbing them of the learning experience.\nIf you have a notebook computer, bring it along to the class sessions. However this is not a requirement. Your lecturer will bring along some spare machines to make sure that every group has at least one computer to use during every session. The only requirement for a computer to be useful for this module is that it can connect to the campus WiFi and run a web browser. The “Computer Practical” takes place in a PC classroom, so there will of course be plenty of machines available then.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#assessment",
    "href": "index.html#assessment",
    "title": "Numerical Analysis",
    "section": "Assessment",
    "text": "Assessment\nUnfortunately, your learning in the module also needs to be assessed. The final mark will be made up of 40% coursework and 60% final exam.\nThe 40% coursework mark will come from 10 short quizzes that will take place during the “Computer practical” in weeks 2 to 11. Answering each quiz should take less than 5 minutes but you will be given 10 minutes to complete it to give you a large safety margin and remove stress. The quizzes will be based on exercises that you will already have worked through and for which you will have had time to discuss them in class, so they will be really easy if you have engaged with the exercises as intended. There will be a practice quiz in the computer practical in week 1.\nDuring the assessment quizzes you will be required to work exclusively on a classroom PC rather than your own machine. You will do your work in a Colab notebook that will be shared with you at the start of the quiz via Moodle. You will then need to save your work, download the Colab notebook to the PC and upload it to Moodle before the end of the quiz. You can find more info on the use of Colab notebooks in this module in the Essential Python chapter of the Numerical Analysis Learning Guide.\nWhile working on the quiz on the classroom PC you are only allowed to use a web browser, and the only pages you are allowed to have open are this guide, the course home page on Moodle and any of your notebooks on Google Colab. You are not allowed to use any AI assistants or other web pages. Besides your online notebooks you may also use any hand-written notes as long as you have written them yourself.\nTo allow for the fact that there may be weeks in which you are ill or otherwise prevented from performing to your best in the assessment quizzes, your final coursework mark will be calculated as the average over your 8 best marks. If exceptional circumstances affect more than two of the 10 quizzes then you would need to submit an exceptional circumstances claim.\nThe 60% final exam will be a 2 hour exam of the usual closed-book form in an exam room during the exam period. I will make a practice exam available at the end of the module.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#textbooks",
    "href": "index.html#textbooks",
    "title": "Numerical Analysis",
    "section": "Textbooks",
    "text": "Textbooks\nIn this module we will only scratch the surface of the vast subject that is Numerical Analysis. The aim is for you at the end of this module to be familiar with some key ideas and to have the confidence to engage with new methods when they become relevant to you.\nThere are many textbooks on Numerical Analysis. Standard textbooks are (Burden and Faires 2010) and (Kincaid and Cheney 2009). They contain much of the material from this module. A less structured and more opinionated account can be found in (Acton 1990). Another well known reference that researchers often turn to for solutions to specific tasks is (Press et al. 2007). You will find many others in the library. They may go also under alternative names like Numerical Methods or Scientific Computing.\nYou may also want to look at textbooks for specific topics covered in this module, like for example (Butcher 2016) for methods for ordinary differential equations.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#your-jobs",
    "href": "index.html#your-jobs",
    "title": "Numerical Analysis",
    "section": "Your jobs",
    "text": "Your jobs\nYou have the following jobs as a student in this module:\n\nFight! You will have to fight hard to work through this material. The fight is exactly what we are after since it is ultimately what leads to innovative thinking.\nScrew Up! More accurately, do not be afraid to screw up. You should write code, work problems, and develop methods, then be completely unafraid to scrap what you have done and redo it from scratch.\nCollaborate! You should collaborate with your peers with the following caveats:\n\nWhen you are done collaborating you should go your separate ways. When you write your solution you should have no written (or digital) record of your collaboration.\nUse of the internet or AI to help solve these problems robs you of the most important part of this module; the chance for original thought.\n\nEnjoy! Part of the fun of inquiry-based learning is that you get to experience what it is like to think like a true mathematician / scientist. It takes hard work but ultimately this should be fun!\n\n\n© Gustav Delius. Some Rights Reserved.\nThis learning guide, adapted from the original text by Eric Sullivan, is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. You may copy, distribute, display, remix, rework, and perform this copyrighted work, as long as you give credit to both Gustav Delius for the adaptations and Eric Sullivan for the original work.\nPlease attribute the original work to Eric Sullivan, formerly Mathematics Faculty at Carroll College, esullivan@carroll.edu, and the adapted work to Gustav Delius, Department of Mathematics, University of York, gustav.delius@york.ac.uk.\nThe original work by Eric Sullivan is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/. The adaptations by Gustav Delius are also published under the same Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\nFor inquiries regarding the use of this learning guide, please contact gustav.delius@york.ac.uk.\n\n\n\n\nActon, Forman S. 1990. Numerical Methods That Work. 1St Edition edition. Washington, D.C: The Mathematical Association of America.\n\n\nBurden, Richard L., and J. Douglas Faires. 2010. Numerical Analysis. 9th ed. Brooks Cole.\n\n\nButcher, J. C. 2016. Numerical Methods for Ordinary Differential Equations. Third edition. Wiley. https://yorsearch.york.ac.uk/permalink/f/1kq3a7l/44YORK_ALMA_DS51336126850001381.\n\n\nKincaid, D. R., and E. W. Cheney. 2009. Numerical Analysis: Mathematics of Scientific Computing. Pure and Applied Undergraduate Texts. American Mathematical Society.\n\n\nPress, William H., Saul A. Teukolsky, William T. Vetterling, and Brian P. Flannery. 2007. Numerical Recipes: The Art of Scientific Computing. Cambridge University Press. https://numerical.recipes/.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "nmPython.html",
    "href": "nmPython.html",
    "title": "1  Essential Python",
    "section": "",
    "text": "1.1 Why Python?\nWe are going to be using Python since\nIt is important to keep in mind that Python is a general purpose language that we will be using for Scientific Computing. The purpose of Scientific Computing is not to build apps, build software, manage databases, or develop user interfaces. Instead, Scientific Computing is the use of a computer programming language (like Python) along with mathematics to solve scientific and mathematical problems. For this reason it is definitely not our purpose to write an all-encompassing guide for how to use Python. We will only cover what is necessary for our computing needs. You will learn more as the course progresses so use this chapter just to get going with the language.\nWe are also definitely not saying that Python is the best language for scientific computing under all circumstances. The reason there are so many scientific programming languages coexisting is that each has particular strengths that make it the best option for particular applications. But we are saying that Python is so widely used that every scientist should know Python.\nThere is an overwhelming abundance of information available about Python and the suite of tools that we will frequently use.\nThese tools together provide all of the computational power that we will need. And they are free!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Essential Python</span>"
    ]
  },
  {
    "objectID": "nmPython.html#why-python",
    "href": "nmPython.html#why-python",
    "title": "1  Essential Python",
    "section": "",
    "text": "Python is free,\nPython is very widely used,\nPython is flexible,\nPython is relatively easy to learn,\nand Python is quite powerful.\n\n\n\n\n\nPython https://www.python.org/,\nnumpy (numerical Python) https://www.numpy.org/,\nmatplotlib (a suite of plotting tools) https://matplotlib.org/,\nscipy (scientific Python) https://www.scipy.org/.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Essential Python</span>"
    ]
  },
  {
    "objectID": "nmPython.html#google-colab",
    "href": "nmPython.html#google-colab",
    "title": "1  Essential Python",
    "section": "1.2 Google Colab",
    "text": "1.2 Google Colab\nEvery computer is its own unique flower with its own unique requirements. Hence, we will not spend time here giving you all of the ways that you can install Python and all of the associated packages necessary for this module. Unless you are already familiar with using Python on your own computer, I highly recommend that you use the Google Colab notebook tool for writing your Python code: https://colab.research.google.com.\nGoogle Colab allows you to keep all of your Python code on your Google Drive. The Colab environment is a free and collaborative version of the popular Jupyter notebook project. Jupyter notebooks allow you to write and test code as well as to mix writing (including LaTeX formatting) in along with your code and your output. I recommend that if you are new to Google Colab, you start by watching the brief introductory video.\n\nExercise 1.1 Spend a bit of time poking around in Colab. Figure out how to\n\nCreate new Colab notebooks.\nAdd and delete code cells.\nUse the keyboard to switch between writing text and writing code.\nSave a notebook to your Google Drive.\nDownload a notebook to your computer.\n\n\n\n\nExercise 1.2 Create a new Colab notebook and in that notebook create a text cell. In that text cell create the following displayed equation using LaTeX: \\[\\begin{equation}\ne^{i\\pi}=-1\n\\end{equation}\\]\n\n\n\nExercise 1.3 Share a Colab notebook with all the members of your group and see whether you can collaboratively edit it. The goal is that that everyone adds a cell that contains their own name and a favourite equation. Then share that notebook with your lecturer gustav.delius@york.ac.uk.\n\n\nIf you are already very practised in using Python then you can jump straight to Section 1.8 with the coding exercises. But if you are new to Python or your Python skills are a bit rusty, then you will benefit from working through all the examples and exercises below, making sure you copy and paste all the code into your Colab notebook and run it there.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Essential Python</span>"
    ]
  },
  {
    "objectID": "nmPython.html#hello-world",
    "href": "nmPython.html#hello-world",
    "title": "1  Essential Python",
    "section": "1.3 Hello, World!",
    "text": "1.3 Hello, World!\nAs is traditional when learning a new programming language, we should create code that prints the words “Hello, world!”. The code below does just that.\nprint(\"Hello, world!\")\nIn a Jupyter notebook you will write your code in a code block, and when you are ready to run it you can press Shift+Enter (or Control+Enter) and you will see your output. Shift+Enter will evaluate your code and advance to the next block of code. Control+Enter will evaluate without advancing the cursor to the next block.\n\n\nExercise 1.4 Create a new Jupyter notebook for your work and have Python print Hello, world! in your notebook.\n\n\n\nExercise 1.5 Write code to print your name in your Jupyter notebook.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Essential Python</span>"
    ]
  },
  {
    "objectID": "nmPython.html#python-programming-basics",
    "href": "nmPython.html#python-programming-basics",
    "title": "1  Essential Python",
    "section": "1.4 Python Programming Basics",
    "text": "1.4 Python Programming Basics\nThroughout the remainder of this chapter it is expected that you run all of the blocks of code on your own and critically evaluate and understand the output. To copy the code from this guide to your notebook you can use the “Copy to Clipboard” icon that pops up in the top right corner of a code block in this guide when you hover over that code block.\n\n1.4.1 Variables\nVariable names in Python can contain letters (lower case or capital), numbers 0-9, and some special characters such as the underscore. Variable names must start with a letter. There are a bunch of reserved words that you can not use for your variable names because they have a special meaning in the Python syntax. Python will let you know with a syntax error if you try to use a reserved word for a variable name.\nYou can do the typical things with variables. Assignment is with an equal sign (be careful R users, we will not be using the left-pointing arrow here!).\nWarning: When defining numerical variables you do not always get floating point numbers. In some programming languages, if you write x=1 then automatically x is saved as 1.0; a floating point number, not an integer. In Python however, if you assign x=1 it is defined as an integer (with no decimal digits) but if you assign x=1.0 it is assigned as a floating point number.\n# assign some variables\nx = 7 # integer assignment of the integer 7\ny = 7.0 # floating point assignment of the decimal number 7.0\nprint(\"The variable x has the value\", x, \" and has type\", type(x), \". \\n\")\nprint(\"The variable y has the value\", y, \" and has type\", type(y), \". \\n\")\nRemember to copy each code block to your own notebook, execute it and look at the output.\n# multiplying by a float will convert an integer to a float\nx = 7 # integer assignment of the integer 7\nprint(\"Multiplying x by 1.0 gives\", 1.0*x)\nprint(\"The type of this value is\", type(1.0*x), \". \\n\")\nThe allowed mathematical operations are:\n\nAddition: +\nSubtraction: -\nMultiplication: *\nDivision: /\nInteger Division (modular division): // and %\nExponents: **\n\nThat’s right, the caret key, ^, is NOT an exponent in Python (sigh). Instead we have to get used to ** for exponents.\nx = 7.0\ny = x**2 # square the value in x\nprint(y)\n\n\nExercise 1.6 What happens if you evaluate 7^2 in Python? What does it give you? We will return to this later.\n\n\n\nExercise 1.7 Write code to define positive integers \\(a,b\\) and \\(c\\) of your own choosing. Then calculate \\(a^2, b^2\\) and \\(c^2\\). When you have all three values computed, check to see if your three values form a Pythagorean Triple so that \\(a^2 + b^2 = c^2\\). Have Python simply say True or False to verify that you do, or do not, have a Pythagorean Triple defined. Hint: You will need to use the == Boolean check just like in other programming languages.\n\n\n\n\n1.4.2 Indexing and Lists\nLists are a key component to storing data in Python. Lists are exactly what the name says: lists of things (in our case, usually the entries are floating point numbers).\nWarning: Python indexing starts at 0 whereas some other programming languages have indexing starting at 1. In other words, the first entry of a list has index 0, the second entry as index 1, and so on. We just have to keep this in mind.\nWe can extract a part of a list using the syntax name[start:stop] which extracts elements between index start and stop-1. Take note that Python stops reading at the second to last index. This often catches people off guard when they first start with Python.\n\n\nExample 1.1 (Lists and Indexing) Let us look at a few examples of indexing from lists. In this example we will use the list of numbers 0 through 8. This list contains 9 numbers indexed from 0 to 8.\n\nCreate the list of numbers 0 through 8\n\nMyList = [0,1,2,3,4,5,6,7,8]\n\nPrint only the element with index 0.\n\nprint(MyList[0]) \n\nPrint all elements up to, but not including, the third element of MyList.\n\nprint(MyList[:2])\n\nPrint the last element of MyList (this is a handy trick!).\n\nprint(MyList[-1]) \n\nPrint the elements indexed 1 through 4. Beware! This is not the first through fifth element.\n\nprint(MyList[1:5]) \n\nPrint every other element in the list starting with the first.\n\nprint(MyList[0::2])\n\nPrint the last three elements of MyList\n\nprint(MyList[-3:])\n\n\nIn Python, elements in a list do not need to be the same type. You can mix integers, floats, strings, lists, etc.\n\nExample 1.2 In this example we see a list of several items that have different data types: float, integer, string, and complex. Note that the imaginary number \\(i\\) is represented by \\(1j\\) in Python. This is common in many scientific disciplines and is just another thing that we will need to get used to in Python. (For example, \\(j\\) is commonly used as the symbol for the imaginary unit \\(\\sqrt{-1}\\) ) in electrical engineering since \\(i\\) is the symbol commonly used for electric current, and using \\(i\\) for both would be problematic).\nMixedList = [1.0, 7, 'Bob', 1-1j]\nprint(MixedList)\nprint(type(MixedList[0]))\nprint(type(MixedList[1]))\nprint(type(MixedList[2]))\nprint(type(MixedList[3])) \n# Notice that we use 1j for the imaginary number \"i\".\n\n\n\nExercise 1.8 In this exercise you will put your new list skills into practice.\n\nCreate the list of the first several Fibonacci numbers: \\[\\begin{equation}\n1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89.\n\\end{equation}\\]\nPrint the first four elements of the list.\nPrint every third element of the list starting from the first.\nPrint the last element of the list.\nPrint the list in reverse order.\nPrint the list starting at the last element and counting backward by every other element.\n\n\n\n\n\n1.4.3 List Operations\nPython is awesome about allowing you to do things like appending items to lists, removing items from lists, and inserting items into lists. Note in all of the examples below that we are using the code\nvariable.method\nwhere you put the variable name, a dot, and the thing that you would like to do to that variable. For example, MyList.append(7) will append the number 7 to the list MyList. We say that append is a “method” of the list MyList. This is a common programming feature in Python and we will use it often.\n\n\nExample 1.3 The .append method can be used to append an element to the end of a list.\nMyList = [0,1,2,3]\nprint(MyList)\n# Append the string 'a' to the end of the list\nMyList.append('a') \nprint(MyList)\n# Do it again ... just for fun\nMyList.append('a') \nprint(MyList)\n# Append the number 15 to the end of the list\nMyList.append(15) \nprint(MyList)\n\n\n\nExample 1.4 The .remove method can be used to remove an element from a list.\n# Let us remove the 3\nMyList.remove(3)\nprint(MyList)\n\n\n\nExample 1.5 The .insert method can be used to insert an element at a location in a list.\n# insert the letter `A` at the 0-indexed spot\nMyList.insert(0,'A') \n# insert the letter `B` at the spot with index 3 \nMyList.insert(3,'B') \n# remember that index 3 means the fourth spot in the list\nprint(MyList)\n\n\n\nExercise 1.9 In this exercise you will go a bit further with your list operation skills.\n\nCreate the list of the first several Lucas Numbers: \\(1,3,4,7,11,18,29,47.\\)\nAdd the next three Lucas Numbers to the end of the list.\nRemove the number 3 from the list.\nInsert the 3 back into the list in the correct spot.\nPrint the list in reverse order.\nDo a few other list operations to this list and report your findings.\n\n\n\n\n\n1.4.4 Tuples\nIn Python, a “tuple” is like an ordered pair (or ordered triple, or ordered quadruple, ...) in mathematics. We will occasionally see tuples in our work in numerical analysis so for now let us just give a couple of code snippets showing how to store and read them.\nWe can define the tuple of numbers \\((10,20)\\) in Python as follows:\n\nExample 1.6  \npoint = 10, 20 \nprint(point, type(point))\nWe can also define a tuple with parenthesis if we like. Python does not care.\npoint = (10, 20) # now we define the tuple with parenthesis\nprint(point, type(point))\nWe can then unpack the tuple into components if we wish:\nx, y = point\nprint(\"x = \", x)\nprint(\"y = \", y)\n\nThere are other important data structures in Python that we will not cover in this module. These include dictionaries and sets. We will not cover these because they are not necessary for our work in numerical analysis. We are trying to keep things simple. If you are interested in learning more about these data structures, you can find a lot of information about them in the Python documentation.\n\n\n1.4.5 Control Flow: Loops and If Statements\nAny time you need to do some repetitive task with a programming language you can use a loop. Just like in other programming languages, we can do loops and conditional statements in very easy ways in Python. The thing to keep in mind is that the Python language is very white-space-dependent. This means that your indentations need to be correct in order for a loop to work. You could get away with sloppy indention in other languages but not so in Python. Also, in some languages (like R and Java) you need to wrap your loops in curly braces. Again, not so in Python.\nCaution: Be really careful of the white space in your code when you write loops.\n\n1.4.5.1 for Loops\nA for loop is designed to do a task a certain number of times and then stop. This is a great tool for automating repetitive tasks, but it also nice numerically for building sequences, summing series, or just checking lots of examples. The following are several examples of Python for loops. Take careful note of the syntax for a for loop as it is the same as for other loops and conditional statements:\n\na control statement,\na colon, a new line,\nindent four spaces,\nsome programming statements\n\nWhen you are done with the loop, just back out of the indention. There is no need for an end command or a curly brace. All of the control statements in Python are white-space-dependent.\n\n\nExample 1.7 Print the first 6 perfect squares.\nfor x in [1,2,3,4,5,6]:\n    print(x**2)\nOften instead of writing the list of integers explicitly one uses the range() function, so that this example would be written as\nfor x in range(1,7):\n    print(x**2)\n\nNote that range(1,7) produces the integers from 1 to 6, not from 1 to 7. This is another manifestation of Python’s weird 0-based indexing. Of course it is only weird to people who are new to Python. For Pythonists it is perfectly natural.\n\n\nExample 1.8 Print the names in a list.\nNamesList = ['Alice','Billy','Charlie','Dom','Enrique','Francisco']\nfor name in NamesList:\n    print(name)\n\n\nIn Python you can use a more compact notation for for loops sometimes. This takes a bit of getting used to, but is super slick!\n\n\nExample 1.9 Create a list of the perfect squares from 1 to 9.\n# create a list of the perfect squares from 1 to 9\nCoolList = [x**2 for x in range(1,10)]\nprint(CoolList)\n# Then print the sum of this list\nprint(\"The sum of the first 9 perfect squares is\",sum(CoolList))\n\n\nfor loops can also be used to build recursive sequences as can be seen in the next couple of examples.\n\n\nExample 1.10 In the following code we write a for loop that outputs a list of the first 7 iterations of the sequence \\(x_{n+1}=-0.5x_n+1\\) starting with \\(x_0=3\\). Notice that we are using the command x.append instead of \\(x[n+1]\\) to append the new term to the list. This allows us to grow the length of the list dynamically as the loop progresses.\nx=[3.0]\nfor n in range(0,7):\n    x.append(-0.5*x[n] + 1)\n    print(x) # print the whole list x at each step of the loop\n\n\n\nExample 1.11 As an alternative to the code from the previous example we can pre-allocate the memory in an array of zeros. This is done with the clever code x = [0] * 10. Literally multiplying a list by some number, like 10, says to repeat that list 10 times.\nNow we will build the sequence with pre-allocated memory.\nx = [0] * 7\nx[0] = 3.0\nfor n in range(0,6):\n    x[n+1] = -0.5*x[n]+1\n    print(x) # This print statement shows x at each iteration\n\n\n\nExercise 1.10 We want to sum the first 100 perfect cubes. Let us do this in two ways.\n\nStart off a variable called Total at 0 and write a for loop that adds the next perfect cube to the running total.\nWrite a for loop that builds the sequence of the first 100 perfect cubes. After the list has been built find the sum with the sum() function.\n\nThe answer is: 25,502,500 so check your work.\n\n\n\nExercise 1.11 Write a for loop that builds the first 20 terms of the sequence \\(x_{n+1}=1-x_n^2\\) with \\(x_0=0.1\\). Pre-allocate enough memory in your list and then fill it with the terms of the sequence. Only print the list after all of the computations have been completed.\n\n\n\n\n1.4.5.2 while Loops\nA while loop repeats some task (or sequence of tasks) while a logical condition is true. It stops when the logical condition turns from true to false. The structure in Python is the same as with for loops.\n\n\nExample 1.12 Print the numbers 0 through 4 and then the word “done.” we will do this by starting a counter variable, i, at 0 and increment it every time we pass through the loop.\ni = 0\nwhile i &lt; 5:\n    print(i)\n    i += 1 # increment the counter\nprint(\"done\")\n\n\n\nExample 1.13 Now let us use a while loop to build the sequence of Fibonacci numbers and stop when the newest number in the sequence is greater than 1000. Notice that we want to keep looping until the condition that the last term is greater than 1000 – this is the perfect task for a while loop, instead of a for loop, since we do not know how many steps it will take before we start the task\nFib = [1,1]\nwhile Fib[-1] &lt;= 1000:\n    Fib.append(Fib[-1] + Fib[-2])\nprint(\"The last few terms in the list are:\\n\",Fib[-3:])\n\n\n\nExercise 1.12 Write a while loop that sums the terms in the Fibonacci sequence until the sum is larger than 1000\n\n\n\n\n1.4.5.3 if Statements\nConditional (if) statements allow you to run a piece of code only under certain conditions. This is handy when you have different tasks to perform under different conditions.\n\n\nExample 1.14 Let us look at a simple example of an if statement in Python.\nName = \"Alice\"\nif Name == \"Alice\":\n    print(\"Hello, Alice.  Isn't it a lovely day to learn Python?\")\nelse:\n    print(\"You're not Alice.  Where is Alice?\")\nName = \"Billy\"\nif Name == \"Alice\":\n    print(\"Hello, Alice.  Isn't it a lovely day to learn Python?\")\nelse:\n    print(\"You're not Alice.  Where is Alice?\")\n\n\n\nExample 1.15 For another example, if we get a random number between 0 and 1 we could have Python print a different message depending on whether it was above or below 0.5. Run the code below several times and you will see different results each time.\nNote: We have to import the numpy package to get the random number generator in Python. Do not worry about that for now. we will talk about packages in a moment.\nimport numpy as np\nx = np.random.rand(1,1) # get a random 1x1 matrix using numpy\nx = x[0,0] # pull the entry from the first row and first column\nif x &lt; 0.5:\n    print(x,\" is less than a half\")\nelse:\n    print(x, \"is NOT less than a half\")\n(Take note that the output will change every time you run it)\n\n\n\nExample 1.16 In many programming tasks it is handy to have several different choices between tasks instead of just two choices as in the previous examples. This is a job for the elif command.\nThis is the same code as last time except we will make the decision at 0.33 and 0.67\nimport numpy as np\nx = np.random.rand(1,1) # get a random 1x1 matrix using numpy\nx = x[0,0] # pull the entry from the first row and first column\nif x &lt; 0.33:\n    print(x,\" &lt; 1/3\")\nelif x &lt; 0.67:\n    print(\"1/3 &lt;= \",x,\"&lt; 2/3\")\nelse:\n    print(x, \"&gt;= 2/3\")\n(Take note that the output will change every time you run it)\n\n\n\nExercise 1.13 Write code to give the Collatz Sequence \\[\\begin{equation}\nx_{n+1} = \\left\\{ \\begin{array}{ll} x_n / 2, & \\text{$x_n$ is even} \\\\ 3 x_n + 1, & \\text{otherwise} \\end{array} \\right.\n\\end{equation}\\] starting with a positive integer of your choosing. The sequence will converge1 to 1 so your code should stop when the sequence reaches 1.\nHints: To test whether a number x is even you can test whether the remainder after dividing by 2 is zero with (x % 2) == 0. Also you will want to use the integer division // when calculating \\(x_n/2\\).\n\n\n\n\n\n1.4.6 Functions\nMathematicians and programmers talk about functions in very similar ways, but they are not exactly the same. When we say “function” in a programming sense we are talking about a chunk of code that you can pass parameters and expect an output of some sort. This is not unlike the mathematician’s version, but unlike a mathematical function can also have side effects, like plotting a graph for example. So Python’s definition of a function is a bit more flexible than that of a mathematician.\nIn Python, to define a function we start with def, followed by the function’s name, any input variables in parenthesis, and a colon. The indented code after the colon is what defines the actions of the function.\n\n\nExample 1.17 The following code defines the polynomial \\(f(x) = x^3 + 3x^2 + 3x + 1\\) and then evaluates the function at a point \\(x=2.3\\).\ndef f(x):\n    return(x**3 + 3*x**2 + 3*x + 1)\nf(2.3)\n\n\nTake careful note of several things in the previous example:\n\nTo define the function we cannot just type it like we would see it one paper. This is not how Python recognizes functions.\nOnce we have the function defined we can call upon it just like we would on paper.\nWe cannot pass symbols into this type of function.2\n\n\n\nExercise 1.14 Define the function \\(g(n) = n^2 + n + 41\\) as a Python function. Write a loop that gives the output for this function for integers from \\(n=0\\) to \\(n=39\\). Euler noticed that each of these outputs is a prime number (check this on your own). Will the function produce a prime for \\(n=40\\)? For \\(n=41\\)?\n\n\n\nExample 1.18 One cool thing that you can do with functions is call them recursively. That is, you can call the same function from within the function itself. This turns out to be really handy in several mathematical situations.\nLet us define a function for the factorial. This function is naturally going to be recursive in the sense that it calls on itself!\ndef Fact(n):\n    if n==0:\n        return(1)\n    else:\n        return( n*Fact(n-1) ) \n        # Note: we are calling the function recursively.\nWhen you run this code there will be no output. You have just defined the function so you can use it later. So let us use it to make a list of the first several factorials. Note the use of a for loop in the following code.\nFactList = [Fact(n) for n in range(0,10)]\nFactList\n\n\n\nExample 1.19 For this next example let us define the sequence \\[\\begin{equation}\nx_{n+1} = \\left\\{ \\begin{array}{ll} 2x_n, & x_n \\in [0,0.5] \\\\ 2x_n - 1, & x_n \\in (0.5,1] \\end{array} \\right.\n\\end{equation}\\] as a function and then build a loop to find the first several iterates of the sequence starting at any real number between 0 and 1.\n# Define the function\ndef MySeq(xn):\n    if xn &lt;= 0.5:\n        return(2*xn)\n    else:\n        return(2*xn-1)\n# Now build a sequence with this function\nx = [0.125] # arbitrary starting point\nfor n in range(0,5): # Let us only build the first 5 terms\n    x.append(MySeq(x[-1]))\nprint(x)\n\n\n\nExample 1.20 A fun way to approximate the square root of two is to start with any positive real number and iterate over the sequence \\[\\begin{equation}\nx_{n+1} = \\frac{1}{2} x_n + \\frac{1}{x_n}\n\\end{equation}\\] until we are within any tolerance we like of the square root of \\(2\\). Write code that defines the sequence as a function and then iterates in a while loop until we are within \\(10^{-8}\\) of the square root of 2.\nWe import the math package so that we get the square root function. More about packages in the next section.\nfrom math import sqrt\ndef f(x):\n    return(0.5*x + 1/x)\nx = 1.1 # arbitrary starting point\nprint(\"approximation \\t\\t exact \\t\\t abs error\")\nwhile abs(x-sqrt(2)) &gt; 10**(-8):\n    x = f(x)\n    print(x, sqrt(2), abs(x - sqrt(2)))\n\n\n\nExercise 1.15 The previous example is a special case of the Babylonian Algorithm for calculating square roots. If you want the square root of \\(S\\) then iterate the sequence \\[\\begin{equation}\nx_{n+1} = \\frac{1}{2} \\left( x_n + \\frac{S}{x_n} \\right)\n\\end{equation}\\] until you are within an appropriate tolerance.\nModify the code given in the previous example to give a list of approximations of the square roots of the natural numbers 2 through 20, each to within \\(10^{-8}\\). This problem will require that you build a function, write a ‘for’ loop (for the integers 2-20), and write a ‘while’ loop inside your ‘for’ loop to do the iterations.\n\n\n\n\n1.4.7 Lambda Functions\nUsing def to define a function as in the previous subsection is really nice when you have a function that is complicated or requires some bit of code to evaluate. However, in the case of mathematical functions we have a convenient alternative: lambda Functions.\nThe basic idea of a lambda Function is that we just want to state what the variable is and what the rule is for evaluating the function. This is closest to the way that we write mathematical functions. For example, we can define the mathematical function \\(f(x) = x^2+3\\) in two different ways.\n\nUsing def:\n\ndef f(x):\n    return(x**2+3)\n\nUsing lambda:\n\nf = lambda x: x**2+3\nYou can see that in the Lambda Function we are explicitly stating the name of the variable immediately after the word lambda, then we put a colon, and then the function definition.\nNo matter whether we use def or lambda to define the function f, if we want to evaluate the function at a point, say \\(x=1.5\\), then we can write code just like we would mathematically: \\(f(1.5)\\)\nf(1.5) # evaluate the function at x=1.5\nWe can also define Lambda Functions of several variables. For example, if we want to define the mathematical function \\(f(x,y) = x^2 + xy + y^3\\) we could write the code\nf = lambda x, y: x**2 + x*y + y**3\nIf we wanted the value \\(f(2,4)\\) we would now write the code f(2,4).\n\n\nExercise 1.16 Go back to Exercise 1.14 and repeat this exercise using a lambda function.\n\n\n\nExercise 1.17 Go back to Exercise 1.15 and repeat this exercise using a lambda function.\n\n\n\n\n1.4.8 Packages\nPython was not created as a scientific programming language. The reason Python can be used for scientific computing is that there are powerful extension packages that define additional functions that are needed for scientific calculations.\nYou need to remember which functions live in which packages so that you can load the right ones. It is helpful to keep a list of commonly used packages and functions at least while you are getting started.\nLet us start with the math package.\n\n\nExample 1.21 The code below imports the math package into your instance of Python and calculates the cosine of \\(\\pi/4\\).\nimport math\nx = math.cos(math.pi / 4)\nprint(x)\nThe answer, unsurprisingly, is the decimal form of \\(\\sqrt{2}/2\\).\n\n\nYou might already see a potential disadvantage to Python’s packages: there is now more typing involved! Let us fix this. When you import a package you could just import all of the functions so they can be used by their proper names.\n\n\nExample 1.22 Here we import the entire math package so we can use every one of the functions therein without having to use the math prefix.\nfrom math import * # read this as: from math import everything\nx = cos(pi / 4)\nprint(x)\nThe end result is exactly the same: the decimal form of \\(\\sqrt{2}/2\\), but now we had less typing to do.\n\n\nNow you can freely use the functions that were imported from the math package. There is a disadvantage to this, however. What if we have two packages that import functions with the same name. For example, in the math package and in the numpy package there is a cos() function. In the next block of code we will import both math and numpy, but instead we will import them with shortened names so we can type things a bit faster.\n\n\nExample 1.23 Here we import math and numpy under aliases so we can use the shortened aliases and not mix up which functions belong to which packages.\nimport math as ma\nimport numpy as np\n# use the math version of the cosine function\nx = ma.cos( ma.pi / 4) \n# use the numpy version of the cosine function\ny = np.cos( np.pi / 4) \nprint(x, y)\nBoth x and y in the code give the decimal approximation of \\(\\sqrt{2}/2\\). This is clearly pretty redundant in this really simple case, but you should be able to see where you might want to use this and where you might run into troubles.\n\n\n\nExample 1.24 (Contents of a package) Once you have a package imported you can see what is inside of it using the dir command. The following block of code prints a list of all of the functions inside the math package.\nimport math\nprint(dir(math))\n\n\nBy the way: you only need to import a package once in a session. The only reason we are repeating the import statement in each code block is to make it easier to come back to this material later in a new session, where you will need to import the packages again.\nOf course, there will be times when you need help with a function. You can use the help function to view the help documentation for any function. For example, you can run the code help(math.acos) to get help on the arc cosine function from the math package.\n\n\nExercise 1.18 Import the math package, figure out how the log function works, and write code to calculate the logarithm of the number 8.3 in base 10, base 2, base 16, and base \\(e\\) (the natural logarithm).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Essential Python</span>"
    ]
  },
  {
    "objectID": "nmPython.html#numerical-python-with-numpy",
    "href": "nmPython.html#numerical-python-with-numpy",
    "title": "1  Essential Python",
    "section": "1.5 Numerical Python with NumPy",
    "text": "1.5 Numerical Python with NumPy\nThe base implementation of Python includes the basic programming language, the tools to write loops, check conditions, build and manipulate lists, and all of the other things that we saw in the previous section. In this section we will explore the package numpy that contains optimized numerical routines for doing numerical computations in scientific computing.\n\n\nExample 1.25 To start with let us look at a really simple example. Say you have a list of real numbers and you want to take the sine of every element in the list. If you just try to take the sine of the list you will get an error. Try it yourself.\nfrom math import pi, sin\nMyList = [0,pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]\nsin(MyList)\nYou could get around this error using some of the tools from base Python, but none of them are very elegant from a programming perspective.\nfrom math import pi, sin\nMyList = [0,pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]\nSineList = [sin(n) for n in MyList]\nprint(SineList)\nfrom math import pi, sin\nMyList = [0,pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]\nSineList = [ ]\nfor n in range(0,len(MyList)):\n    SineList.append( sin(MyList[n]) )\nprint(SineList)\nPerhaps more simply, say we wanted to square every number in a list. Just appending the code **2 to the end of the list will fail!\nMyList = [1,2,3,4]\nMyList**2 # This will produce an error\nIf, instead, we define the list as a numpy array instead of a Python list then everything will work mathematically exactly the way that we intend.\nimport numpy as np\nMyList = np.array([1,2,3,4])\nMyList**2 # This will work as expected!  \n\n\n\nExercise 1.19 See if you can take the sine of a full list of numbers that are stored in a numpy array.\nHint: you will now see why the numpy package provides its own version of the sine function.\n\n\nThe package numpy is used in many (most) mathematical computations in numerical analysis using Python. It provides algorithms for matrix and vector arithmetic. Furthermore, it is optimized to be able to do these computations in the most efficient possible way (both in terms of memory and in terms of speed).\nTypically when we import numpy we use import numpy as np. This is the standard way to name the numpy package. This means that we will have lots of function with the prefix “np” in order to call on the numpy functions. Let us first see what is inside the package with the code print(dir(np)) after importing numpy as np. A brief glimpse through the list reveals a huge wealth of mathematical functions that are optimized to work in the best possible way with the Python language. (We are intentionally not showing the output here since it is quite extensive, run it so you can see.)\n\n1.5.1 Numpy Arrays, Array Operations, and Matrix Operations\nIn the previous section you worked with Python lists. As we pointed out, the shortcoming of Python lists is that they do not behave well when we want to apply mathematical functions to the vector as a whole. The “numpy array”, np.array, is essentially the same as a Python list with the notable exceptions that\n\nIn a numpy array every entry is a floating point number\nIn a numpy array the memory usage is more efficient (mostly since Python is expecting data of all the same type)\nWith a numpy array there are ready-made functions that can act directly on the array as a matrix or a vector\n\nLet us just look at a few examples using numpy. What we are going to do is to define a matrix \\(A\\) and vectors \\(v\\) and \\(w\\) as \\[\\begin{equation}\nA = \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix}, \\quad v = \\begin{pmatrix} 5\\\\6 \\end{pmatrix} \\quad \\text{and} \\quad w = v^T = \\begin{pmatrix} 5 & 6 \\end{pmatrix}.\n\\end{equation}\\] Then we will do the following\n\nGet the size and shape of these arrays\nGet individual elements, rows, and columns from these arrays\nTreat these arrays as with linear algebra to\n\ndo element-wise multiplication\ndo matrix a vector products\ndo scalar multiplication\ntake the transpose of matrices\ntake the inverse of matrices\n\n\n\n\nExample 1.26 (numpy Matrices) The first thing to note is that a matrix is a list of lists (each row is a list).\nimport numpy as np\nA = np.array([[1,2],[3,4]])\nprint(\"The matrix A is:\\n\",A)\nv = np.array([[5],[6]]) # this creates a column vector\nprint(\"The vector v is:\\n\",v)\nw = np.array([[5,6]]) # this creates a row vector\nprint(\"The vector w is:\\n\",w)\n\n\n\nExample 1.27 (.shape) The .shape attribute can be used to give the shape of a numpy array. Notice that the output is a tuple showing the size (rows, columns).\nprint(\"The shape of the matrix A is \", A.shape)\nprint(\"The shape of the column vector v is \", v.shape)\nprint(\"The shape of the row vector w is \", w.shape)\n\n\n\nExample 1.28 (.size) The .size attribute can be used to give the size of a numpy array. The size of a matrix or vector will be the total number of elements in the array. You can think of this as the product of the values in the tuple coming from the shape method.\nprint(\"The size of the matrix A is \", A.size)\nprint(\"The size of the column vector v is \", v.size)\nprint(\"The size of the row vector w is \", w.size)\n\n\nReading individual elements from a numpy array is the same, essentially, as reading elements from a Python list. We will use square brackets to get the row and column. Remember that the indexing all starts from 0, not 1!\n\nExample 1.29 Let us read the top left and bottom right entries of the matrix \\(A\\).\nimport numpy as np\nA = np.array([[1,2],[3,4]])\nprint(A[0,0]) # top left\nprint(A[1,1]) # bottom right\n\n\n\nExample 1.30 Let us read the first row from that matrix \\(A\\).\nimport numpy as np\nA = np.array([[1,2],[3,4]])\nprint(A[0,:])\n\n\n\nExample 1.31 Let us read the second column from the matrix \\(A\\).\nimport numpy as np\nA = np.array([[1,2],[3,4]])\nprint(A[:,1])\nNotice when we read the column it was displayed as a row. Be careful. Reading a row or a column from a matrix will automatically flatten it into a 1-dimensional array.\n\n\nIf we try to multiply either \\(A\\) and \\(v\\) or \\(A\\) and \\(A\\) we will get some funky results. Unlike in some programming languages like MATLAB, the default notion of multiplication is NOT matrix multiplication. Instead, the default is element-wise multiplication. You may be familiar with this from R.\n\n\nExample 1.32 If we write the code A*A we do NOT do matrix multiplication. Instead we do element-by-element multiplication. This is a common source of issues when dealing with matrices and Linear Algebra in Python.\nimport numpy as np\nA = np.array([[1,2],[3,4]])\nprint(\"Element-wise multiplication:\\n\", A * A)\nprint(\"Matrix multiplication:\\n\", A @ A)\n\n\n\nExample 1.33 If we write A * v Python will do element-wise multiplication across each column since \\(v\\) is a column vector. If we want the matrix A to act on v we write A @ v.\nimport numpy as np\nA = np.array([[1,2],[3,4]])\nv = np.array([[5],[6]])\nprint(\"Element-wise multiplication on each column:\\n\", A * v) \n# A @ v will do proper matrix multiplication\nprint(\"Matrix A acting on vector v:\\n\", A @ v)\n\nIt is up to you to check that these products are indeed correct from the definitions of matrix multiplication from Linear Algebra.\nIt remains to show some of the other basic linear algebra operations: inverses, determinants, the trace, and the transpose.\n\n\nExample 1.34 (Transpose) Taking the transpose of a matrix (swapping the rows and columns) is done with the .T attribute.\nprint(A.T) # The transpose is relatively simple\n\n\n\nExample 1.35 (Trace) The trace is done with matrix.trace()\nprint(A.trace()) # The trace is pretty darn easy too\nOddly enough, the trace returns a matrix, not a scalar Therefore you will have to read the first entry (index [0,0]) from the answer to just get the trace.\n\n\n\nExample 1.36 (Determinant) The determinant function is hiding under the linalg subpackage inside numpy. Therefore we need to call it as such.\nprint(np.linalg.det(A)) \nYou notice an interesting numerical error here. You can do the determinant easily by hand and so know that it should be exactly \\(-2\\).\n\n\n\nExample 1.37 (Inverse) In the linalg subpackage there is also a function for taking the inverse of a matrix.\nAinv = np.linalg.inv(A)\nprint(Ainv)\nprint(A @ Ainv) # check that we get the identity matrix back\n\n\n\nExercise 1.20 Now that we can do some basic linear algebra with numpy it is your turn. Define the matrix \\(B\\) and the vector \\(u\\) as\n\n\\[\\begin{equation}\nB = \\begin{pmatrix} 1 & 4 & 8 \\\\ 2 & 3 & -1 \\\\ 0 & 9 & -3 \\end{pmatrix} \\quad \\text{and} \\quad u = \\begin{pmatrix} 6 \\\\ 3 \\\\ -7 \\end{pmatrix}.\n\\end{equation}\\]\nThen find\n\n\\(Bu\\)\n\\(B^2\\) (in the traditional linear algebra sense)\nThe size and shape of \\(B\\)\n\\(B^T u\\)\nThe element-by-element product of \\(B\\) with itself\nThe dot product of \\(u\\) with the first row of \\(B\\)\n\n\n\n\n\n1.5.2 arange, linspace, zeros, ones, and meshgrid\nThere are a few built-in ways to build arrays in numpy that save a bit of time in many scientific computing settings.\n\n\nExample 1.38 The np.arange (array range) function is great for building sequences.\nimport numpy as np\nx = np.arange(0,0.6,0.1)\nprint(x)\nnp.arange builds an array of floating point numbers with the arguments start, stop, and step. Note that the stop value itself is not included in the result.\n\n\n\nExample 1.39 The np.linspace function builds an array of floating point numbers starting at one point, ending at the next point, and have exactly the number of points specified with equal spacing in between: start, stop, number of points.\nimport numpy as np\ny = np.linspace(0,5,11)\nprint(y)\nIn a linear space you are always guaranteed to hit the stop point exactly, but you do not have direct control over the step size.\n\n\n\nExample 1.40 The np.zeros function builds an array of zeros. This is handy for pre-allocating memory.\nimport numpy as np\nz = np.zeros((3,5)) # create a 3x5 matrix of zeros\nprint(z)\n\n\n\nExample 1.41 The np.ones function builds an array of ones.\nimport numpy as np\nu = np.ones((3,5)) # create a 3x5 matrix of ones\nprint(u)\n\n\n\nExample 1.42 The np.meshgrid function builds two arrays that when paired make up the ordered pairs for a 2D (or higher D) mesh grid of points. This is handy for building 2D (or higher dimensional) arrays of data for multi-variable functions. Notice that the output is defined as a tuple.\nimport numpy as np\nx, y = np.meshgrid( np.linspace(0,5,6) , np.linspace(0,5,6) )\nprint(\"x = \", x)\nprint(\"y = \", y)\nThe thing to notice with the np.meshgrid() function is that when you lay the two arrays on top of each other, the matching entries give every ordered pair in the domain.\nIf the purpose of this is not clear to you yet, don’t worry. You will see it used a lot later in the module.\n\n\n\nExercise 1.21 Now it is time to practice with some of these numpy functions.\n\nCreate a numpy array of the numbers 1 through 10 and square every entry in the list without using a loop.\nCreate a \\(10 \\times 10\\) identity matrix and change the top right corner to a 5. Hint: np.identity()\nFind the matrix-vector product of the answer to part (b) and the answer to part (a).\nChange the bottom row of your matrix from part (b) to all \\(3\\)’s, then change the third column to all \\(7\\)’s, and then find the \\(5^{th}\\) power of this matrix.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Essential Python</span>"
    ]
  },
  {
    "objectID": "nmPython.html#plotting-with-matplotlib",
    "href": "nmPython.html#plotting-with-matplotlib",
    "title": "1  Essential Python",
    "section": "1.6 Plotting with Matplotlib",
    "text": "1.6 Plotting with Matplotlib\nA key part of scientific computing is plotting your results or your data. The tool in Python best-suited to this task is the package matplotlib. As with all of the other packages in Python, it is best to learn just the basics first and then to dig deeper later. One advantage to using matplotlib in Python is that it is modelled off of MATLAB’s plotting tools. People coming from a MATLAB background should feel pretty comfortable here, but there are some differences to be aware of.\n\n1.6.1 Basics with plt.plot()\nWe are going to start right away with an example. In this example, however, we will walk through each of the code chunks one-by-one so that we understand how to set up a proper plot.\nBelow we will mention some tricks for getting the plots to render that only apply to Jupyter Notebooks. If you are using Google Colab then you may not need some of these little tricks.\n\n\nExample 1.43 (Plotting with matplotlib) In the first example we want to simply plot the sine function on the domain \\(x \\in [0,2\\pi]\\), colour it green, put a grid on it, and give a meaningful legend and axis labels. To do so we first need to take care of a couple of housekeeping items.\n\nImport numpy so we can take advantage of some good numerical routines.\nImport matplotlib’s pyplot module. The standard way to pull it in is with the nickname plt (just like with numpy when we import it as np).\n\n\nimport numpy as np \nimport matplotlib.pyplot as plt\n\nIn Jupyter Notebooks the plots will not show up unless you tell the notebook to put them “inline.” Usually we will use the following command to get the plots to show up. You do not need to do this in Google Colab. The percent sign is called a magic command in Jupyter Notebooks. This is not a Python command, but it is a command for controlling the Jupyter IDE specifically.\n%matplotlib inline\nNow we will build a numpy array of \\(x\\) values (using the np.linspace function) and a numpy array of \\(y\\) values from the sine function.\n\n# 100 equally spaced points from 0 to 2pi\nx = np.linspace(0,2*np.pi, 100) \ny = np.sin(x)\n\n\nNext, build the plot with plt.plot(). The syntax is: plt.plot(x, y, ’color’, ...) where you have several options that you can pass (more on that later).\nWe send the plot label directly to the plot function. This is optional and we could set the legend up separately if we like.\nThen we will add the grid with plt.grid()\nThen we will add the legend to the plot\nFinally we will add the axis labels\nWe end the plotting code with plt.show() to tell Python to finally show the plot. This line of code tells Python that you are done building that plot.\n\n\nplt.plot(x,y, 'green', label='The Sine Function')\nplt.grid()\nplt.legend()\nplt.xlabel(\"x axis\")\nplt.ylabel(\"y axis\")\nplt.show()\n\n\n\n\n\n\n\nFigure 1.1: The sine function\n\n\n\n\n\n\n\n\nExample 1.44 Now let us do a second example, but this time we want to show four different plots on top of each other. When you start a figure, matplotlib is expecting all of those plots to be layered on top of each other. (Note:For MATLAB users, this means that you do not need the hold on command since it is automatically “on.”)\nIn this example we will plot \\[\\begin{equation}\ny_0 = \\sin(2\\pi x) \\quad y_1 = \\cos(2 \\pi x) \\quad y_2 = y_0 + y_1 \\quad \\text{and} \\quad y_3 = y_0 - y_1\n\\end{equation}\\] on the domain \\(x \\in [0,1]\\) with 100 equally spaced points. we will give each of the plots a different line style, built a legend, put a grid on the plot, and give axis labels.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n# %matplotlib inline # you may need this in Jupyter Notebooks\n\n# build the x and y values\nx = np.linspace(0,1,100)\ny0 = np.sin(2*np.pi*x)\ny1 = np.cos(2*np.pi*x)\ny2 = y0 + y1\ny3 = y0 - y1\n\n# plot each of the functions \n# (notice that they will be on the same axes)\nplt.plot(x, y0, 'b-.', label=r\"$y_0 = \\sin(2\\pi x)$\")\nplt.plot(x, y1, 'r--', label=r\"$y_1 = \\cos(2\\pi x)$\")\nplt.plot(x, y2, 'g:', label=r\"$y_2 = y_0 + y_1$\")\nplt.plot(x, y3, 'k-', label=r\"$y_3 = y_0 - y_1$\")\n\n# put in a grid, legend, title, and axis labels\nplt.grid()\nplt.legend()\nplt.title(\"Awesome Graph\")\nplt.xlabel('x axis label')\nplt.ylabel('y axis label')\nplt.show()\n\n\n\n\n\n\n\nFigure 1.2: Plots of the sine, cosine, and sums and differences.\n\n\n\n\n\nNotice the r in front of the strings defining the legend. This prevents the backslash that is used a lot in LaTeX to be interpreted as an escape character. These strings are referred to as raw strings.\nThe legend was placed automatically at the lower left of the plot. There are ways to control the placement of the legend if you wish, but for now just let Python and matplotlib have control over the placement.\n\n\n\nExample 1.45 Now let us create the same plot with slightly different code. The plot function can take several \\((x, y)\\) pairs in the same line of code. This can really shrink the amount of coding that you have to do when plotting several functions on top of each other.\n\n# The next line of code does all of the plotting of all \n# of the functions.  Notice the order: x, y, color and \n# line style, repeat\nimport numpy as np\nimport matplotlib.pyplot as plt\nx = np.linspace(0,1,100)\ny0 = np.sin(2*np.pi*x)\ny1 = np.cos(2*np.pi*x)\ny2 = y0 + y1\ny3 = y0 - y1\nplt.plot(x, y0, 'b-.', x, y1, 'r--', x, y2, 'g:', x, y3, 'k-')\n\nplt.grid()\nplt.legend([r\"$y_0 = \\sin(2\\pi x)$\",r\"$y_1 = \\cos(2\\pi x)$\",\\\n            r\"$y_2 = y_0 + y_1$\",r\"$y_3 = y_0 - y_1$\"])\nplt.title(\"Awesome Graph\")\nplt.xlabel('x axis label')\nplt.ylabel('y axis label')\nplt.show()\n\n\n\n\n\n\n\nFigure 1.3: A second plot of the sine, cosine, and sums and differences.\n\n\n\n\n\n\n\n\nExercise 1.22 Plot the functions \\(f(x) = x^2\\), \\(g(x) = x^3\\), and \\(h(x) = x^4\\) on the same axes. Use the domain \\(x \\in [0,1]\\) and the range \\(y \\in [0,1]\\). Put a grid, a legend, a title, and appropriate labels on the axes.\n\n\n\n\n1.6.2 Subplots\nIt is often very handy to place plots side-by-side or as some array of plots. The subplots command allows us that control. The main idea is that we are setting up a matrix of blank plots and then populating the axes with the plots that we want.\n\n\nExample 1.46 Let us repeat the previous exercise, but this time we will put each of the plots in its own subplot. There are a few extra coding quirks that come along with building subplots so we will highlight each block of code separately.\n\nFirst we set up the plot area with plt.subplots(). The first two inputs to the subplots command are the number of rows and the number of columns in your plot array. For the first example we will do 2 rows of plots with 2 columns – so there are four plots total.\nThen we build each plot individually telling matplotlib which axes to use for each of the things in the plots.\nNotice the small differences in how we set the titles and labels\nIn this example we are setting the \\(y\\)-axis to the interval \\([-2,2]\\) for consistency across all of the plots.\n\n\n# set up the blank matrix of plots\nimport numpy as np\nimport matplotlib.pyplot as plt\nx = np.linspace(0,1,100)\ny0 = np.sin(2*np.pi*x)\ny1 = np.cos(2*np.pi*x)\ny2 = y0 + y1\ny3 = y0 - y1\n\nfig, axes = plt.subplots(nrows = 2, ncols = 2)\n\n# Build the first plot\naxes[0,0].plot(x, y0, 'b-.')\naxes[0,0].grid()\naxes[0,0].set_title(r\"$y_0 = \\sin(2\\pi x)$\")\naxes[0,0].set_ylim(-2,2)\naxes[0,0].set_xlabel(\"x\")\naxes[0,0].set_ylabel(\"y\")\n\n# Build the second plot\naxes[0,1].plot(x, y1, 'r--')\naxes[0,1].grid()\naxes[0,1].set_title(r\"$y_1 = \\cos(2\\pi x)$\")\naxes[0,1].set_ylim(-2,2)\naxes[0,1].set_xlabel(\"x\")\naxes[0,1].set_ylabel(\"y\")\n\n# Build the first plot\naxes[1,0].plot(x, y2, 'g:')\naxes[1,0].grid()\naxes[1,0].set_title(r\"$y_2 = y_0 + y_1$\")\naxes[1,0].set_ylim(-2,2)\naxes[1,0].set_xlabel(\"x\")\naxes[1,0].set_ylabel(\"y\")\n\n# Build the first plot\naxes[1,1].plot(x, y3, 'k-')\naxes[1,1].grid()\naxes[1,1].set_title(r\"$y_3 = y_0 - y_1$\")\naxes[1,1].set_ylim(-2,2)\naxes[1,1].set_xlabel(\"x\")\naxes[1,1].set_ylabel(\"y\")\n\nfig.tight_layout()\nplt.show()\n\n\n\n\n\n\n\nFigure 1.4: An example of subplots\n\n\n\n\n\nThe fig.tight_layout() command makes the plot labels a bit more readable in this instance (again, something you can play with).\n\n\n\nExercise 1.23 Put the functions \\(f(x) = x^2\\), \\(g(x) = x^3\\) and \\(h(x) = x^4\\) in a subplot environment with 1 row and 3 columns of plots. Use the unit interval as the domain and range for all three plot, but sure that each plot has a grid, appropriate labels, an appropriate title, and the overall figure has a title.\n\n1.6.3 Logarithmic Scaling with semilogy, semilogx, and loglog\nIt is occasionally useful to scale an axis logarithmically. This arises most often when we are examining an exponential function, or some other function, that is close to zero for much of the domain. Scaling logarithmically allows us to see how small the function is getting in orders of magnitude instead of as a raw real number. we will use this often in numerical methods.\n\n\n\n\nExample 1.47 In this example we will plot the function \\(y = 10^{-0.01x}\\) on a regular (linear) scale and on a logarithmic scale on the \\(y\\) axis. We use the interval \\([0,500]\\) on the \\(x\\) axis.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nx = np.linspace(0,500,1000)\ny = 10**(-0.01*x)\nfig, axis = plt.subplots(1,2)\n\naxis[0].plot(x,y, 'r')\naxis[0].grid()\naxis[0].set_title(\"Linearly scaled y axis\")\naxis[0].set_xlabel(\"x\")\naxis[0].set_ylabel(\"y\")\n\naxis[1].semilogy(x,y, 'r')\naxis[1].grid()\naxis[1].set_title(\"Logarithmically scaled y axis\")\naxis[1].set_xlabel(\"x\")\naxis[1].set_ylabel(\"Log(y)\")\n\nfig.tight_layout()\nplt.show()\n\n\n\n\n\n\n\nFigure 1.5: An example of using logarithmic scaling.\n\n\n\n\n\nIt should be noted that the same result can be achieved using the yscale command along with the plot command instead of using the semilogy command. So you could replace\naxis[1].semilogy(x,y, 'r')\nby\naxis[1].plot(x,y, 'r')\naxis[1].set_yscale(\"log\")\nto produce identical results.\n\n\n\nExercise 1.24 Plot the function \\(f(x) = x^3\\) for \\(x \\in [0,1]\\) on linearly scaled axes, logarithmic axis in the \\(y\\) direction, logarithmically scaled axes in the \\(x\\) direction, and a log-log plot with logarithmic scaling on both axes. Use subplots to put your plots side-by-side. Give appropriate labels, titles, etc.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Essential Python</span>"
    ]
  },
  {
    "objectID": "nmPython.html#sec:pandas",
    "href": "nmPython.html#sec:pandas",
    "title": "1  Essential Python",
    "section": "1.7 Dataframes with Pandas",
    "text": "1.7 Dataframes with Pandas\nThe Pandas package provides Python with the ability to work with tables of data similar to what R provides via its dataframes. As we will not work with data in this module, we do not need to dive deep into the Pandas package. We will only use it to collect computational results into tables for easier display.\n\nExample 1.48 In this example we will build a simple dataframe with Pandas. We will build a table of the first 10 natural numbers and their squares and. We will then display the table.\n\nimport pandas as pd\nimport numpy as np\n\n# Calculate the columns for the table\nn = np.arange(1,11)\nn2 = n**2\nn3 = n**3\n\n# Combine the columns into a data frame with headers\ndf = pd.DataFrame({'n': n, 'n^2': n2, 'n^3': n3})\ndf\n\n\n\n\n\n\n\n\nn\nn^2\nn^3\n\n\n\n\n0\n1\n1\n1\n\n\n1\n2\n4\n8\n\n\n2\n3\n9\n27\n\n\n3\n4\n16\n64\n\n\n4\n5\n25\n125\n\n\n5\n6\n36\n216\n\n\n6\n7\n49\n343\n\n\n7\n8\n64\n512\n\n\n8\n9\n81\n729\n\n\n9\n10\n100\n1000",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Essential Python</span>"
    ]
  },
  {
    "objectID": "nmPython.html#sec-python_exercises",
    "href": "nmPython.html#sec-python_exercises",
    "title": "1  Essential Python",
    "section": "1.8 Problems",
    "text": "1.8 Problems\nThese problem exercises here are meant for you to practice and improve your coding skills. Please refrain from using Gemini, ChatGPT or Copilot or any other AI for solving these exercises. The point is to struggle through the code, get it wrong many times, debug, and then to eventually have working code.\n\n\nExercise 1.25 (This problem is modified from (“Project Euler” n.d.))\nIf we list all of the numbers below 10 that are multiples of 3 or 5 we get 3, 5, 6, and 9. The sum of these multiples is 23. Write code to find the sum of all the multiples of 3 or 5 below 1000. Your code needs to run error free and output only the sum. There are of course many ways you could approach this exercise. Compare your approach to that of others in your group.\n\n\n\nExercise 1.26 (This problem is modified from (“Project Euler” n.d.))\nEach new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: \\[\\begin{equation}\n1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \\dots\n\\end{equation}\\] By considering the terms in the Fibonacci sequence whose values do not exceed four million, write code to find the sum of the even-valued terms. Your code needs to run error free and output only the sum.\n\n\n\nExercise 1.27 Write computer code that will draw random numbers from the unit interval \\([0,1]\\), distributed uniformly (using Python’s np.random.rand()), until the sum of the numbers that you draw is greater than 1. Keep track of how many numbers you draw. Then write a loop that does this process many many times. On average, how many numbers do you have to draw until your sum is larger than 1?\n\nHint #1:\n\nUse the np.random.rand()command to draw a single number from a uniform distribution with bounds \\((0,1)\\).\n\nHint #2:\n\nYou should do this more than 1,000,000 times to get a good average …and the number that you get should be familiar!\n\n\n\n\n\nExercise 1.28 My favourite prime number is 8675309. Yep. Jenny’s phone number is prime! Write a script that verifies this fact.\n\nHint:\n\nYou only need to check divisors as large as the square root of 8675309 (why).\n\n\n\n\n\nExercise 1.29 (This problem is modified from (“Project Euler” n.d.))\nWrite a function called that accepts an integer and returns a binary variable:\n\n0 = not prime,\n1 = prime.\n\nNext write a script to find the sum of all of the prime numbers less than 1000.\n\nHint:\n\nRemember that a prime number has exactly two divisors: 1 and itself. You only need to check divisors as large as the square root of \\(n\\). Your script should probably be smart enough to avoid all of the non-prime even numbers.\n\n\n\n\n\nExercise 1.30 (This problem is modified from (“Project Euler” n.d.))\nThe sum of the squares of the first ten natural numbers is, \\[\\begin{equation}\n1^2 + 2^2 + \\dots + 10^2 = 385\n\\end{equation}\\] The square of the sum of the first ten natural numbers is, \\[\\begin{equation}\n(1 + 2 + \\dots + 10)^2 = 55^2 = 3025\n\\end{equation}\\] Hence the difference between the square of the sum of the first ten natural numbers and the sum of the squares is \\(3025 - 385 = 2640\\).\nWrite code to find the difference between the square of the sum of the first one hundred natural numbers and the sum of the squares. Your code needs to run error free and output only the difference.\n\n\n\nExercise 1.31 (This problem is modified from (“Project Euler” n.d.))\nThe prime factors of \\(13195\\) are \\(5, 7, 13\\) and \\(29\\). Write code to find the largest prime factor of the number \\(600851475143\\)? Your code needs to run error free and output only the largest prime factor.\n\n\n\nExercise 1.32 (This problem is modified from (“Project Euler” n.d.))\nThe number 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder. Write code to find the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?\nHint: You will likely want to use modular division for this problem.\n\n\n\nExercise 1.33 The following iterative sequence is defined for the set of positive integers: \\[\\begin{equation}\n\\begin{aligned} & n \\to \\frac{n}{2} \\quad \\text{(n is even)} \\\\ & n \\to 3n + 1 \\quad \\text{(n is odd)} \\end{aligned}\n\\end{equation}\\] Using the rule above and starting with \\(13\\), we generate the following sequence: \\[\\begin{equation}\n13 \\to 40 \\to 20 \\to 10 \\to 5 \\to 16 \\to 8 \\to 4 \\to 2 \\to 1\n\\end{equation}\\] It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1. This has been verified on computers for massively large starting numbers, but this does not constitute a proof that it will work this way for all starting numbers.\nWrite code to determine which starting number, under one million, produces the longest chain. NOTE: Once the chain starts, the terms are allowed to go above one million.\n\nFootnotes\n\n\n\n\n“Project Euler.” n.d. Accessed December 14, 2023. https://projecteuler.net/.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Essential Python</span>"
    ]
  },
  {
    "objectID": "nmPython.html#footnotes",
    "href": "nmPython.html#footnotes",
    "title": "1  Essential Python",
    "section": "",
    "text": "Actually, it is still an open mathematical question whether every integer seed will converge to 1. The Collatz sequence has been checked for many millions of initial seeds and they all converge to 1, but there is no mathematical proof that it will always happen.↩︎\nThere is the sympy package if you want to do symbolic computations, but we will not use that in this module.↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Essential Python</span>"
    ]
  },
  {
    "objectID": "nmApprox.html",
    "href": "nmApprox.html",
    "title": "2  Approximations",
    "section": "",
    "text": "2.1 Binary Numbers\nA computer circuit knows two states: on and off. As such, anything saved in computer memory is stored using base-2 numbers. This is called a binary number system. To fully understand a binary number system it is worth while to pause and reflect on our base-10 number system for a few moments.\nWhat do the digits in the number “735” really mean? The position of each digit tells us something particular about the magnitude of the overall number. The number 735 can be represented as a sum of powers of 10 as\n\\[\\begin{equation}\n735 = 700 + 30 + 5 = 7 \\times 10^2 + 3 \\times 10^1 + 5 \\times 10^0\n\\end{equation}\\]\nand we can read this number as 7 hundreds, 3 tens, and 5 ones. As you can see, in a “positional number system” such as our base-10 system, the position of the number indicates the power of the base, and the value of the digit itself tells you the multiplier of that power. This is contrary to number systems like Roman Numerals where the symbols themselves give us the number, and meaning of the position is somewhat flexible. The number “48,329” can therefore be interpreted as\n\\[\\begin{equation}\n\\begin{split}\n48,329 &= 40,000 + 8,000 + 300 + 20 + 9 \\\\\n&= 4 \\times 10^4 + 8 \\times 10^3 + 3 \\times 10^2 + 2 \\times 10^1 + 9 \\times 10^0,\n\\end{split}\n\\end{equation}\\]\nfour ten thousands, eight thousands, three hundreds, two tens, and nine ones.\nNow let us switch to the number system used by computers: the binary number system. In a binary number system the base is 2 so the only allowable digits are 0 and 1 (just like in base-10 the allowable digits were 0 through 9). In binary (base-2), the number “101,101” can be interpreted as\n\\[\\begin{equation}\n101,101_2 = 1 \\times 2^5 + 0 \\times 2^4 + 1 \\times 2^3 + 1 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0\n\\end{equation}\\]\n(where the subscript “2” indicates the base to the reader). If we put this back into base 10, so that we can read it more comfortably, we get\n\\[101,101_2 = 32 + 0 + 8 + 4 + 0 + 1 = 45_{10}.\\]\nThe reader should take note that the commas in the numbers are only to allow for greater readability – we can easily see groups of three digits and mentally keep track of what we are reading.\nNext we will work with fractions and decimals.\nWe can do a similar thing with binary decimals.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Approximations</span>"
    ]
  },
  {
    "objectID": "nmApprox.html#binary-numbers",
    "href": "nmApprox.html#binary-numbers",
    "title": "2  Approximations",
    "section": "",
    "text": "Exercise 2.1 By hand (no computers!) compute the first 50 terms of this sequence with the initial condition \\(x_0 = 1/10\\).\n\\[\\begin{equation}\nx_{n+1} = \\left\\{ \\begin{array}{ll} 2x_n, & x_n \\in [0,\\frac{1}{2}] \\\\ 2x_n - 1, & x_n \\in (\\frac{1}{2},1] \\end{array} \\right.\n\\end{equation}\\]\n\n\n\nExercise 2.2 Now use a spreadsheet and to do the computations. Do you get the same answers?\n\n\n\nExercise 2.3 Finally, solve this problem with Python. Some starter code is given to you below.\nx = 1.0/10\nfor n in range(50):\n    if x&lt;= 0.5:\n        # put the correct assignment here\n    else:\n        # put the correct assigment here\n    print(x)\n\n\n\nExercise 2.4 It seems like the computer has failed you! What do you think happened on the computer and why did it give you a different answer? What, do you suppose, is the cautionary tale hiding behind the scenes with this problem?\n\n\n\nExercise 2.5 Now what happens with this problem when you start with \\(x_0 = 1/8\\)? Why does this new initial condition work better?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 2.6 Express the following binary numbers in base-10.\n\n\\(111_2\\)\n\\(10,101_2\\)\n\\(1,111,111,111_2\\)\n\n\n\n\nExercise 2.7 Explain the joke: There are 10 types of people. Those who understand binary and those who do not.\n\n\n\nExercise 2.8 Discussion: With your group, discuss how you would convert a base-10 number into its binary representation. Once you have a proposed method put it into action on the number \\(237_{10}\\) to show that the base-2 expression is \\(11,101,101_2\\).\n\n\n\nExercise 2.9 Convert the following numbers from base 10 to base 2 or visa versa.\n\nWrite \\(12_{10}\\) in binary\nWrite \\(11_{10}\\) in binary\nWrite \\(23_{10}\\) in binary\nWrite \\(11_2\\) in base \\(10\\)\nWhat is \\(100101_2\\) in base \\(10\\)?\n\n\n\n\nExercise 2.10 Now that you have converted several base-10 numbers to base-2, summarize an efficient technique to do the conversion.\n\n\n\nExample 2.1 Convert the number \\(137\\) from base \\(10\\) to base \\(2\\).\n\n\n\nSolution. One way to do the conversion is to first look for the largest power of \\(2\\) less than or equal to your number. In this case, \\(128=2^7\\) is the largest power of \\(2\\) that is less than \\(137\\). Then looking at the remainder, \\(9\\), look for the largest power of \\(2\\) that is less than this remainder. Repeat until you have the number.\n\\[\\begin{aligned} 137_{10} &= 128 + 8 + 1 \\\\ &= 2^7 + 2^3 + 2^0 \\\\ &= 1 \\times 2^7 + 0 \\times 2^6 + 0 \\times 2^5 + 0 \\times 2^4 + 1 \\times 2^3 + 0 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0 \\\\ &= 10001001_2 \\end{aligned}\\]\n\n\n\n\nExample 2.2 Let us take the base \\(10\\) number \\(5.341_{10}\\) and expand it out to get\n\\[5.341_{10} = 5 + \\frac{3}{10} + \\frac{4}{100} + \\frac{1}{1000} = 5 \\times 10^0 + 3 \\times 10^{-1} + 4 \\times 10^{-2} + 1 \\times 10^{-3}.\\]\nThe position to the right of the decimal point is the negative power of 10 for the given position.\n\n\n\n\nExercise 2.11 The base-2 number \\(1,101.01_2\\) can be expanded in powers of \\(2\\). Fill in the question marks below and observe the pattern in the powers.\n\\[1,101.01_2 = ? \\times 2^3 + 1 \\times 2^2 + 0 \\times 2^1 + ? \\times 2^0 + 0 \\times 2^{?} + 1 \\times 2^{-2}.\\]\n\n\n\nExample 2.3 Convert \\(11.01011_2\\) to base \\(10\\).\nSolution:\n\\[\\begin{aligned} 11.01011_2 &= 2 + 1 + \\frac{0}{2} + \\frac{1}{4} + \\frac{0}{8} + \\frac{1}{16} + \\frac{1}{32} \\\\ &= 1 \\times 2^1 + 1 \\times 2^0 + 0 \\times 2^{-1} + 1 \\times 2^{-2} + 0 \\times 2^{-3} + 1 \\times 2^{-4} + 1 \\times 2^{-5}\\\\ &= 3.34375_{10}. \\end{aligned}\\]\n\n\n\nExercise 2.12 Repeating digits in binary numbers are rather intriguing. The number \\(0.\\overline{0111} = 0.01110111011101110111\\ldots\\) surely also has a decimal representation. I will get you started:\n\\[\\begin{aligned} 0.0_2 &= 0 \\times 2^0 + 0 \\times 2^{-1} = 0.0_{10} \\\\ 0.01_2 &= 0.0_{10} + 1 \\times 2^{-2} = 0.25_{10} \\\\ 0.011_2 &= 0.25_{10} + 1 \\times 2^{-3} = 0.25_{10} + 0.125_{10} = 0.375_{10} \\\\ 0.0111_2 &= 0.375_{10} + 1 \\times 2^{-4} = 0.4375_{10} \\\\ 0.01110_2 &= 0.4375_{10} + 0 \\times 2^{-5} = 0.4375_{10} \\\\ 0.011101_2 &= 0.4375_{10} + 1 \\times 2^{-6} = 0.453125_{10} \\\\ \\vdots & \\qquad \\qquad \\vdots \\qquad \\qquad \\qquad \\vdots \\end{aligned}\\]\nWe want to know what this series converges to in base 10. Work with your partners to approximate the base-10 number.\n\n\n\nExercise 2.13 Convert the following numbers from base 10 to binary.\n\nWhat is \\(1/2\\) in binary?\nWhat is \\(1/8\\) in binary?\nWhat is \\(4.125\\) in binary?\nWhat is \\(0.15625\\) in binary?\n\n\n\n\nExercise 2.14 Convert the base \\(10\\) decimal \\(0.635\\) to binary using the following steps.\n\nMultiply \\(0.635\\) by \\(2\\). The whole number part of the result is the first binary digit to the right of the decimal point.\nTake the result of the previous multiplication and ignore the digit to the left of the decimal point. Multiply the remaining decimal by \\(2\\). The whole number part is the second binary decimal digit.\nRepeat the previous step until you have nothing left, until a repeating pattern has revealed itself, or until your precision is close enough.\n\nExplain why each step gives the binary digit that it does.\n\n\n\nExercise 2.15 Based on your previous problem write an algorithm that will convert base-10 decimals (less than 1) to binary.\n\n\n\nExercise 2.16 Convert the base \\(10\\) fraction \\(1/10\\) into binary. Use your solution to fully describe what went wrong in the Exercise 2.1.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Approximations</span>"
    ]
  },
  {
    "objectID": "nmApprox.html#floating-point-numbers",
    "href": "nmApprox.html#floating-point-numbers",
    "title": "2  Approximations",
    "section": "2.2 Floating Point Numbers",
    "text": "2.2 Floating Point Numbers\nEverything stored in the memory of a computer is a number, but how does a computer actually store a number. More specifically, since computers only have finite memory we would really like to know the full range of numbers that are possible to store in a computer. Clearly, given the uncountable nature of the real numbers, there will be gaps between the numbers that can be stored. We would like to know what gaps in our number system to expect when using a computer to store and do computations on numbers.\n\n\nExercise 2.17 Let us start the discussion with a very concrete example. Consider the number \\(x = -123.15625\\) (in base 10). As we have seen this number can be converted into binary. Indeed\n\\[x = -123.15625_{10} = -1111011.00101_2\\]\n(you should check this).\n\nIf a computer needs to store this number then first they put in the binary version of scientific notation. In this case we write\n\\[x = -1. \\underline{\\hspace{1in}} \\times 2^{\\underline{\\hspace{0.25in}}}\\]\nBased on the fact that every binary number, other than 0, can be written in this way, what three things do you suppose a computer needs to store for any given number?\nUsing your answer to part (b), what would a computer need to store for the binary number \\(x=10001001.1100110011_2\\)?\n\n\n\n\nDefinition 2.1 For any base-2 number \\(x\\) we can write\n\\[x = (-1)^{s} \\times (1+ m) \\times 2^E\\]\nwhere \\(s \\in \\{0,1\\}\\) and \\(m\\) is a binary number such that \\(0 \\le m &lt; 1\\).\nThe number \\(m\\) is called the mantissa or the significand, \\(s\\) is known as the sign bit, and \\(E\\) is known as the exponent.\n\n\n\nExample 2.4 What are the mantissa, sign bit, and exponent for the numbers \\(7_{10}, -7_{10}\\), and \\((0.1)_{10}\\)?\nSolution:\n\nFor the number \\(7_{10}=111_2 = 1.11 \\times 2^2\\) we have \\(s=0, m=0.11\\) and \\(E=2\\).\nFor the number \\(-7_{10}=111_2 = -1.11 \\times 2^2\\) we have \\(s=1, m=0.11\\) and \\(E=2\\).\nFor the number \\(\\frac{1}{10} = 0.000110011001100\\cdots = 1.100110011 \\times 2^{-4}\\) we have \\(s=0, m=0.100110011\\cdots\\), and \\(E = -4\\).\n\n\n\nIn the last part of the previous example we saw that the number \\((0.1)_{10}\\) is actually a repeating decimal in base-2. This means that in order to completely represent the number \\((0.1)_{10}\\) in base-2 we need infinitely many decimal places. Obviously that cannot happen since we are dealing with computers with finite memory. Over the course of the past several decades there have been many systems developed to properly store numbers. The IEEE standard that we now use is the accumulated effort of many computer scientists, much trial and error, and deep scientific research. We now have three standard precisions for storing numbers on a computer: single, double, and extended precision. The double precision standard is what most of our modern computers use.\n\n\nDefinition 2.2 There are two common precisions for storing numbers in a computer.\n\nA single-precision number consists of 32 bits, with 1 bit for the sign, 8 for the exponent, and 23 for the significand.\nA double-precision number consists of 64 bits with 1 bit for the sign, 11 for the exponent, and 52 for the significand.\n\n\n\n\nDefinition 2.3 (Machine precision) Machine precision is the gap between the number 1 and the next larger floating point number. Often it is represented by the symbol \\(\\epsilon\\). To clarify, the number 1 can always be stored in a computer system exactly and if \\(\\epsilon\\) is machine precision for that computer then \\(1+\\epsilon\\) is the next largest number that can be stored with that machine.\n\n\nFor all practical purposes the computer cannot tell the difference between two numbers if the difference is smaller than machine precision. This is of the utmost important when you want to check that something is “zero” since a computer just cannot know the difference between \\(0\\) and \\(\\epsilon\\).\n\nExercise 2.18 To make all of these ideas concrete let us play with a small computer system where each number is stored in the following format:\n\\[s \\, E \\, b_1 \\, b_2 \\, b_3\\]\nThe first entry is a bit for the sign (\\(0=+\\) and \\(1=-\\)). The second entry, \\(E\\) is for the exponent, and we will assume in this example that the exponent can be 0, 1, or \\(-1\\). The three bits on the right represent the significand of the number. Hence, every number in this number system takes the form\n\\[(-1)^s \\times (1+ 0.b_1b_2b_3) \\times 2^{E}\\]\n\nWhat is the smallest positive number that can be represented in this form?\nWhat is the largest positive number that can be represented in this form?\nWhat is the machine precision in this number system?\nWhat would change if we allowed \\(E \\in \\{-2,-1,0,1,2\\}\\)?\n\n\n\n\nExercise 2.19 What are the largest and smallest numbers that can be stored in single and double precision?\n\n\n\nExercise 2.20 What is machine precision for the single and double precision standard?\n\n\n\nExercise 2.21 What is the gap between \\(2^n\\) and the next largest number that can be stored in double precision?\n\n\n\nMuch more can be said about floating point numbers such as how we store infinity, how we store NaN, and how we store 0. The Wikipedia page for floating point arithmetic might be of interest for the curious reader. It is beyond the scope of this module to go into all of those details here. Instead, the biggest takeaway points from this section and the previous are:\n\nAll numbers in a computer are stored with finite precision.\nNice numbers like 0.1 are sometimes not machine representable in binary.\nMachine precision is the gap between 1 and the next largest number that can be stored.\nThe gap between one number and the next grows in proportion to the number.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Approximations</span>"
    ]
  },
  {
    "objectID": "nmApprox.html#loss-of-significant-digits",
    "href": "nmApprox.html#loss-of-significant-digits",
    "title": "2  Approximations",
    "section": "2.3 Loss of significant digits",
    "text": "2.3 Loss of significant digits\nAs we have discussed, when representing real numbers by floating point numbers in the computer, rounding errors will usually occur. However each individual rounding error is only a tiny fraction of the actual number, so should not really matter. However, calculations usually involve a number of steps, and if we are not careful then the rounding errors can get magnified if we perform the steps in an unfortunate way. The following exercises will illustrate this.\n\n\nExample 2.5 Consider the expression \\[\n(10^{10} + 0.123456789) - 10^{10}.\n\\] Mathematically the two terms of \\(10^{10}\\) simply cancel out leaving just \\(0.123456789\\). However, let us evaluate this in Python:\n\n10**10 + 0.123456789 - 10**10\n\n0.12345695495605469\n\n\nOnly the first six digits after the decimal point were preserved, the other digits were replaced by something seemingly random. The reason should be clear. The computer makes a rounding error when it tries to store the \\(10000000000.123456789\\). This is known as the loss of significant digits. It occurs whenever you subtract two almost equal numbers from each other.\n\n\n\nExercise 2.22 Consider the trigonometric idenity \\[\n2\\sin^2(x/2) = 1 - \\cos(x).\n\\] It gives us two different methods to calculate the same quantity. Ask Python to evaluate both sides of the identity. If you want to calculate \\(1 - \\cos(x)\\) with the highest precision, which expression would you use? Discuss.\n\n\n\nExercise 2.23 You know how fo find the solutions to the quadratic equation \\[\na x^2+bx+c=0.\n\\] You know the quadratic formula. For the larger of the two solutions the formula is \\[\nx = \\frac{-b+\\sqrt{b^2-4ac}}.\n\\] Let’s assume that the parameters are given as \\[ a = 1,~~~b = 1000000, ~~~ c = 1.\\] Use the quadratic formula to find the larger of the two solutions, by coding the formula up in Python. You should get a solution slightly larger than 1. Then check whether your value for \\(x\\) really does solve the quadratic equation by evaluating \\(ax^2+bx+c\\) with your value of \\(x\\). You will notice that it does not work. Discuss the cause of the error.\nNow rearrange the quadratic formula for the larger solution by multiplying both the numerator and denominator by \\(-b-\\sqrt{b^2-4ac}\\) and then simplify by multiplying out the resulting numerator. This should give you the alternative formula \\[\nx = \\frac{2c}{-b-\\sqrt{b^2-4ac}}.\n\\] Can you see why this expression will work better for the given parameter values? Again evaluate \\(x\\) with Python and then check it by substituting into the quadratic expression. What do you find?\n\nThese exercises should suffice to make you sensitive to the issue of loss of significant figures.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Approximations</span>"
    ]
  },
  {
    "objectID": "nmApprox.html#sec-Taylor",
    "href": "nmApprox.html#sec-Taylor",
    "title": "2  Approximations",
    "section": "2.4 Approximating Functions",
    "text": "2.4 Approximating Functions\nHow does a computer understand a function like \\(f(x) = e^x\\) or \\(f(x) = \\sin(x)\\) or \\(f(x) = \\log(x)\\)? What happens under the hood, so to speak, when you ask a computer to do a computation with one of these functions? A computer is darn good at arithmetic, but working with transcendental functions like these, or really any other sufficiently complicated functions for that matter, is not something that comes naturally to a computer. What is actually happening under the hood is that the computer only approximates the functions.\n\n\nExercise 2.24 In this problem we are going to make a bit of a wish list for all of the things that a computer will do when approximating a function. We are going to complete the following sentence:\nIf we are going to approximate a smooth function \\(f(x)\\) near the point \\(x=x_0\\) with a simpler function \\(g(x)\\) then …\n(I will get us started with the first two things that seems natural to wish for. The rest of the wish list is for you to complete.)\n\nthe functions \\(f(x)\\) and \\(g(x)\\) should agree at \\(x=x_0\\). In other words, \\(f(x_0) = g(x_0)\\)\nthe function \\(g(x)\\) should only involve addition, subtraction, multiplication, division, and integer exponents since computer are very good at those sorts of operations.\nif \\(f(x)\\) is increasing / decreasing near \\(x=x_0\\) then \\(g(x)\\) …\nif \\(f(x)\\) is concave up / down near \\(x=x_0\\) then \\(g(x)\\)…\nif we zoom into plots of the functions \\(f(x)\\) and \\(g(x)\\) near \\(x=x_0\\) then …\n… is there anything else that you would add?\n\n\n\n\nExercise 2.25 Discuss: Could a polynomial function with a high enough degree satisfy everything in the wish list from the previous problem? Explain your reasoning.\n\n\n\nExercise 2.26 Let us put some parts of the wish list into action. If \\(f(x)\\) is a differentiable function at \\(x=x_0\\) and if \\(g(x) = A + B (x-x_0) + C (x-x_0)^2 + D (x-x_0)^3\\) then\n\nWhat is the value of \\(A\\) such that \\(f(x_0) = g(x_0)\\)? (Hint: substitute \\(x=x_0\\) into the \\(g(x)\\) function)\nWhat is the value of \\(B\\) such that \\(f'(x_0) = g'(x_0)\\)? (Hint: Start by taking the derivative of \\(g(x)\\))\nWhat is the value of \\(C\\) such that \\(f''(x_0) = g''(x_0)\\)?\nWhat is the value of \\(D\\) such that \\(f'''(x_0) = g'''(x_0)\\)?\n\n\n\n\nExercise 2.27 Let \\(f(x) = e^x\\). Put the answers to the previous question into action and build a cubic polynomial that approximates \\(f(x) = e^x\\) near \\(x_0=0\\).\n\n\nIn the previous 4 exercises you have built up some basic intuition for what we would want out of a mathematical operation that might build an approximation of a complicated function. What we have built is actually a way to get better and better approximations for functions out to pretty much any arbitrary accuracy that we like so long as we are near some anchor point (which we called \\(x_0\\) in the previous exercises).\nIn the next several problems you will unpack the approximations of \\(f(x) = e^x\\) a bit more carefully and we will wrap the whole discussion with a little bit of formal mathematical language. Then we will examine other functions like sine, cosine, logarithms, etc. One of the points of this whole discussion is to give you a little glimpse as to what is happening behind the scenes in scientific programming languages when you do computations with these functions. A bigger point is to start getting a feel for how we might go in reverse and approximate an unknown function out of much simpler parts. This last goal is one of the big takeaways from numerical analysis: we can mathematically model highly complicated functions out of fairly simple pieces.\n\n\nExercise 2.28 What is Euler’s number \\(e\\)? You likely remember using this number often in Calculus and Differential Equations. Do you know the decimal approximation for this number? Moreover, is there a way that we could approximate something like \\(\\sqrt{e} = e^{0.5}\\) or \\(e^{-1}\\) without actually having access to the full decimal expansion?\nFor all of the questions below let us work with the function \\(f(x) = e^x\\).\n\nThe function \\(g(x) = 1\\) matches \\(f(x) = e^x\\) exactly at the point \\(x=0\\) since \\(f(0) = e^0 = 1\\). Furthermore if \\(x\\) is very very close to \\(0\\) then the functions \\(f(x)\\) and \\(g(x)\\) are really close to each other. Hence we could say that \\(g(x) = 1\\) is an approximation of the function \\(f(x) = e^x\\) for values of \\(x\\) very very close to \\(x=0\\). Admittedly, though, it is probably pretty clear that this is a horrible approximation for any \\(x\\) just a little bit away from \\(x=0\\).\nLet us get a better approximation. What if we insist that our approximation \\(g(x)\\) matches \\(f(x) = e^x\\) exactly at \\(x=0\\) and ALSO has exactly the same first derivative as \\(f(x)\\) at \\(x=0\\).\n\nWhat is the first derivative of \\(f(x)\\)?\nWhat is \\(f'(0)\\)?\nUse the point-slope form of a line to write the equation of the function \\(g(x)\\) that goes through the point \\((0,f(0))\\) and has slope \\(f'(0)\\). Recall from algebra that the point-slope form of a line is \\(y = f(x_0) + m(x-x_0).\\) In this case we are taking \\(x_0 = 0\\) so we are using the formula \\(g(x) = f(0) + f'(0) (x-0)\\) to get the equation of the line.\n\nWrite Python code to build a plot like Figure 2.1. This plot shows \\(f(x) = e^x\\), our first approximation \\(g(x) = 1\\) and our second approximation \\(g(x) = 1+x\\). You may want to refer back to Exercise 1.22 in the Python chapter.\n\n\n\n\n\n\n\n\n\nFigure 2.1: The first two polynomial approximations of the exponential function.\n\n\n\n\n\n\n\nExercise 2.29 Let us extend the idea from the previous problem to much better approximations of the function \\(f(x) = e^x\\).\n\nLet us build a function \\(g(x)\\) that matches \\(f(x)\\) exactly at \\(x=0\\), has exactly the same first derivative as \\(f(x)\\) at \\(x=0\\), AND has exactly the same second derivative as \\(f(x)\\) at \\(x=0\\). To do this we will use a quadratic function. For a quadratic approximation of a function we just take a slight extension to the point-slope form of a line and use the equation \\[\\begin{equation}\ny = f(x_0) + f'(x_0) (x-x_0) + \\frac{f''(x_0)}{2} (x-x_0)^2.\n\\end{equation}\\] In this case we are using \\(x_0 = 0\\) so the quadratic approximation function looks like \\[\\begin{equation}\ny = f(0) + f'(0) x + \\frac{f''(0)}{2} x^2.\n\\end{equation}\\]\n\nFind the quadratic approximation for \\(f(x) = e^x\\).\nHow do you know that this function matches \\(f(x)\\) is all of the ways described above at \\(x=0\\)?\nAdd your new function to the plot you created in the previous problem.\n\nLet us keep going!! Next we will do a cubic approximation. A cubic approximation takes the form \\[\\begin{equation}\ny = f(x_0) + f'(0) (x-x_0) + \\frac{f''(0)}{2}(x-x_0)^2 + \\frac{f'''(0)}{3!}(x-x_0)^3\n\\end{equation}\\]\n\nFind the cubic approximation for \\(f(x) = e^x\\).\nHow do we know that this function matches the first, second, and third derivatives of \\(f(x)\\) at \\(x=0\\)?\nAdd your function to the plot.\nPause and think: What’s the deal with the \\(3!\\) on the cubic term?\n\nYour turn: Build the next several approximations of \\(f(x) = e^x\\) at \\(x=0\\). Add these plots to the plot that we have been building all along.\n\n\n\n\nExercise 2.30 Use the functions that you have built to approximate \\(\\frac{1}{e} = e^{-1}\\). Check the accuracy of your answer using np.exp(-1) in Python.\n\n\nWhat we have been exploring so far in this section is the Taylor Series of a function.\n\nDefinition 2.4 (Taylor Series) If \\(f(x)\\) is an infinitely differentiable function at the point \\(x_0\\) then \\[\\begin{equation}\nf(x) = f(x_0) + f'(x_0)(x-x_0) + \\frac{f''(x_0)}{2}(x-x_0)^2 + \\cdots \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n + \\cdots\n\\end{equation}\\] for any reasonably small interval around \\(x_0\\). The infinite polynomial expansion is called the Taylor Series of the function \\(f(x)\\). Taylor Series are named for the mathematician Brook Taylor.\n\n\nThe Taylor Series of a function is often written with summation notation as \\[\\begin{equation}\nf(x) = \\sum_{k=0}^\\infty \\frac{f^{(k)}(x_0)}{k!} (x-x_0)^k.\n\\end{equation}\\] Do not let the notation scare you. In a Taylor Series you are just saying: give me a function that\n\nmatches \\(f(x)\\) at \\(x=x_0\\) exactly,\nmatches \\(f'(x)\\) at \\(x=x_0\\) exactly,\nmatches \\(f''(x)\\) at \\(x=x_0\\) exactly,\nmatches \\(f'''(x)\\) at \\(x=x_0\\) exactly,\netc.\n\n(Take a moment and make sure that the summation notation makes sense to you.)\nMoreover, Taylor Series are built out of the easiest types of functions: polynomials. Computers are rather good at doing computations with addition, subtraction, multiplication, division, and integer exponents, so Taylor Series are a natural way to express functions in a computer. The down side is that we can only get true equality in the Taylor Series if we have infinitely many terms in the series. A computer cannot do infinitely many computations. So, in practice, we truncate Taylor Series after many terms and think of the new polynomial function as being close enough to the actual function so far as we do not stray too far from the anchor \\(x_0\\).\n\n\nExercise 2.31 Verify from your previous work that the Taylor Series centred at \\(x_0 = 0\\) for \\(f(x) = e^x\\) is indeed \\[\\begin{equation}\ne^x = 1 + x + \\frac{x^2}{2} + \\frac{x^3}{3!} + \\frac{x^4}{4!} + \\frac{x^5}{5!} + \\cdots.\n\\end{equation}\\]\n\n\n\nExercise 2.32 Do all of the calculations to show that the Taylor Series centred at \\(x_0 = 0\\) for the function \\(f(x) = \\sin(x)\\) is indeed \\[\\begin{equation}\n\\sin(x) = x - \\frac{x^3}{3!} + \\frac{x^5}{5!} - \\frac{x^7}{7!} + \\cdots\n\\end{equation}\\]\n\n\n\nExercise 2.33 Do all of the calculations to show that the Taylor Series centred at \\(x_0 = 0\\) for the function \\(f(x) = \\cos(x)\\) is indeed \\[\\begin{equation}\n\\cos(x) = 1 - \\frac{x^2}{2!} + \\frac{x^4}{4!} - \\frac{x^6}{6!} + \\cdots\n\\end{equation}\\]\n\n\n\nExercise 2.34 Let us compute a few Taylor Series that are not centred at \\(x_0 = 0\\). For example, let us approximate the function \\(f(x) = \\sin(x)\\) near \\(x_0 = \\frac{\\pi}{2}\\). Near the point \\(x_0 = \\frac{\\pi}{2}\\), the Taylor Series approximation will take the form \\[\\begin{equation}\nf(x) = f\\left( \\frac{\\pi}{2} \\right) + f'\\left( \\frac{\\pi}{2} \\right)\\left( x - \\frac{\\pi}{2} \\right) + \\frac{f''\\left( \\frac{\\pi}{2} \\right)}{2!}\\left( x - \\frac{\\pi}{2} \\right)^2 + \\frac{f'''\\left( \\frac{\\pi}{2} \\right)}{3!}\\left( x - \\frac{\\pi}{2} \\right)^3 + \\cdots\n\\end{equation}\\]\nWrite the first several terms of the Taylor Series for \\(f(x) = \\sin(x)\\) centred at \\(x_0 = \\frac{\\pi}{2}\\). Then write Python code to build the plot below showing successive approximations for \\(f(x) = \\sin(x)\\) centred at \\(\\pi/2\\).\n\n\n\n\n\n\n\n\nFigure 2.2: Taylor series approximation of the sine function.\n\n\n\n\n\n\n\n\nExercise 2.35 Repeat the previous exercise for the function \\[\nf(x) = \\log(x) \\text{ centered at } x_0 = 1.\n\\] Use this to give an approximate value for \\(\\log(1.1)\\).\n\n\n\nExample 2.6 Let us conclude this brief section by examining an interesting example. Consider the function \\[\\begin{equation}\nf(x) = \\frac{1}{1-x}.\n\\end{equation}\\] If we build a Taylor Series centred at \\(x_0 = 0\\) it is not too hard to show that we get \\[\\begin{equation}\nf(x) = 1 + x + x^2 + x^3 + x^4 + x^5 + \\cdots\n\\end{equation}\\] (you should stop now and verify this!). However, if we plot the function \\(f(x)\\) along with several successive approximations for \\(f(x)\\) we find that beyond \\(x=1\\) we do not get the correct behaviour of the function (see Figure 2.3). More specifically, we cannot get the Taylor Series to change behaviour across the vertical asymptote of the function at \\(x=1\\). This example is meant to point out the fact that a Taylor Series will only ever make sense near the point at which you centre the expansion. For the function \\(f(x) = \\frac{1}{1-x}\\) centred at \\(x_0 = 0\\) we can only get good approximations within the interval \\(x \\in (-1,1)\\) and no further.\n\n\nCode\nimport numpy as np\nimport math as ma\nimport matplotlib.pyplot as plt\n\n# build the x and y values\nx = np.linspace(-1,2,101)\ny0 = 1/(1-x)\ny1 = 1 + 0*x\ny2 = 1 + x\ny3 = y2 + x**2\ny4 = y3 + x**3 + x**4 + x**5 + x**6 + x**7 + x**8\n\n# plot each of the functions \nplt.plot(x, y0, 'r-', label=r\"$f(x)=\\sin(x)\")\nplt.plot(x, y1, 'c-', label=r\"constant\")\nplt.plot(x, y2, 'g:', label=r\"linear\")\nplt.plot(x, y3, 'b-.', label=r\"quadratic\")\nplt.plot(x, y4, 'k--', label=r\"8th order\")\n\n# set limits on the y axis\nplt.ylim(-3,5)\n\n# put in a grid, legend, title, and axis labels\nplt.grid()\nplt.legend()\nplt.title(\"Taylor approximations of $f(x)=1/(1-x)$ around $x=0$\")\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2.3: Several Taylor Series approximations of the function \\(f(x) = 1/(1-x)\\).\n\n\n\n\n\n\n\nIn the previous example we saw that we cannot always get approximations from Taylor Series that are good everywhere. For every Taylor Series there is a domain of convergence where the Taylor Series actually makes sense and gives good approximations. While it is beyond the scope of this section to give all of the details for finding the domain of convergence for a Taylor Series, a good heuristic is to observe that a Taylor Series will only give reasonable approximations of a function from the centre of the series to the nearest asymptote. The domain of convergence is typically symmetric about the centre as well. For example:\n\nIf we were to build a Taylor Series approximation for the function \\(f(x) = \\log(x)\\) centred at the point \\(x_0 = 1\\) then the domain of convergence should be \\(x \\in (0,2)\\) since there is a vertical asymptote for the natural logarithm function at \\(x=0\\).\nIf we were to build a Taylor Series approximation for the function \\(f(x) = \\frac{5}{2x-3}\\) centred at the point \\(x_0 = 4\\) then the domain of convergence should be \\(x \\in (1.5, 6.5)\\) since there is a vertical asymptote at \\(x=1.5\\) and the distance from \\(x_0 = 4\\) to \\(x=1.5\\) is 2.5 units.\nIf we were to build a Taylor Series approximation for the function \\(f(x) = \\frac{1}{1+x^2}\\) centred at the point \\(x_0 = 0\\) then the domain of convergence should be \\(x \\in (-1,1)\\). This may seem quite odd (and perhaps quite surprising!) but let us think about where the nearest asymptote might be. To find the asymptote we need to solve \\(1+x^2 = 0\\) but this gives us the values \\(x = \\pm i\\). In the complex plane, the numbers \\(i\\) and \\(-i\\) are 1 unit away from \\(x_0 = 0\\), so the “asymptote” is not visible in a real-valued plot but it is still only one unit away. Hence the domain of convergence is \\(x \\in (-1,1)\\). You may want to pause now and build some plots to show yourself that this indeed appears to be true.\n\nA Taylor Series will give good approximations to the function within the domain of convergence, but will give garbage outside of it. For more details about the domain of convergence of a Taylor Series you can refer to the Taylor Series section of the online Active Calculus Textbook [2].",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Approximations</span>"
    ]
  },
  {
    "objectID": "nmApprox.html#truncation-error",
    "href": "nmApprox.html#truncation-error",
    "title": "2  Approximations",
    "section": "2.5 Truncation Error",
    "text": "2.5 Truncation Error\nThe great thing about Taylor Series is that they allow for the representation of potentially very complicated functions as polynomials – and polynomials are easily dealt with on a computer since they involve only addition, subtraction, multiplication, division, and integer powers. The down side is that the order of the polynomial is infinite. Hence, every time we use a Taylor series on a computer we are actually going to be using is a Truncated Taylor Series where we only take a finite number of terms. The idea here is simple in principle:\n\nIf a function \\(f(x)\\) has a Taylor Series representation it can be written as an infinite sum.\nComputers cannot do infinite sums.\nSo stop the sum at some point \\(n\\) and throw away the rest of the infinite sum.\nNow \\(f(x)\\) is approximated by some finite sum so long as you stay pretty close to \\(x = x_0\\),\nand everything that we just chopped off of the end is called the remainder for the finite sum.\n\nLet us be a bit more concrete about it. The Taylor Series for \\(f(x) = e^x\\) centred at \\(x_0 = 0\\) is \\[\\begin{equation}\ne^x = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\frac{x^4}{4!} + \\cdots.\n\\end{equation}\\]\n\n\\(0^{th}\\) Order Approximation of \\(f(x) = e^x\\):\n\nIf we want to use a zeroth-order (constant) approximation \\(f_0(x)\\) of the function \\(f(x) = e^x\\) then we only take the first term in the Taylor Series and the rest is not used for the approximation \\[\\begin{equation}\ne^x = \\underbrace{1}_{\\text{$0^{th}$ order approximation}} + \\underbrace{x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\frac{x^4}{4!} + \\cdots}_{\\text{remainder}}.\n\\end{equation}\\] Therefore we would approximate \\(e^x\\) as \\(e^x \\approx 1=f_0(x)\\) for values of \\(x\\) that are close to \\(x_0 = 0\\). Furthermore, for small values of \\(x\\) that are close to \\(x_0 = 0\\) the largest term in the remainder is \\(x\\) (since for small values of \\(x\\) like 0.01, \\(x^2\\) will be even smaller, \\(x^3\\) even smaller than that, etc). This means that if we use a \\(0^{th}\\) order approximation for \\(e^x\\) then we expect our error to be about the same size as \\(x\\). It is common to then rewrite the truncated Taylor Series as \\[\\begin{equation}\n\\text{$0^{th}$ order approximation: } e^x \\approx 1 + \\mathcal{O}(x)\n\\end{equation}\\] where \\(\\mathcal{O}(x)\\) (read “Big-O of \\(x\\)”) tells us that the expected error for approximations close to \\(x_0 = 0\\) is about the same size as \\(x\\).\n\n\\(1^{st}\\) Order Approximation of \\(f(x) = e^x\\):\n\nIf we want to use a first-order (linear) approximation \\(f_1(x)\\) of the function \\(f(x) = e^x\\) then we gather the \\(0^{th}\\) order and \\(1^{st}\\) order terms together as our approximation and the rest is the remainder \\[\\begin{equation}\ne^x = \\underbrace{1 + x}_{\\text{$1^{st}$ order approximation}} + \\underbrace{\\frac{x^2}{2!} + \\frac{x^3}{3!} + \\frac{x^4}{4!} + \\cdots}_{\\text{remainder}}.\n\\end{equation}\\] Therefore we would approximate \\(e^x\\) as \\(e^x \\approx 1+x=f_1(x)\\) for values of \\(x\\) that are close to \\(x_0 = 0\\). Furthermore, for values of \\(x\\) very close to \\(x_0 = 0\\) the largest term in the remainder is the \\(x^2\\) term. Using Big-O notation we can write the approximation as \\[\\begin{equation}\n\\text{$1^{st}$ order approximation: } e^x \\approx 1 + x + \\mathcal{O}(x^2).\n\\end{equation}\\] Notice that we do not explicitly say what the coefficient is for the \\(x^2\\) term. Instead we are just saying that using the linear function \\(y=1+x\\) to approximate \\(e^x\\) for values of \\(x\\) near \\(x_0=0\\) will result in errors that are of the order of \\(x^2\\).\n\n\\(2^{nd}\\) Order Approximation of \\(f(x) = e^x\\):\n\nIf we want to use a second-order (quadratic) approximation \\(f_2(x)\\) of the function of \\(f(x) = e^x\\) then we gather the \\(0^{th}\\) order, \\(1^{st}\\) order, and \\(2^{nd}\\) order terms together as our approximation and the rest is the remainder \\[\\begin{equation}\ne^x = \\underbrace{1 + x + \\frac{x^2}{2!}}_{\\text{$2^{nd}$ order approximation}} + \\underbrace{\\frac{x^3}{3!} + \\frac{x^4}{4!} + \\cdots}_{\\text{remainder}}.\n\\end{equation}\\] Therefore we would approximate \\(e^x\\) as \\(e^x \\approx 1+x+\\frac{x^2}{2}=f_2(x)\\) for values of \\(x\\) that are close to \\(x_0 = 0\\). Furthermore, for values of \\(x\\) very close to \\(x_0 = 0\\) the largest term in the remainder is the \\(x^3\\) term. Using Big-O notation we can write the approximation as \\[\\begin{equation}\n\\text{$2^{nd}$ order approximation: } e^x \\approx 1 + x + \\frac{x^2}{2} + \\mathcal{O}(x^3).\n\\end{equation}\\] Again notice that we do not explicitly say what the coefficient is for the \\(x^3\\) term. Instead we are just saying that using the quadratic function \\(y=1+x+\\frac{x^2}{2}\\) to approximate \\(e^x\\) for values of \\(x\\) near \\(x_0=0\\) will result in errors that are of the order of \\(x^3\\).\n\n\nKeep in mind that this sort of analysis is only good for values of \\(x\\) that are very close to the centre of the Taylor Series. If you are making approximations that are too far away then all bets are off.\nFor the function \\(f(x) = e^x\\) the idea of approximating the amount of approximation error by truncating the Taylor Series is relatively straight forward: if we want an \\(n^{th}\\) order polynomial approximation \\(f_n(x)\\) of the function of \\(f(x)=e^x\\) near \\(x_0 = 0\\) then \\[\\begin{equation}\ne^x = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\frac{x^4}{4!} + \\cdots + \\frac{x^n}{n!} + \\mathcal{O}(x^{n+1}),\n\\end{equation}\\] meaning that we expect the error to be of the order of \\(x^{n+1}\\).\n\n\nExercise 2.36 Now make the previous discussion a bit more concrete. You know the Taylor Series for \\(f(x) = e^x\\) around \\(x=0\\) quite well at this point so use it to approximate the values of \\(f(0.1) = e^{0.1}\\) and \\(f(0.2)=e^{0.2}\\) by truncating the Taylor series at different orders. Because \\(x=0.1\\) and \\(x=0.2\\) are pretty close to the centre of the Taylor Series \\(x_0 = 0\\), this sort of approximation is reasonable.\nThen compare your approximate values to Python’s values \\(f(0.1)=e^{0.1} \\approx\\) np.exp(0.1) \\(=1.1051709180756477\\) and \\(f(0.2)=e^{0.2} \\approx\\) np.exp(0.2) \\(=1.2214027581601699\\) to calculate the truncation errors \\(\\epsilon_n(0.1)=|f(0.1)-f_n(0.1)|\\) and \\(\\epsilon_n(0.2)=|f(0.2)-f_n(0.2)|\\).\nFill in the blanks in the table. If you want to create the table in your jupyter notebook, you can use Pandas as described in ?sec-pandas\n\n\n\n\n\n\n\n\n\n\nOrder \\(n\\)\n\\(f_n(0.1)\\)\n\\(\\epsilon_n(0.1)=|f(0.1)-f_n(0.1)|\\)\n\\(f_n(0.2)\\)\n\\(\\epsilon_n(0.2)=|f(0.2)-f_n(0.2)|\\)\n\n\n\n\n0\n1\n1.051709e-01\n1\n2.214028e-01\n\n\n1\n1.1\n5.170918e-03\n1.2\n\n\n\n2\n1.105\n\n\n\n\n\n3\n\n\n\n\n\n\n4\n\n\n\n\n\n\n5\n\n\n\n\n\n\n\n\n\nYou will find that, as expected, the truncation errors \\(\\epsilon_n(x)\\) decrease with \\(n\\) but increase with \\(x\\).\n\n\nExercise 2.37 To investigate the dependence of the truncation error \\(\\epsilon_n(x)\\) on \\(n\\) and \\(x\\) a bit more, add an extra column to the table from the previous exercise with the ratio \\(\\epsilon_n(0.2) / \\epsilon_n(0.1)\\).\n\n\n\n\n\n\n\n\n\nOrder \\(n\\)\n\\(\\epsilon_n(0.1)\\)\n\\(\\epsilon_n(0.2)\\)\n\\(\\epsilon_n(0.2) / \\epsilon_n(0.1)\\)\n\n\n\n\n0\n1.051709e-01\n2.214028e-01\n2.105171\n\n\n1\n5.170918e-03\n\n\n\n\n2\n\n\n\n\n\n3\n\n\n\n\n\n4\n\n\n\n\n\n5\n\n\n\n\n\n\nFormulate a conjecture about how \\(\\epsilon_n\\) changes as \\(x\\) changes.\n\n\n\nExercise 2.38 To test your conjecture, examine the truncation error for the sine function near \\(x_0 = 0\\). You know that the sine function has the Taylor Series centred at \\(x_0 = 0\\) as \\[\\begin{equation}\nf(x) = \\sin(x) = x - \\frac{x^3}{3!} + \\frac{x^5}{5!} - \\frac{x^7}{7!} + \\cdots.\n\\end{equation}\\] So there are only approximations of odd order. Use the truncated Taylor series to approximate \\(f(0.1)=\\sin(0.1)\\) and \\(f(0.2)=\\sin(0.2)\\) and use Python’s values np.sin(0.1) and np.sin(0.2) to calculate the truncation errors \\(\\epsilon_n(0.1)=|f(0.1)-f_n(0.1)|\\) and \\(\\epsilon_n(0.2)=|f(0.2)-f_n(0.2)|\\).\nComplete the following table:\n\n\n\n\n\n\n\n\n\n\nOrder \\(n\\)\n\\(\\epsilon_n(0.1)\\)\n\\(\\epsilon_n(0.2)\\)\n\\(\\epsilon_n(0.2)/ \\epsilon_n(0.1)\\)\nYour Conjecture\n\n\n\n\n1\n1.665834e-04\n1.330669e-03\n\n\n\n\n3\n8.331349e-08\n2.664128e-06\n\n\n\n\n5\n1.983852e-11\n\n\n\n\n\n7\n\n\n\n\n\n\n9\n\n\n\n\n\n\n\n\nThe entry in the last row of the table will almost certainly not agree with your conjecture. That is okay! That discrepancy has a different explanation. Can you figure out what it is? Hint: does np.sin(x) give you the exact value of \\(\\sin(x)\\)?\n\n\nExercise 2.39 Perform another check of your conjecture by approximating \\(\\log(1.02)\\) and \\(\\log(1.1)\\) from truncations of the Taylor series around \\(x=1\\): \\[\n\\log(1+x) = x - \\frac{x^2}{2} + \\frac{x^3}{3} - \\frac{x^4}{4} + \\frac{x^5}{5} - \\cdots.\n\\]\n\n\n\nExercise 2.40 Write down your observations about how the truncation error at order \\(n\\) changes as \\(x\\) changes. Explain this in terms of the form of the remainder of the truncated Taylor series.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Approximations</span>"
    ]
  },
  {
    "objectID": "nmApprox.html#problems",
    "href": "nmApprox.html#problems",
    "title": "2  Approximations",
    "section": "2.6 Problems",
    "text": "2.6 Problems\nThese problem exercises will let you consolidate what you have learned so far and combine it with the coding skills you picked up in Chapter 1.\n\n\nExercise 2.41 (This problem is modified from (Greenbaum and Chartier 2012))\nSometimes floating point arithmetic does not work like we would expect (and hope) as compared to by-hand mathematics. In each of the following problems we have a mathematical problem that the computer gets wrong. Explain why the computer is getting these wrong.\n\nMathematically we know that \\(\\sqrt{5}^2\\) should just give us 5 back. In Python type np.sqrt(5)**2 == 5. What do you get and why do you get it?\nMathematically we know that \\(\\left( \\frac{1}{49} \\right) \\cdot 49\\) should just be 1. In Python type (1/49)*49 == 1. What do you get and why do you get it?\nMathematically we know that \\(e^{\\log(3)}\\) should just give us 3 back. In Python type np.exp(np.log(3)) == 3. What do you get and why do you get it?\nCreate your own example of where Python gets something incorrect because of floating point arithmetic.\n\n\n\n\nExercise 2.42 (This problem is modified from (Greenbaum and Chartier 2012))\nIn the 1999 film Office Space, a character creates a program that takes fractions of cents that are truncated in a bank’s transactions and deposits them to his own account. This idea has been attempted in the past and now banks look for this sort of thing. In this problem you will build a simulation of the program to see how long it takes to become a millionaire.\nAssumptions:\n\nAssume that you have access to 50,000 bank accounts.\nAssume that the account balances are uniformly distributed between $100 and $100,000.\nAssume that the annual interest rate on the accounts is 5% and the interest is compounded daily and added to the accounts, except that fractions of cents are truncated.\nAssume that your illegal account initially has a $0 balance.\n\nYour Tasks:\n\nExplain what the code below does.\n\nimport numpy as np\naccounts = 100 + (100000-100) * np.random.rand(50000,1);\naccounts = np.floor(100*accounts)/100;\n\nBy hand (no computer) write the mathematical steps necessary to increase the accounts by (5/365)% per day, truncate the accounts to the nearest penny, and add the truncated amount into an account titled “illegal.”\nWrite code to complete your plan from part (b).\nUsing a while loop, iterate over your code until the illegal account has accumulated $1,000,000. How long does it take?\n\n\n\n\nExercise 2.43 (This problem is modified from (Greenbaum and Chartier 2012))\nIn the 1991 Gulf War, the Patriot missile defence system failed due to roundoff error. The troubles stemmed from a computer that performed the tracking calculations with an internal clock whose integer values in tenths of a second were converted to seconds by multiplying by a 24-bit binary approximation to \\(\\frac{1}{10}\\): \\[\\begin{equation}\n0.1_{10} \\approx 0.00011001100110011001100_2.\n\\end{equation}\\]\n\nConvert the binary number above to a fraction by hand (common denominators would be helpful).\nThe approximation of \\(\\frac{1}{10}\\) given above is clearly not equal to \\(\\frac{1}{10}\\). What is the absolute error in this value?\nWhat is the time error, in seconds, after 100 hours of operation?\nDuring the 1991 war, a Scud missile travelled at approximately Mach 5 (3750 mph). Find the distance that the Scud missile would travel during the time error computed in (c).\n\n\n\n\nExercise 2.44 Find the Taylor Series for \\(f(x) = \\frac{1}{\\log(x)}\\) centred at the point \\(x_0 = e\\). Then use the Taylor Series to approximate the number \\(\\frac{1}{\\log(3)}\\) to 4 decimal places.\n\n\n\nExercise 2.45 In this problem we will use Taylor Series to build approximations for the irrational number \\(\\pi\\).\n\nWrite the Taylor series centred at \\(x_0=0\\) for the function \\[\\begin{equation}\nf(x) = \\frac{1}{1+x}.\n\\end{equation}\\]\nNow we want to get the Taylor Series for the function \\(g(x) = \\frac{1}{1+x^2}\\). It would be quite time consuming to take all of the necessary derivatives to get this Taylor Series. Instead we will use our answer from part (a) of this problem to shortcut the whole process.\n\nSubstitute \\(x^2\\) for every \\(x\\) in the Taylor Series for \\(f(x) = \\frac{1}{1+x}\\).\nMake a few plots to verify that we indeed now have a Taylor Series for the function \\(g(x) = \\frac{1}{1+x^2}\\).\n\nRecall from Calculus that \\[\\begin{equation}\n\\int \\frac{1}{1+x^2} dx = \\arctan(x).\n\\end{equation}\\] Hence, if we integrate each term of the Taylor Series that results from part (b) we should have a Taylor Series for \\(\\arctan(x)\\).1\nNow recall the following from Calculus:\n\n\n\\(\\tan(\\pi/4) = 1\\)\nso \\(\\arctan(1) = \\pi/4\\)\nand therefore \\(\\pi = 4\\arctan(1)\\).\nLet us use these facts along with the Taylor Series for \\(\\arctan(x)\\) to approximate \\(\\pi\\): we can just plug in \\(x=1\\) to the series, add up a bunch of terms, and then multiply by 4. Write a loop in Python that builds successively better and better approximations of \\(\\pi\\). Stop the loop when you have an approximation that is correct to 6 decimal places.\n\n\n\n\nExercise 2.46 In this problem we will prove the famous (and the author’s favourite) formula \\[\\begin{equation}\ne^{i\\theta} = \\cos(\\theta) + i \\sin(\\theta).\n\\end{equation}\\] This is known as Euler’s formula after the famous mathematician Leonard Euler. Show all of your work for the following tasks.\n\nWrite the Taylor series for the functions \\(e^x\\), \\(\\sin(x)\\), and \\(\\cos(x)\\).\nReplace \\(x\\) with \\(i\\theta\\) in the Taylor expansion of \\(e^x\\). Recall that \\(i = \\sqrt{-1}\\) so \\(i^2 = -1\\), \\(i^3 = -i\\), and \\(i^4 = 1\\). Simplify all of the powers of \\(i\\theta\\) that arise in the Taylor expansion. I will get you started: \\[\\begin{equation}\n\\begin{aligned} e^x &= 1 + x + \\frac{x^2}{2} + \\frac{x^3}{3!} + \\frac{x^4}{4!} + \\frac{x^5}{5!} + \\cdots \\\\ e^{i\\theta} &= 1 + (i\\theta) + \\frac{(i\\theta)^2}{2!} + \\frac{(i\\theta)^3}{3!} + \\frac{(i\\theta)^4}{4!} + \\frac{(i\\theta)^5}{5!} + \\cdots \\\\ &= 1 + i\\theta + i^2 \\frac{\\theta^2}{2!} + i^3 \\frac{\\theta^3}{3!} + i^4 \\frac{\\theta^4}{4!} + i^5 \\frac{\\theta^5}{5!} + \\cdots \\\\ &= \\ldots \\text{ keep simplifying ... } \\ldots \\end{aligned}\n\\end{equation}\\]\nGather all of the real terms and all of the imaginary terms together. Factor the \\(i\\) out of the imaginary terms. What do you notice?\nUse your result from part (c) to prove that \\(e^{i\\pi} + 1 = 0\\).\n\n\n\n\nExercise 2.47 In physics, the relativistic energy of an object is defined as \\[\\begin{equation}\nE_{rel} = \\gamma mc^2\n\\end{equation}\\] where \\[\\begin{equation}\n\\gamma = \\frac{1}{\\sqrt{1 - \\frac{v^2}{c^2}}}.\n\\end{equation}\\] In these equations, \\(m\\) is the mass of the object, \\(c\\) is the speed of light (\\(c \\approx 3 \\times 10^8\\)m/s), and \\(v\\) is the velocity of the object. For an object of fixed mass (m) we can expand the Taylor Series centred at \\(v=0\\) for \\(E_{rel}\\) to get \\[\\begin{equation}\nE_{rel} = mc^2 + \\frac{1}{2} mv^2 + \\frac{3}{8} \\frac{mv^4}{c^2} + \\frac{5}{16} \\frac{mv^6}{c^4} + \\cdots.\n\\end{equation}\\]\n\nWhat do we recover if we consider an object with zero velocity?\nWhy might it be completely reasonable to only use the quadratic approximation \\[\\begin{equation}\nE_{rel} = mc^2 + \\frac{1}{2} mv^2\n\\end{equation}\\] for the relativistic energy equation?2\n(some physics knowledge required) What do you notice about the second term in the Taylor Series approximation of the relativistic energy function?\nShow all of the work to derive the Taylor Series centred at \\(v = 0\\) given above.\n\n\n\n\nExercise 2.48 (The Python Caret Operator) Now that you’re used to using Python to do some basic computations you are probably comfortable with the fact that the caret, ^, does NOT do exponentiation like it does in many other programming languages. But what does the caret operator do? That’s what we explore here.\n\nConsider the numbers \\(9\\) and \\(5\\). Write these numbers in binary representation. We are going to use four bits to represent each number (it is OK if the first bit happens to be zero). \\[\\begin{equation}\n\\begin{aligned} 9 &=& \\underline{\\hspace{0.2in}} \\, \\underline{\\hspace{0.2in}} \\, \\underline{\\hspace{0.2in}} \\, \\underline{\\hspace{0.2in}} \\\\ 5 &=& \\underline{\\hspace{0.2in}} \\, \\underline{\\hspace{0.2in}} \\, \\underline{\\hspace{0.2in}} \\, \\underline{\\hspace{0.2in}} \\end{aligned}\n\\end{equation}\\]\nNow go to Python and evaluate the expression 9^5. Convert Python’s answer to a binary representation (again using four bits).\nMake a conjecture: How do we go from the binary representations of \\(a\\) and \\(b\\) to the binary representation for Python’s a^b for numbers \\(a\\) and \\(b\\)? Test and verify your conjecture on several different examples and then write a few sentences explaining what the caret operator does in Python.\n\n\n\n\n\n\n\nGreenbaum, Anne, and Tim P. Chartier. 2012. Numerical Methods: Design, Analysis, and Computer Implementation of Algorithms. Princeton University Press.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Approximations</span>"
    ]
  },
  {
    "objectID": "nmApprox.html#footnotes",
    "href": "nmApprox.html#footnotes",
    "title": "2  Approximations",
    "section": "",
    "text": "There are many reasons why integrating an infinite series term by term should give you a moment of pause. For the sake of this problem we are doing this operation a little blindly, but in reality we should have verified that the infinite series actually converges uniformly.↩︎\nThis is something that people in physics and engineering do all the time – there is some complicated nonlinear relationship that they wish to use, but the first few terms of the Taylor Series captures almost all of the behaviour since the higher-order terms are very very small.↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Approximations</span>"
    ]
  },
  {
    "objectID": "nmAlgebra.html",
    "href": "nmAlgebra.html",
    "title": "3  Algebra",
    "section": "",
    "text": "3.1 Introduction to Numerical Root Finding\nIn this chapter we want to solve equations using a computer. The goal of equation solving is to find the value of the independent variable which makes the equation true. These are the sorts of equations that you learned to solve at school. For a very simple example, solve for \\(x\\) if \\(x+5 = 2x- 3\\). Or, for another example, the equation \\(x^2+x=2x - 7\\) is an equation that could be solved with the quadratic formula. The equation \\(\\sin(x) = \\frac{\\sqrt{2}}{2}\\) is an equation which can be solved using some knowledge of trigonometry. The topic of Numerical Root Finding really boils down to approximating the solutions to equations without using all of the by-hand techniques that you learned in high school. The down side to everything that we are about to do is that our answers are only ever going to be approximations.\nThe fact that we will only ever get approximate answers begs the question: why would we want to do numerical algebra if by-hand techniques exist? The answers are relatively simple:\nLet us first take a look at equations in a more abstract way. Consider the equation \\(\\ell(x) = r(x)\\) where \\(\\ell(x)\\) and \\(r(x)\\) stand for left-hand and right-hand expressions respectively. To begin solving this equation we can first rewrite it by subtracting the right-hand side from the left to get \\[\\begin{equation}\n\\ell(x) - r(x) = 0.\n\\end{equation}\\] Hence, we can define a function \\(f(x)\\) as \\(f(x)=\\ell(x)-r(x)\\) and observe that every equation can be written as: \\[\\begin{equation}\n\\text{If } f(x) = 0, \\text{ find } x.\n\\end{equation}\\] This gives us a common language for which to frame all of our numerical algorithms. An \\(x\\) where \\(f(x)=0\\) is called a root of \\(f\\) and thus we have seen that solving an equation is always a root finding problem.\nFor example, if we want to solve the equation \\(3\\sin(x) + 9 = x^2 - \\cos(x)\\) then this is the same as solving \\((3\\sin(x) + 9 ) - (x^2 - \\cos(x)) = 0\\). We illustrate this idea in Figure 3.1. You should pause and notice that there is no way that you are going to apply by-hand techniques from algebra to solve this equation … an approximate answer is pretty much our only hope.\nCode\nimport numpy as np \nimport matplotlib.pyplot as plt\nx = np.linspace(-4,4, 100) \nl = 3 * np.sin(x) + 9\nr = x**2 - np.cos(x)\n\nfig, axes = plt.subplots(nrows = 1, ncols = 2)\n\naxes[0].plot(x, l, 'b-.', label=r\"$3\\sin(x)+9$\")\naxes[0].plot(x, r, 'r-', label=r\"$x^2-\\cos(x)$\")\naxes[0].grid()\naxes[0].legend()\naxes[0].set_title(r\"$3\\sin(x)+9 = x^2-\\cos(x)$\")\n\naxes[1].plot(x, l-r, 'g:', label=r\"(3\\sin(x)+9) - (x^2-\\cos(x))\")\naxes[1].plot(x, np.zeros(100), 'k-')\naxes[1].grid()\naxes[1].legend()\naxes[1].set_title(r\"$(3\\sin(x)+9) - (x^2-\\cos(x))=0$\")\n\nfig.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 3.1: Two ways to visualise the same root finding problem\nOn the left-hand side of Figure 3.1 we see the solutions as the intersections of the graph of \\(3\\sin(x) + 9\\) with the graph of \\(x^2 - \\cos(x)\\), and on the right-hand side we see the solutions as the intersections of the graph of\n\\(\\left( 3\\sin(x)+9 \\right) - \\left( x^2 - \\cos(x) \\right)\\) with the \\(x\\) axis. From either plot we can read off the approximate solutions: \\(x_1 \\approx -2.55\\) and \\(x_2 \\approx 2.88\\). Figure 3.1 should demonstrate what we mean when we say that solving equations of the form \\(\\ell(x) = r(x)\\) will give the same answer as finding the roots of \\(f(x) = \\ell(x)-r(x)\\).\nWe now have one way to view every equation-solving problem. As we will see in this chapter, if \\(f(x)\\) has certain properties then different numerical techniques for solving the equation will apply – and some will be much faster and more accurate than others. In the following sections you will develop several different techniques for solving equations of the form \\(f(x) = 0\\). You will start with the simplest techniques to implement and then move to the more powerful techniques that use some ideas from Calculus to understand and analyse. Throughout this chapter you will also work to quantify the amount of error that one makes when using these techniques.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algebra</span>"
    ]
  },
  {
    "objectID": "nmAlgebra.html#introduction-to-numerical-root-finding",
    "href": "nmAlgebra.html#introduction-to-numerical-root-finding",
    "title": "3  Algebra",
    "section": "",
    "text": "Most equations do not lend themselves to by-hand solutions. The reason you may not have noticed that is that we tend to show you only nice equations that arise in often very simplified situations. When equations arise naturally they are often not nice.\nBy-hand algebra is often very challenging, quite time consuming, and error prone. You will find that the numerical techniques are quite elegant, work very quickly, and require very little overhead to actually implement and verify.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algebra</span>"
    ]
  },
  {
    "objectID": "nmAlgebra.html#sec-bisection",
    "href": "nmAlgebra.html#sec-bisection",
    "title": "3  Algebra",
    "section": "3.2 The Bisection Method",
    "text": "3.2 The Bisection Method\n\n3.2.1 Intuition and Implementation\n\nExercise 3.1 A friend tells you that she is thinking of a number between 1 and 100. She will allow you multiple guesses with some feedback for where the mystery number falls. How do you systematically go about guessing the mystery number? Is there an optimal strategy?\nFor example, the conversation might go like this.\n\nSally: I am thinking of a number between 1 and 100.\nJoe: Is it 35?\nSally: No, 35 is too low.\nJoe: Is it 99?\nSally: No, 99 is too high.\n…\n\n\n\n\nExercise 3.2 Imagine that Sally likes to formulate her answer not in the form “\\(x\\) is too small” or “\\(x\\) is too large” but in the form “\\(f(x)\\) is positive” or “\\(f(x)\\) is negative”. What continuous function could she choose for \\(f(x)\\) so that her new answers contain exactly the same as her previous answers? Give an expression for a possible \\(f(x)\\) assuming that we call Sally’s chosen number \\(x_0\\). Can you now explain how Sally’s game is a root finding game?\n\n\n\nExercise 3.3 Now go and play the game with other functions \\(f(x)\\). Choose someone from your group to be Sally and someone else to be Joe. Sally can choose a continuous function and Joe needs to guess its root. Does your strategy still allow Joe to find the root of \\(f(x)\\)? Does Sally need to give Joe some extra information to give him a fighting chance?\n\n\n\nExercise 3.4 Was it necessary to say that Sally’s function was continuous? Does your strategy work if the function is not continuous.\n\n\nNow let us get to the maths. We will start the mathematical discussion with a theorem from Calculus.\n\nTheorem 3.1 (The Intermediate Value Theorem (IVT)) If \\(f(x)\\) is a continuous function on the closed interval \\([a,b]\\) and \\(y_*\\) lies between \\(f(a)\\) and \\(f(b)\\), then there exists some point \\(x_* \\in [a,b]\\) such that \\(f(x_*) = y_*\\).\n\n\n\nExercise 3.5 Draw a picture of what the intermediate value theorem says graphically.\n\n\n\nExercise 3.6 If \\(y_*=0\\) the Intermediate Value Theorem gives us important information about solving equations. What does it tell us?\n\n\n\nCorollary 3.1 If \\(f(x)\\) is a continuous function on the closed interval \\([a,b]\\) and if \\(f(a)\\) and \\(f(b)\\) have opposite signs then from the Intermediate Value Theorem we know that there exists some point \\(x_* \\in [a,b]\\) such that ____.\n\n\n\nExercise 3.7 Fill in the blank in the previous corollary and then draw several pictures that indicate why this might be true for continuous functions.\n\n\nThe Intermediate Value Theorem (IVT) and its corollary are existence theorems in the sense that they tell us that some point exists. The annoying thing about mathematical existence theorems is that they typically do not tell us how to find the point that is guaranteed to exist. The method that you developed in Exercise 3.1 to Exercise 3.3 gives one possible way to find the root.\nIn those exercises you likely came up with an algorithm such as this:\n\nSay we know that a continuous function has opposite signs at \\(x=a\\) and \\(x=b\\).\nGuess that the root is at the midpoint \\(m = \\frac{a+b}{2}\\).\nBy using the signs of the function, narrow the interval which contains the root to either \\([a,m]\\) or \\([m,b]\\).\nRepeat\n\nNow we will turn this strategy into computer code that will simply play the game for us. But first we need to pay careful attention to some of the mathematical details.\n\n\nExercise 3.8 Where is the Intermediate Value Theorem used in the root-guessing strategy?\n\n\n\nExercise 3.9 Why was it important that the function \\(f(x)\\) is continuous when playing this root-guessing game? Provide a few sketches to demonstrate your answer.\n\n\n\nExercise 3.10 (The Bisection Method) Goal: We want to solve the equation \\(f(x) = 0\\) for \\(x\\) assuming that the solution \\(x^*\\) is in the interval \\([a,b]\\).\nThe Algorithm: Assume that \\(f(x)\\) is continuous on the closed interval \\([a,b]\\). To make approximations of the solutions to the equation \\(f(x) = 0\\), do the following:\n\nCheck to see if \\(f(a)\\) and \\(f(b)\\) have opposite signs. You can do this taking the product of \\(f(a)\\) and \\(f(b)\\).\n\nIf \\(f(a)\\) and \\(f(b)\\) have different signs then what does the IVT tell you?\nIf \\(f(a)\\) and \\(f(b)\\) have the same sign then what does the IVT not tell you? What should you do in this case?\nWhy does the product of \\(f(a)\\) and \\(f(b)\\) tell us something about the signs of the two numbers?\n\nCompute the midpoint of the closed interval, \\(m=\\frac{a+b}{2}\\), and evaluate \\(f(m)\\).\n\nWill \\(m\\) always be a better guess of the root than \\(a\\) or \\(b\\)? Why?\nWhat should you do here if \\(f(m)\\) is really close to zero?\n\nCompare the signs of \\(f(a)\\) versus \\(f(m)\\) and \\(f(b)\\) versus \\(f(m)\\).\n\nWhat do you do if \\(f(a)\\) and \\(f(m)\\) have opposite signs?\nWhat do you do if \\(f(m)\\) and \\(f(b)\\) have opposite signs?\n\nRepeat steps 2 and 3 and stop when \\(f(m)\\) is close enough to zero.\n\n\n\n\nExercise 3.11 Draw a picture illustrating what the Bisection Method does to approximate a solution to an equation \\(f(x) = 0\\).\n\n\n\nExercise 3.12 We want to write a Python function for the Bisection Method. Instead of jumping straight into the code we should ALWAYS write pseudo-code first. It is often helpful to write pseudo-code as comments in your file. Use the template below to complete your pseudo-code.\ndef Bisection(f , a , b , tol):\n# The input parameters are\n# f is a function\n# a is the lower end of the interval\n# b is the upper end of the interval\n# tol is an optional tolerance for the accuracy of the root\n\n# if the user does not define a tolerance we need \n# code to create a default\n\n# check that a and b have opposite signs\n# if not we should return an error and break the code\n\n# next calculate the midpoint m = (a+b)/2\n\n# start a while loop\n#   # in the while loop we need an if statement\n#   # if ...\n#   # elif ...\n#   # elif ...\n\n#   # we should check that the while loop is not running away\n\n# end the while loop\n# define and return the root\n\n\n\nExercise 3.13 Now use the pseudo-code from Exercise 3.12 as structure to complete a Python function for the Bisection Method. Test your Bisection Method code on the following equations.\n\n\\(x^2 - 2 = 0\\) on \\(x \\in [0,2]\\)\n\\(\\sin(x) + x^2 = 2\\log(x) + 5\\) on \\(x \\in [0,5]\\) (be careful! make a plot first)\n\\((5-x)e^{x}=5\\) on \\(x \\in [0,5]\\)\n\n\n\nFigure 3.2 shows an animation showing the bisection method in action on the equation \\(x^2 - 2 = 0\\).\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\nFigure 3.2: An animation of the bisection method in action on the equation \\(x^2 - 2 = 0\\).\n\n\n\n\n\n\n\n3.2.2 Analysis\nAfter we build any root finding algorithm we need to stop and think about how it will perform on new problems. The questions that we typically have for a root-finding algorithm are:\n\nWill the algorithm always converge to a solution?\nHow fast will the algorithm converge to a solution?\nAre there any pitfalls that we should be aware of when using the algorithm?\n\n\n\nExercise 3.14 Discussion: What must be true in order to use the bisection method?\n\n\n\nExercise 3.15 Discussion: Does the bisection method work if the Intermediate Value Theorem does not apply? (Hint: what does it mean for the IVT to “not apply?”)\n\n\n\nExercise 3.16 If there is a root of a continuous function \\(f(x)\\) between \\(x=a\\) and \\(x=b\\) will the bisection method always be able to find it? Why / why not?\n\n\nNext we will focus on a deeper mathematical analysis that will allow us to determine exactly how fast the bisection method actually converges to within a pre-set tolerance. Work through the next problem to develop a formula that tells you exactly how many steps the bisection method needs to take before it gets close enough to the true solution.\n\n\nExercise 3.17 Let \\(f(x)\\) be a continuous function on the interval \\([a,b]\\) and assume that \\(f(a) \\cdot f(b) &lt;0\\). A recurring theme in Numerical Analysis is to approximate some mathematical thing to within some tolerance. For example, if we want to approximate the solution to the equation \\(f(x)=0\\) to within \\(\\varepsilon\\) with the bisection method, we should be able to figure out how many steps it will take to achieve that goal.\n\nLet us say that \\(a = 3\\) and \\(b = 8\\) and \\(f(a) \\cdot f(b) &lt; 0\\) for some continuous function \\(f(x)\\). The width of this interval is \\(5\\), so if we guess that the root is \\(m=(3+8)/2 = 5.5\\) then our error is less than \\(5/2\\). In the more general setting, if there is a root of a continuous function in the interval \\([a,b]\\) then how far off could the midpoint approximation of the root be? In other words, what is the error in using \\(m=(a+b)/2\\) as the approximation of the root?\nThe bisection method cuts the width of the interval down to a smaller size at every step. As such, the approximation error gets smaller at every step. Fill in the blanks in the following table to see the pattern in how the approximation error changes with each iteration.\n\n\n\n\nIteration\nWidth of Interval\nMaximal Error\n\n\n\n\n1\n\\(|b-a|\\)\n\\(\\frac{|b-a|}{2}\\)\n\n\n2\n\\(\\frac{|b-a|}{2}\\)\n\n\n\n3\n\\(\\frac{|b-a|}{2^2}\\)\n\n\n\n\\(\\vdots\\)\n\\(\\vdots\\)\n\\(\\vdots\\)\n\n\n\\(n\\)\n\\(\\frac{|b-a|}{2^{n-1}}\\)\n\n\n\n\n\nNow to the key question:\nIf we want to approximate the solution to the equation \\(f(x)=0\\) to within some tolerance \\(\\varepsilon\\) then how many iterations of the bisection method do we need to take?\nHint: Set the \\(n^{th}\\) approximation error from the table equal to \\(\\varepsilon\\). What should you solve for from there?\n\n\n\nIn Exercise 3.17 you actually proved the following theorem.\n\nTheorem 3.2 (Convergence Rate of the Bisection Method) If \\(f(x)\\) is a continuous function with a root in the interval \\([a,b]\\) and if the bisection method is performed to find the root then:\n\nThe error between the actual root and the approximate root will decrease by a factor of 2 at every iteration.\nIf we want the approximate root found by the bisection method to be within a tolerance of \\(\\varepsilon\\) then \\[\\begin{equation}\n\\frac{|b-a|}{2^{n}} = \\varepsilon\n\\end{equation}\\] where \\(n\\) is the number of iterations that it takes to achieve that tolerance.\n\n\nSolving for the number of iterations (\\(n\\)) we get \\[\\begin{equation}\nn = \\log_2\\left( \\frac{|b-a|}{\\varepsilon} \\right).\n\\end{equation}\\]\nRounding the value of \\(n\\) up to the nearest integer gives the number of iterations necessary to approximate the root to a precision less than \\(\\varepsilon\\).\n\n\nExercise 3.18 Is it possible for a given function and a given interval that the Bisection Method converges to the root in fewer steps than what you just found in the previous problem? Explain.\n\n\n\nExercise 3.19 Create a second version of your Python Bisection Method function that uses a for loop that takes the optimal number of steps to approximate the root to within some tolerance. This should be in contrast to your first version which likely used a while loop to decide when to stop. Is there an advantage to using one of these version of the Bisection Method over the other?\n\n\nThe final type of analysis that we should do on the bisection method is to make plots of the error between the approximate solution that the bisection method gives you and the exact solution to the equation. This is a bit of a funny thing! Stop and think about this for a second: if you know the exact solution to the equation then why are you solving it numerically in the first place!?!? However, whenever you build an algorithm you need to test it on problems where you actually do know the answer so that you can be somewhat sure that it is not giving you nonsense. Furthermore, analysis like this tells us how fast the algorithm is expected to perform.\nFrom Theorem 3.2 you know that the bisection method cuts the interval in half at every iteration. You proved in Exercise 3.17 that the error given by the bisection method is therefore cut in half at every iteration as well. The following example demonstrate this theorem graphically.\n\n\nExample 3.1 Let us solve the very simple equation \\(x^2 - 2 = 0\\) for \\(x\\) to get the solution \\(x = \\sqrt{2}\\) with the bisection method. Since we know the exact answer we can compare the exact answer to the value of the midpoint given at each iteration and calculate an absolute error: \\[\\begin{equation}\n\\text{Absolute Error} = | \\text{Approximate Solution} - \\text{Exact Solution}|.\n\\end{equation}\\]\nIf we plot the absolute error on the vertical axis and the iteration number on the horizontal axis we get Figure 3.3. As expected, the absolute error follows an exponentially decreasing trend. Notice that it is not a completely smooth curve since we will have some jumps in the accuracy just due to the fact that sometimes the root will be near the midpoint of the interval and sometimes it will not be.\n\n\nCode\nimport matplotlib.pyplot as plt\nfrom math import sqrt\n\ndef f(x):\n    return x**2 - 2\n\nx_exact = sqrt(2)\n\ndef bisection(a, b, tol):\n    errors = []\n    while (b - a) / 2.0 &gt; tol:\n        midpoint = (a + b) / 2.0\n        if f(midpoint) == 0:\n            break\n        elif f(a) * f(midpoint) &lt; 0:\n            b = midpoint\n        else:\n            a = midpoint\n        error = abs(midpoint - x_exact)\n        errors.append(error)\n    return errors\n\n# Using the interval [1, 2] and a tolerance of 1e-7\ntolerance = 1e-7\nerrors = bisection(1, 2, tolerance)\n\n# Creating the x values for the plot (iterations)\niterations = np.arange(len(errors))\n\n# Plotting the errors\nplt.scatter(iterations, errors, label='Error per Iteration')\n\nplt.xlabel('Iteration')\nplt.ylabel('Absolute Error')\nplt.title('Absolute Error in Each Iteration of the Bisection Method')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 3.3: The evolution of the absolute error when solving the equation \\(x^2-2=0\\) with the bisection method.\n\n\n\n\n\nWithout Theorem 3.2 it would be rather hard to tell what the exact behaviour is in the exponential plot above. We know from Theorem 3.2 that the error will divide by 2 at every step, so if we instead plot the base-2 logarithm of the absolute error against the iteration number we should see a linear trend as shown in Figure 3.4.\n\n\nCode\nimport matplotlib.pyplot as plt\nfrom math import sqrt\nfrom scipy.stats import linregress\n\ndef f(x):\n    return x**2 - 2\n\nx_exact = sqrt(2)\n\ndef bisection(a, b, tol):\n    errors = []\n    while (b - a) / 2.0 &gt; tol:\n        midpoint = (a + b) / 2.0\n        if f(midpoint) == 0:\n            break\n        elif f(a) * f(midpoint) &lt; 0:\n            b = midpoint\n        else:\n            a = midpoint\n        error = abs(midpoint - x_exact)\n        errors.append(error)\n    return errors\n\n# Using the interval [1, 2] and a tolerance of 1e-7\ntolerance = 1e-7\nerrors = bisection(1, 2, tolerance)\n\n# Convert errors to base 2 logarithm\nlog_errors = np.log2(errors)\n# Creating the x values for the plot (iterations)\niterations = np.arange(len(log_errors))\n\n# Plotting the errors\nplt.scatter(iterations, log_errors, label='Log Error per Iteration')\n\n# Determine slope and intercept of the best-fit straight line\nslope, intercept = np.polyfit(iterations, log_errors, deg=1)\nbest_fit_line = slope * iterations + intercept\n# Plot the best-fit line\nplt.plot(iterations, best_fit_line, label='Best Fit Line', color='red')\n\nplt.xlabel('Iteration')\nplt.ylabel('Base 2 Log of Absolute Error')\nplt.title('Absolute Error in Each Iteration of the Bisection Method')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 3.4: Iteration number vs the base-2 logarithm of the absolute error. Notice the slope of \\(-1\\) indicating that the error is divided by 1 factor of 2 at each step of the algorithm.\n\n\n\n\n\nThere will be times later in this course where we will not have a nice theorem like Theorem 3.2 and instead we will need to deduce the relationship from plots like these.\n\nThe trend is linear since logarithms and exponential functions are inverses. Hence, applying a logarithm to an exponential will give a linear function.\nThe slope of the resulting linear function should be \\(-1\\) in this case since we are dividing by 1 power of 2 each iteration. Visually verify that the slope in the plot below follows this trend (the red dashed line in the plot is shown to help you see the slope).\n\n\n\n\nExercise 3.20 Carefully read and discuss all of the details of the previous example and plots. Then create plots similar to this example to solve a different equation to which you know the exact solution. You should see the same basic behaviour based on the theorem that you proved in Exercise 3.17. If you do not see the same basic behaviour then something has gone wrong.\n\n\n\nExample 3.2 Another plot that numerical analysts use quite frequently for determining how an algorithm is behaving as it progresses is shown in Figure 3.5. and is defined by the following axes:\n\nThe horizontal axis is the absolute error at iteration \\(k\\).\nThe vertical axis is the absolute error at iteration \\(k+1\\).\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Redefining the functions as the execution environment has been reset\ndef f(x):\n    return x**2 - 2\n\ndef bisection(a, b, tol):\n    errors = []\n    while (b - a) / 2.0 &gt; tol:\n        midpoint = (a + b) / 2.0\n        if f(midpoint) == 0:\n            break\n        elif f(a) * f(midpoint) &lt; 0:\n            b = midpoint\n        else:\n            a = midpoint\n        error = abs(f(midpoint))\n        errors.append(error)\n    return errors\n\n# Running the bisection method again\ntolerance = 1e-7\nerrors = bisection(1, 2, tolerance)\n\n# Calculating the log2 of the absolute error at step k and k+1\nlog_errors = np.log2(errors)\nlog_errors_k = log_errors[:-1]  # log errors at step k (excluding the last one)\nlog_errors_k_plus_1 = log_errors[1:]  # log errors at step k+1 (excluding the first one)\n\n# Plotting log_errors_k+1 vs log_errors_k\nplt.scatter(log_errors_k, log_errors_k_plus_1, label='Log Error at k+1 vs Log Error at k')\n\n# Fitting a straight line to the data points\nslope, intercept = np.polyfit(log_errors_k, log_errors_k_plus_1, deg=1)\nbest_fit_line = slope * log_errors_k + intercept\nplt.plot(log_errors_k, best_fit_line, color='red', label='Best Fit Line')\n\n# Setting up the plot\nplt.xlabel('Log2 of Absolute Error at Step k')\nplt.ylabel('Log2 of Absolute Error at Step k+1')\nplt.title('Log2 of Absolute Error at Step k+1 vs Step k')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 3.5: The base-2 logarithm of the absolute error at iteration \\(k\\) vs the base-2 logarithm of the absolute error at iteration \\(k+1\\).\n\n\n\n\n\nThis type of plot takes a bit of explaining the first time you see it. Start on the right-hand side of the plot where the error is the largest (this will be where the algorithm starts). The coordinates of the first point are interpreted as: \\[\\begin{equation}\n(\\text{absolute error at step 1} \\, , \\, \\text{absolute error at step 2}).\n\\end{equation}\\] The coordinates of the second point are interpreted as: \\[\\begin{equation}\n(\\text{absolute error at step 2} \\, , \\, \\text{absolute error at step 3}),\n\\end{equation}\\] etc. Examining the slope of the trend line in this plot shows how we expect the error to progress from step to step. The slope appears to be about \\(1\\) in Figure 3.5 and the intercept appears to be about \\(-1\\). In this case we used a base-2 logarithm for each axis so we have just empirically shown that \\[\\begin{equation}\n\\log_2(\\text{absolute error at step $k+1$}) \\approx 1\\cdot \\log_2(\\text{absolute error at step $k$}) -1.\n\\end{equation}\\] Rearranging the algebra a bit we see that this linear relationship turns into \\[\\begin{equation}\n\\frac{\\text{absolute error at step $k+1$}}{\\text{absolute error at step $k$}} \\approx \\frac{1}{2}.\n\\end{equation}\\] (You should stop now and do this algebra.) Rearranging a bit more we get \\[\\begin{equation}\n(\\text{absolute error at step $k+1$}) = \\frac{1}{2}(\\text{absolute error at step $k$}),\n\\end{equation}\\] exactly as expected!! Pause and ponder this result for a second – we just empirically verified the convergence rate for the bisection method just by examining Figure 3.5. That’s what makes these types of plots so powerful!\n\n\n\nExercise 3.21 Reproduce plots like those in the previous example but for the different equation that you used in Exercise 3.20. Again check that the plots have the expected shape.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algebra</span>"
    ]
  },
  {
    "objectID": "nmAlgebra.html#sec-fixedpoint1d",
    "href": "nmAlgebra.html#sec-fixedpoint1d",
    "title": "3  Algebra",
    "section": "3.3 Fixed point iteration",
    "text": "3.3 Fixed point iteration\nWe will now investigate a different problem that is closely related to root finding: the fixed point problem. Given a function \\(g\\) (of one real argument with real values), we look for a number \\(p\\) such that \\[\ng(p)=p.\n\\] This \\(p\\) is called a fixed point of \\(g\\).\nAny root finding problem \\(f(x)=0\\) can be reformulated as a fixed point problem, and this can be done in many (in fact, infinitely many) ways. For example, given \\(f\\), we can define \\(g(x):=f(x) + x\\); then \\[\nf(x) = 0 \\quad \\Leftrightarrow\\quad g(x)=x.\n\\] Just as well, we could set \\(g(x):=\\lambda f(x) + x\\) with any \\(\\lambda\\in{\\mathbb R}\\backslash\\{0\\}\\), and there are many other possibilities.\nThe heuristic idea for approximating a fixed point of a function \\(g\\) is quite simple. We take an initial approximation \\(x_{0}\\) and calculate subsequent approximations using the formula \\[\nx_{n}:=g(x_{n-1}).\n\\] A graphical representation of this sequence when \\(g = \\cos\\) and \\(x_0=2\\) is shown in Figure 3.6.\nTo view the animation, click on the play button below the plot.\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\nFigure 3.6: Fixed point iteration \\(x_{n} = \\cos(x_{n-1})\\).\n\n\n\n\n\n\nExercise 3.22 The plot that emerges in Figure 3.6 is known as a cobweb diagram, for obvious reason. Explain to others in your group what is happening in the animation in Figure 3.6 and how that animation is related to the fixed point iteration \\(x_{n} = \\cos(x_{n-1})\\).\n\n\n\nExercise 3.23 The animation in Figure 3.6 is a graphical representation of the fixed point iteration \\(x_{n} = \\cos(x_{n-1})\\). Use Python to calculate the first 10 iterations of this sequence with \\(x_0=2\\). Use that to get an estimate of the solution to the equation \\(\\cos(x)-x=0\\).\n\n\nWhy is the sequence \\((x_n)\\) expected to approximate a fixed point? Suppose for a moment that the sequence \\((x_n)\\) converges to some number \\(p\\), and that \\(g\\) is continuous. Then \\[\np=\\lim_{n\\to\\infty}x_{n}=\\lim_{n\\to\\infty}g(x_{n-1})=\ng\\left(\\lim_{n\\to\\infty}x_{n-1}\\right)=g(p).\n\\tag{3.1}\\] Thus, if the sequence converges, then it converges to a fixed point. However, this resolves the problem only partially. One would like to know:\n\nUnder what conditions does the sequence \\((x_n)\\) converge?\nHow fast is the convergence, i.e., can one obtain an estimate for the approximation error?\n\nSo there is much for you to investigate!\n\n\nExercise 3.24 Copy the two plots in Figure 3.7 to a piece of paper and draw the first few iterations of the fixed point iteration \\(x_{n} = g(x_{n-1})\\) on each of them. In the first plot start with \\(x_0=0.2\\) and in the second plot start with \\(x_0=1.5\\) and in the second plot start with $x=0.9 What do you observe about the convergence of the sequence in each case?\n\n\n\n\n\n\n\n\nFigure 3.7: Two plots for practicing your cobweb skills.\n\n\n\n\n\nCan you make some conjectures about when the sequence \\((x_n)\\) will converge to a fixed point and when it will not?\n\n\n\nExercise 3.25 Make similar plots as in the previous exercise but with different slopes of the blue line. Can you make some conjectures about how the speed of convergence is related to the slope of the blue line?\n\n\nNow see if your observations are in agreement with the following theorem:\n\nTheorem 3.3 (Fixed Point Theorem) Suppose that \\(g:[a,b]\\to [a,b]\\) is differentiable, and that there exists \\(0&lt;k&lt;1\\) such that \\[\n\\lvert g^{\\prime}(x)\\rvert\\leq k\\quad \\text{for all }x \\in (a,b).\n\\tag{3.2}\\] Then, \\(g\\) has a unique fixed point \\(p\\in [a,b]\\); and for any choice of \\(x_0 \\in [a,b]\\), the sequence defined by \\[\nx_{n}:=g(x_{n-1}) \\quad \\text{for all }n\\ge1\n\\tag{3.3}\\] converges to \\(p\\). The following estimate holds: \\[\n\\lvert p- x_{n}\\rvert \\leq k^n \\lvert p-x_{0}\\rvert \\quad \\text{for all }n\\geq1.\n\\tag{3.4}\\]\n\n\nProof. The proof of this theorem is not difficult, but you can skip it and go directly to Exercise 3.26 if you feel that the theorem makes intuitive sense and you are not interested in proofs.\nWe first show that \\(g\\) has a fixed point \\(p\\) in \\([a,b]\\). If \\(g(a)=a\\) or \\(g(b)=b\\) then \\(g\\) has a fixed point at an endpoint. If not, then it must be true that \\(g(a)&gt;a\\) and \\(g(b)&lt;b\\). This means that the function \\(h(x):=g(x)-x\\) satisfies \\[\n\\begin{aligned}\nh(a) &= g(a)-a&gt;0, & h(b)&=g(b)-b&lt;0\n\\end{aligned}\n\\] and since \\(h\\) is continuous on \\([a,b]\\) the Intermediate Value Theorem guarantees the existence of \\(p\\in(a,b)\\) for which \\(h(p)=0\\), equivalently \\(g(p)=p\\), so that \\(p\\) is a fixed point of \\(g\\).\nTo show that the fixed point is unique, suppose that \\(q\\neq p\\) is a fixed point of \\(g\\) in \\([a,b]\\). The Mean Value Theorem implies the existence of a number \\(\\xi\\in(\\min\\{p,q\\},\\max\\{p,q\\})\\subseteq(a,b)\\) such that \\[\n\\frac{g(p)-g(q)}{p-q}=g'(\\xi).\n\\] Then \\[\n\\lvert p - q\\rvert = \\lvert g(p)-g(q) \\rvert = \\lvert (p-q)g'(\\xi) \\rvert = \\lvert p-q\\rvert \\lvert g'(\\xi) \\rvert \\le  k\\lvert p-q\\rvert &lt; \\lvert p-q\\rvert,\n\\] where the inequalities follow from Eq. 3.2. This is a contradiction, which must have come from the assumption \\(p\\neq q\\). Thus \\(p=q\\) and the fixed point is unique.\nSince \\(g\\) maps \\([a,b]\\) onto itself, the sequence \\(\\{x_n\\}\\) is well defined. For each \\(n\\ge0\\) the Mean Value Theorem gives the existence of a \\(\\xi\\in(\\min\\{x_n,p\\},\\max\\{x_n,p\\})\\subseteq(a,b)\\) such that \\[\n\\frac{g(x_n)-g(p)}{x_n-p}=g'(\\xi).\n\\] Thus for each \\(n\\ge1\\) by Eq. 3.2, Eq. 3.3 \\[\n\\lvert x_n-p\\rvert = \\lvert g(x_{n-1})-g(p) \\rvert = \\lvert (x_{n-1}-p)g'(\\xi) \\rvert = \\lvert x_{n-1}-p\\rvert \\lvert g'(\\xi) \\rvert \\le  k\\lvert x_{n-1}-p\\rvert.\n\\] Applying this inequality inductively, we obtain the error estimate Eq. 3.4. Moreover since \\(k &lt;1\\) we have \\[\\lim_{n\\rightarrow\\infty}\\lvert x_{n}-p\\rvert \\le \\lim_{n\\rightarrow\\infty} k^n \\lvert x_{0}-p\\rvert = 0,\n\\] which implies that \\((x_n)\\) converges to \\(p\\).  ◻\n\n\n\nExercise 3.26 This exercise shows why the conditions of the Theorem 3.3 are important.\nThe equation \\[\nf(x)=x^{2}-2=0\n\\] has a unique root \\(\\sqrt{2}\\) in \\([1, 2]\\). There are many ways of writing this equation in the form \\(x=g(x)\\); we consider two of them: \\[\n\\begin{aligned}\nx&=g(x)=x-(x^{2}-2), &\n  x&=h(x)=x-\\frac{x^{2}-2}{3}.\n\\end{aligned}\n\\] Calculate the first terms in the sequences generated by the fixed point iteration procedures \\(x_{n}=g(x_{n-1})\\) and \\(x_{n}=h(x_{n-1})\\) with start value \\(x_0=1\\). Which of these fixed point problems generate a rapidly converging sequence? Calculate the derivatives of \\(g\\) and \\(h\\) and check if the conditions of the fixed point theorem are satisfied.\n\nThe previous exercise illustrates that one needs to be careful in rewriting root finding problems as fixed point problems—there are many ways to do so, but not all lead to a good approximation. In the next section about Newton’s method we will discover a very good choice.\nNote at this point that Theorem 3.3 gives only sufficient conditions for convergence; in practice, convergence might occur even if the conditions are violated.\n\n\nExercise 3.27 In this exercise you will write a Python function to implement the fixed point iteration algorithm.\nFor implementing the fixed point method as a computer algorithm, there’s one more complication to be taken into account: how many steps of the iteration should be taken, i.e., how large should \\(n\\) be chosen, in order to reach the desired precision? The error estimate in Eq. 3.4 is often difficult to use for this purpose because it involves estimates on the derivative of \\(g\\) which may not be known.\nInstead, one uses a different stopping condition for the algorithm. Since the sequence is expected to converge rapidly, one uses the difference \\(|x_n-x_{n-1}|\\) to measure the precision reached. If this difference is below a specified limit, say \\(\\tau\\), the iteration is stopped. Since it is possible that the iteration does not converge—see the example above—one would also stop the iteration (with an error message) if a certain number of steps is exceeded, in order to avoid infinite loops. In pseudocode the fixed point iteration algorithm is then implemented as follows:\n\nFixed point iteration\n\n\\[\n\\begin{array}{ll}\n\\ 1: \\ \\textbf{function} \\ FixedPoint(g,x_0,\\tau, N) &\\sharp \\ function \\ g, \\ start \\ point \\ x_0,\\\\\n\\ 2: \\ \\quad x \\gets x_0; \\ n \\gets 0               &\\sharp \\ tolerance \\ \\tau, \\ max. \\ num. \\ of \\\\\n\\ 3: \\ \\quad \\textbf{loop}                          &\\sharp \\ iterations \\ N \\\\\n\\ 4: \\ \\quad\\quad y \\gets x; \\ x \\gets g(x)  & \\\\\n\\ 5: \\ \\quad\\quad \\textbf{if} \\ |y-x| &lt; \\tau \\ \\textbf{then}  &\\sharp \\ Desired \\ tolerance \\ reached  \\\\\n\\ 6: \\ \\quad\\quad\\quad \\textbf{break}  & \\\\\n\\ 7: \\ \\quad\\quad \\textbf{end \\ if}  &  \\\\\n\\ 8: \\ \\quad\\quad \\quad n\\gets n+1  & \\\\\n\\ 9: \\ \\quad\\quad \\textbf{if} \\ n &gt; N \\ \\textbf{then}  &\\sharp \\ Max.~num. \\ of \\ iterations  \\\\\n10: \\ \\quad\\quad\\quad \\textbf{exception}(\"Iteration \\ does \\ not \\ converge\") &\\sharp \\ reached  \\\\\n11: \\ \\quad\\quad \\textbf{end if}  & \\\\\n12: \\ \\quad \\textbf{end loop}  & \\\\\n13: \\ \\quad \\textbf{return} \\ x  & \\\\\n14: \\ \\textbf{end function} &\n\\end{array}\n\\] Implement this algorithm in Python. Use it to approximate the fixed point of the function \\(g(x)=\\cos(x)\\) with start value \\(x_0=2\\) and tolerance \\(\\tau=10^{-8}\\).\n\n\nFurther reading: Section 2.2 of (Burden and Faires 2010).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algebra</span>"
    ]
  },
  {
    "objectID": "nmAlgebra.html#sec-newtons_method",
    "href": "nmAlgebra.html#sec-newtons_method",
    "title": "3  Algebra",
    "section": "3.4 Newton’s Method",
    "text": "3.4 Newton’s Method\nIn the Bisection Method 3.2 we had used only the sign of of the function at the guessed points. We will now investigate how we can use also the value and the slope (derivative) of the function to get a much improved method.\n\n3.4.1 Intuition and Implementation\nRoot finding is really the process of finding the \\(x\\)-intercept of the function. If the function is complicated (e.g. highly nonlinear or does not lend itself to traditional by-hand techniques) then we can approximate the \\(x\\)-intercept by creating a Taylor Series approximation of the function at a nearby point and then finding the \\(x\\)-intercept of that simpler Taylor Series. The simplest non-trivial Taylor Series is a linear function – a tangent line!\n\n\nExercise 3.28 A tangent line approximation to a function \\(f(x)\\) near a point \\(x_0\\) is \\[\\begin{equation}\ny = f(x_0) + f'(x_0) \\left( x - x_0 \\right).\n\\end{equation}\\] Set \\(y\\) to zero and solve for \\(x\\) to find the \\(x\\)-intercept of the tangent line. \\[\\begin{equation}\n\\text{$x$-intercept of tangent line is } x = \\underline{\\hspace{0.5in}}\n\\end{equation}\\]\n\n\nThe idea of approximating the function by its tangent line gives us an algorithm for approximating the root of a function:\n\nGiven a value of \\(x\\) that is a decent approximation of the root, draw a tangent line to \\(f(x)\\) at that point.\nFind where the tangent line intersects the \\(x\\) axis.\nUse this intersection as the new \\(x\\) value and repeat.\n\nThe first step has been shown for you in Figure 3.8. The tangent line to the function \\(f(x)\\) at the point \\((x_0, f(x_0))\\) is shown in red. The \\(x\\)-intercept of the tangent line is the new \\(x\\) value, \\(x_1\\). The process is then repeated with \\(x_1\\) as the new \\(x_0\\) and so on.\nThis algorithm is known as Newton’s Method. The method was originally proposed by Isaac Newton, and later modified by Joseph Raphson, for approximating roots of the equation \\(f(x)=0\\). The method is therefore also known as the Newton-Raphson method.\n\n\n\n\n\n\nFigure 3.8: Using successive tangent line approximations to find the root of a function\n\n\n\n\n\nExercise 3.29 If we had started not at \\(x_0\\) in Figure 3.8 but instead at the very end of the x-axis in that figure, what would have happened? Would this initial guess have worked to eventually approximate the root?\n\n\n\nExercise 3.30 Sketch some other function $f(x) with a root and choose an initial point \\(x_0\\) and graphically perform the Newton iteration a few times, similar to Figure 3.8. Does the algorithm appear to converge to the root in your example? Do you think that this will generally take more or fewer steps than the Bisection Method?\n\n\n\nExercise 3.31 Using your result from Exercise 3.28, write the formula for the \\(x\\)-intercept of the tangent line to \\(f(x)\\) at the point \\((x_0, f(x_0))\\). This is the formula for the next guess in Newton’s Method. Newton’s method is a fixed point iteration method with the formula \\[\nx_{n} = x_{n-1} - \\dots.\n\\] Fill in the blank in the above formula.\n\n\n\nExercise 3.32 Apply Newton’s method to find the root of the function \\(f(x) = x^2 - 2\\) with an initial guess of \\(x_0=1\\). Calculate the first two iterations of the sequence by hand (you do not need a calculator or computer for this). Use a calculator or computer to calculate the next two iterations and fill in the following table:\n\n\n\n\n\n\n\n\n\n\\(n\\)\n\\(x_n\\)\n\\(f(x_n)\\)\n\\(f'(x_n)\\)\n\n\n\n\n\\(0\\)\n\\(x_0 = 1\\)\n\\(f(x_0) = -1\\)\n\\(f'(x_0) = 2\\)\n\n\n\\(1\\)\n\\(x_1 = 1 - \\frac{-1}{2} = \\frac{3}{2}\\)\n\\(f(x_1) =\\)\n\\(f'(x_1) =\\)\n\n\n\\(2\\)\n\\(x_2 =\\)\n\\(f(x_2) =\\)\n\\(f'(x_2) =\\)\n\n\n\\(3\\)\n\\(x_3 =\\)\n\\(f(x_3) =\\)\n\\(f'(x_3) =\\)\n\n\n\\(4\\)\n\\(x_4 =\\)\n\n\n\n\n\n\n\n\nExercise 3.33 Repeat the previous exercise but with an initial guess of \\(x_0=4\\). What do you observe.\n\n\n\nExercise 3.34 Make a complete list of what you must know about the function \\(f(x)\\) for Newton’s method to work?\n\n\n\nExercise 3.35 Create a Python function called newton() and write comments giving pseudo-code for Newton’s method. Your function needs to accept a Python function for \\(f(x)\\), a Python function for \\(f'(x)\\), an initial guess, and an optional error tolerance. You do not need to set aside any code for calculating the derivative.\n\n\n\nExercise 3.36 Using your pseudocode from the previous problem, write the full newton() function. The only output should be the solution to the equation that you are solving. Write a test script to verify that your Newton’s method code indeed works.\n\n\n\n\n3.4.2 Analysis\nThere are several ways in which Newton’s Method will behave unexpectedly – or downright fail. Some of these issues can be foreseen by examining the Newton iteration formula \\[\\begin{equation}\nx_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}.\n\\end{equation}\\] Some of the failures that we will see are a little more surprising. Also in this section we will look at the convergence rate of Newton’s Method and we will show that we can greatly outperform the Bisection method.\n\n\nExercise 3.37 There are several reasons why Newton’s method could fail. Work with your partners to come up with a list of reasons. Support each of your reasons with a sketch or an example.\n\n\n\nExercise 3.38 One of the failures of Newton’s Method is that it requires a division by \\(f'(x_n)\\). If \\(f'(x_n)\\) is zero then the algorithm completely fails. Go back to your Python function and put an if statement in the function that catches instances when Newton’s Method fails in this way.\n\n\n\nExercise 3.39 An interesting failure can occur with Newton’s Method that you might not initially expect. Consider the function \\(f(x) = x^3 - 2x + 2\\). This function has a root near \\(x=-1.77\\). Fill in the table below and draw the tangent lines on the figure for approximating the solution to \\(f(x) = 0\\) with a starting point of \\(x=0\\).\n\n\n\n\n\n\n\n\n\n\\(n\\)\n\\(x_n\\)\n\\(f(x_n)\\)\n\\(f'(x_n)\\)\n\n\n\n\n\\(0\\)\n\\(x_0 = 0\\)\n\\(f(x_0) = 2\\)\n\\(f'(x_0) = -2\\)\n\n\n\\(1\\)\n\\(x_1 = 0 - \\frac{f(x_0)}{f'(x_0)} = 1\\)\n\\(f(x_1) = 1\\)\n\\(f'(x_1) = 1\\)\n\n\n\\(2\\)\n\\(x_2 = 1 - \\frac{f(x_1)}{f'(x_1)} =\\)\n\\(f(x_2) =\\)\n\\(f'(x_2) =\\)\n\n\n\\(3\\)\n\\(x_3 =\\)\n\\(f(x_3) =\\)\n\\(f'(x_3) =\\)\n\n\n\\(4\\)\n\\(x_4 =\\)\n\\(f(x_4) =\\)\n\\(f'(x_4) =\\)\n\n\n\\(\\vdots\\)\n\\(\\vdots\\)\n\\(\\vdots\\)\n\\(\\vdots\\)\n\n\n\n\n\n\n\n\n\nFigure 3.9: An interesting Newton’s Method failure.\n\n\n\n\n\n\nExercise 3.40 Now let us consider the function \\(f(x) = \\sqrt[3]{x}\\). This function has a root \\(x=0\\). Furthermore, it is differentiable everywhere except at \\(x=0\\) since \\[\\begin{equation}\nf'(x) = \\frac{1}{3} x^{-2/3} = \\frac{1}{3x^{2/3}}.\n\\end{equation}\\] The point of this exercise is to show what can happen when the point of non-differentiability is precisely the point that you are looking for.\n\nFill in the table of iterations starting at \\(x=-1\\), draw the tangent lines on the plot, and make a general observation of what is happening with the Newton iterations.\n\n\n\n\n\n\n\n\n\n\n\\(n\\)\n\\(x_n\\)\n\\(f(x_n)\\)\n\\(f(x_n)\\)\n\n\n\n\n\\(0\\)\n\\(x_0 = -1\\)\n\\(f(x_0) = -1\\)\n\\(f'(x_0) =\\)\n\n\n\\(1\\)\n\\(x_1 = -1 - \\frac{f(-1)}{f'(-1)} =\\)\n\\(f(x_1) =\\)\n\\(f'(x_1) =\\)\n\n\n\\(2\\)\n\n\n\n\n\n\\(3\\)\n\n\n\n\n\n\\(4\\)\n\n\n\n\n\n\\(\\vdots\\)\n\\(\\vdots\\)\n\\(\\vdots\\)\n\\(\\vdots\\)\n\n\n\n\n\n\n\n\n\nFigure 3.10: Another surprising Newton’s Method failure.\n\n\n\n\nNow let us look at the Newton iteration in a bit more detail. Since \\(f(x) = x^{1/3}\\) and \\(f'(x) = \\frac{1}{3} x^{-2/3}\\) the Newton iteration can be simplified as \\[\\begin{equation}\nx_{n+1} = x_n - \\frac{x^{1/3}}{ \\left( \\frac{1}{3} x^{-2/3} \\right)} = x_n - 3 \\frac{x^{1/3}}{x^{-2/3}} = x_n - 3x_n = -2x_n.\n\\end{equation}\\] What does this tell us about the Newton iterations?\nHint: You should have found the exact same thing in the numerical experiment in part (a).\nWas there anything special about the starting point \\(x_0=-1\\)? Will this problem exist for every starting point?\n\n\n\n\nExercise 3.41 Repeat the previous exercise with the function \\(f(x) = x^3 - 5x\\) with the starting point \\(x_0 = -1\\).\n\n\n\n\n\n\nFigure 3.11: Another surprising Newton’s Method failure.\n\n\n\n\n\nNewton’s Method is known to have a quadratic convergence rate. This means that there is some constant \\(C\\) such that \\[\\begin{equation}\n|x_{k+1} - x_*| \\leq C |x_{k} - x_*|^2,\n\\end{equation}\\] where \\(x_*\\) is the root that we are hunting for.\nThe quadratic convergence implies that if we plot the error in the new iterate on the \\(y\\)-axis and the error in the old iterate on the \\(x\\) axis of a log-log plot then we will see a constant slope of 2. To see this we can take the log (base 10) of both sides of the previous equation to get \\[\\begin{equation}\n\\log(|x_{k+1} - x_*|) = \\log(C) + 2 \\log(|x_{k} - x_*|),\n\\end{equation}\\] and we see that this is a linear function (on a log-log plot) and the slope is 2. We created plots like this back in Example 3.2.\n\n\nExercise 3.42  \n\nPick an equation where you know the solution.\nCreate the error plot with \\(|x_{k} - x_*|\\) on the horizontal axis and \\(|x_{k+1} - x_*|\\) on the vertical axis. You can re-use some code from Example 3.2.\nDemonstrate that this plot has a slope of 2.\nGive a thorough explanation for how to interpret the plot that you just made.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algebra</span>"
    ]
  },
  {
    "objectID": "nmAlgebra.html#sec-secant_method",
    "href": "nmAlgebra.html#sec-secant_method",
    "title": "3  Algebra",
    "section": "3.5 The Secant Method",
    "text": "3.5 The Secant Method\n\n3.5.1 Intuition and Implementation\nNewton’s Method has second-order (quadratic) convergence and, as such, will perform faster than the Bisection method. However, Newton’s Method requires that you have a function and a derivative of that function. The conundrum here is that sometimes the derivative is cumbersome or impossible to obtain but you still want to have the great quadratic convergence exhibited by Newton’s method.\nRecall that Newton’s method is \\[\\begin{equation}\nx_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}.\n\\end{equation}\\] If we replace \\(f'(x_n)\\) with an approximation of the derivative then we may have a method that is close to Newton’s method in terms of convergence rate but is less troublesome to compute. Any method that replaces the derivative in Newton’s method with an approximation is called a Quasi-Newton Method.\nThe first, and most obvious, way to approximate the derivative is just to use the slope of a secant line instead of the slope of the tangent line in the Newton iteration. If we choose two starting points that are quite close to each other then the slope of the secant line through those points will be approximately the same as the slope of the tangent line.\n\n\nExercise 3.43 Use the backward difference \\[\\begin{equation}\nf'(x_n) \\approx \\frac{f(x_n) - f(x_{n-1})}{x_n - x_{n-1}}\n\\end{equation}\\] to approximate the derivative of \\(f\\) at \\(x_n\\).  Discuss why this approximates the derivative. Use this approximation of \\(f'(n)\\) in the expression for \\(x_{n+1}\\) of Newton’s method. Show that that the result simplifies to \\[\\begin{equation}\nx_{n+1} = x_n - \\frac{f(x_n)\\left( x_n - x_{n-1} \\right)}{f(x_n) - f(x_{n-1})}.\n\\end{equation}\\]\n\n\n\nExercise 3.44 Notice that the iteration formula for \\(x_{n+1}\\) that you derived depends on both \\(x_n\\) and \\(x_{n-1}\\). So to start the iteration you need to choose two points \\(x_0\\) and \\(x_1\\) before you can calculate \\(x_2, x_3, \\dots\\). Draw several pictures showing what the secant method does pictorially. Discuss whether it is important to choose these starting points close to the root and close to each other.\n\n\n\nExercise 3.45 Write pseudo-code to outline how you will implement the Secant Method.\n\n\n\nExercise 3.46 Write Python code for solving equations of the form \\(f(x) = 0\\) with the Secant method. Your function should accept a Python function, two starting points, and an optional error tolerance. Also write a test script that clearly shows that your code is working.\n\n\n\n\n3.5.2 Analysis\nUp to this point we have done analysis work on the Bisection Method and Newton’s Method. We have found that the methods are first order and second order respectively. We end this chapter by doing the same for the Secant Method.\n\n\nExercise 3.47 Choose a non-trivial equation for which you know the solution and write a script to empirically determine the convergence rate of the Secant method.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algebra</span>"
    ]
  },
  {
    "objectID": "nmAlgebra.html#algorithm-summaries",
    "href": "nmAlgebra.html#algorithm-summaries",
    "title": "3  Algebra",
    "section": "3.6 Algorithm Summaries",
    "text": "3.6 Algorithm Summaries\nThe following four problems are meant to have you re-build each of the algorithms that we developed in this chapter. Write all of the mathematical details completely and clearly. Do not just write “how” the method works, but give all of the mathematical details for “why” it works.\n\n\nExercise 3.48 Let \\(f(x)\\) be a continuous function on the interval \\([a,b]\\) where \\(f(a) \\cdot f(b) &lt; 0\\). Clearly give all of the mathematical details for how the Bisection Method approximates the root of the function \\(f(x)\\) in the interval \\([a,b]\\).\n\n\n\nExercise 3.49 Let \\(f(x)\\) be a differentiable function with a root near \\(x=x_0\\). Clearly give all of the mathematical details for how Newton’s Method approximates the root of the function \\(f(x)\\).\n\n\n\nExercise 3.50 Let \\(f(x)\\) be a continuous function with a root near \\(x=x_0\\). Clearly give all of the mathematical details for how the Secant Method approximates the root of the function \\(f(x)\\).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algebra</span>"
    ]
  },
  {
    "objectID": "nmAlgebra.html#problems",
    "href": "nmAlgebra.html#problems",
    "title": "3  Algebra",
    "section": "3.7 Problems",
    "text": "3.7 Problems\n\nExercise 3.51 Can the Bisection Method or Newton’s Method be used to find the roots of the function \\(f(x) = \\cos(x) + 1\\)? Explain why or why not for each technique?\n\n\n\nExercise 3.52 How many iterations of the bisection method are necessary to approximate \\(\\sqrt{3}\\) to within \\(10^{-3}\\), \\(10^{-4}\\), …, \\(10^{-15}\\) using the initial interval \\([a,b]=[0,2]\\)? See Theorem 3.2.\n\n\n\nExercise 3.53 Refer back to Example 3.1 and demonstrate that you get the same results for the order of convergence when solving the problem \\(x^3 - 3 = 0\\). Generate versions of all of the plots from that example and give thorough descriptions of what you learn from each plot.\n\n\n\nExercise 3.54 In this problem you will demonstrate that all of your root finding codes work. At the beginning of this chapter we proposed the equation solving problem \\[\\begin{equation}\n3\\sin(x) + 9 = x^2 - \\cos(x).\n\\end{equation}\\] Write a script that calls upon your Bisection, Newton, and Secant methods one at a time to find the positive solution to this equation. Your script needs to output the solutions in a clear and readable way so you can tell which answer came from which root finding algorithm.\n\n\n\nExercise 3.55 A root-finding method has a convergence rate of order \\(M\\) if there is a constant \\(C\\) such that \\[\\begin{equation}\n|x_{k+1} - x_*| \\leq C |x_k - x_*|^M.\n\\end{equation}\\] Here, \\(x_*\\) is the exact root, \\(x_k\\) is the \\(k^{th}\\) iteration of the root finding technique, and \\(x_{k+1}\\) is the \\((k+1)^{st}\\) iteration of the root finding technique.\n\nIf we consider the equation \\[\\begin{equation}\n|x_{k+1} - x_*| \\leq C |x_k - x_*|^M\n\\end{equation}\\] and take the logarithm (base 10) of both sides then we get \\[\\begin{equation}\n\\log\\left( |x_{k+1} - x_*| \\right) \\leq \\underline{\\hspace{1in}} + \\underline{\\hspace{1in}}\n\\end{equation}\\]\nIn part (a) you should have found that the log of new error is a linear function of the log of the old error. What is the slope of this linear function on a log-log plot?\nIn the plots below you will see six different log-log plots of the new error to the old error for different root finding techniques. What is the order of the approximate convergence rate for each of these methods?\n\n\n\n\n\n\n\nFigure 3.12: Six Error Plots\n\n\n\nFigure 2.12: Six Error Plots\n\nIn your own words, what does it mean for a root finding method to have a “first order convergence rate?” “Second order convergence rate?” etc.\n\n\n\n\nExercise 3.56 There are MANY other root finding techniques beyond the four that we have studied thus far. We can build these methods using Taylor Series as follows:\nNear \\(x=x_0\\) the function \\(f(x)\\) is approximated by the Taylor Series \\[\\begin{equation}\nf(x) \\approx y = f(x_0) + \\sum_{n=1}^N \\frac{f^{(n)}(x_0)}{n!} (x-x_0)^n\n\\end{equation}\\] where \\(N\\) is a positive integer. In a root-finding algorithm we set \\(y\\) to zero to find the root of the approximation function. The root of this function should be close to the actual root that we are looking for. Therefore, to find the next iterate we solve the equation \\[\\begin{equation}\n0 = f(x_0) + \\sum_{n=1}^N \\frac{f^{(n)}(x_0)}{n!} (x-x_0)^n\n\\end{equation}\\] for \\(x\\). For example, if \\(N=1\\) then we need to solve \\(0 = f(x_0) + f'(x_0)(x-x_0)\\) for \\(x\\). In doing so we get \\(x = x_0 - f(x_0)/f'(x_0)\\). This is exactly Newton’s method. If \\(N=2\\) then we need to solve \\[\\begin{equation}\n0 = f(x_0) + f'(x_0)(x-x_0) + \\frac{f''(x_0)}{2!}(x-x_0)^2\n\\end{equation}\\] for \\(x\\).\n\nSolve for \\(x\\) in the case that \\(N=2\\). Then write a Python function that implements this root-finding method.\nDemonstrate that your code from part (a) is indeed working by solving several problems where you know the exact solution.\nShow several plots that estimates the order of the method from part (a). That is, create a log-log plot of the successive errors for several different equation-solving problems.\nWhat are the pro’s and con’s to using this new method?\n\n\n\n\nExercise 3.57 (modified from (Burden and Faires 2010)) An object falling vertically through the air is subject to friction due to air resistance as well as gravity. The function describing the position of such a function is \\[\\begin{equation}\ns(t) = s_0 - \\frac{mg}{k} t + \\frac{m^2 g}{k^2}\\left( 1- e^{-kt/m} \\right),\n\\end{equation}\\] where \\(m\\) is the mass measured in kg, \\(g\\) is gravity measured in meters per second per second, \\(s_0\\) is the initial position measured in meters, and \\(k\\) is the coefficient of air resistance.\n\nWhat are the units of the parameter \\(k\\)?\nIf \\(m = 1\\)kg, \\(g=9.8\\)m/s\\(^2\\), \\(k=0.1\\), and \\(s_0 = 100\\)m how long will it take for the object to hit the ground? Find your answer to within 0.01 seconds.\nThe value of \\(k\\) depends on the aerodynamics of the object and might be challenging to measure. We want to perform a sensitivity analysis on your answer to part (b) subject to small measurement errors in \\(k\\). If the value of \\(k\\) is only known to within 10% then what are your estimates of when the object will hit the ground?\n\n\n\n\nExercise 3.58 In Single Variable Calculus you studied methods for finding local and global extrema of functions. You likely recall that part of the process is to set the first derivative to zero and to solve for the independent variable (remind yourself why you are doing this). The trouble with this process is that it may be very very challenging to solve by hand. This is a perfect place for Newton’s method or any other root finding technique!\nFind the local extrema for the function \\(f(x) = x^3(x-3)(x-6)^4\\) using numerical techniques where appropriate.\n\n\n\nExercise 3.59 (scipy.optimize.fsolve()) The scipy library in Python has many built-in numerical analysis routines much like the ones that we have built in this chapter. Of particular interest to the task of root finding is the fsolve command in the scipy.optimize library.\n\nGo to the help documentation for scipy.optimize.fsolve and make yourself familiar with how to use the tool.\nFirst solve the equation \\(x\\sin(x) - \\log(x) = 0\\) for \\(x\\) starting at \\(x_0 = 3\\).\n\nMake a plot of the function on the domain \\([0,5]\\) so you can eyeball the root before using the tool.\nUse the scipy.optimize.fsolve() command to approximate the root.\nFully explain each of the outputs from the scipy.optimize.fsolve() command. You should use the fsolve() command with full_output=1 so you can see all of the solver diagnostics.\n\nDemonstrate how to use fsolve() using any non-trivial nonlinear equation solving problem. Demonstrate what some of the options of fsolve() do.\nThe scipy.optimize.fsolve() command can also solve systems of equations (something we have not built algorithms for in this chapter). Consider the system of equations \\[\\begin{equation}\n\\begin{aligned} x_0 \\cos(x_1) &= 4 \\\\ x_0 x_1 - x_1 &= 5 \\end{aligned}\n\\end{equation}\\] The following Python code allows you to use scipy.optimize.fsolve() so solve this system of nonlinear equations in much the same way as we did in part (b) of this problem. However, be aware that we need to think of x as a vector of \\(x\\)-values. Go through the code below and be sure that you understand every line of code.\n\nimport numpy as np\nfrom scipy.optimize import fsolve\n\ndef F(x):\n return [x[0]*np.cos(x[1])-4, x[0]*x[1] - x[1] - 5]\n\nfsolve(F, [6,1], full_output=1) \n# Note: full_output=1 gives the solver diagnostics\n\nSolve the system of nonlinear equations below using .fsolve(). \\[\\begin{equation}\n\\begin{aligned} x^2-xy^2 &=2 \\\\ xy &= 2 \\end{aligned}\n\\end{equation}\\]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algebra</span>"
    ]
  },
  {
    "objectID": "nmAlgebra.html#projects",
    "href": "nmAlgebra.html#projects",
    "title": "3  Algebra",
    "section": "3.8 Projects",
    "text": "3.8 Projects\nAt the end of every chapter we propose a few projects related to the content in the preceding chapter(s). In this section we propose two ideas for a project related to numerical algebra. The projects in this book are meant to be open ended, to encourage creative mathematics, to push your coding skills, and to require you to write and communicate your mathematics.\n\n3.8.1 Basins of Attraction\nLet \\(f(x)\\) be a differentiable function with several roots. Given a starting \\(x\\) value we should be able to apply Newton’s Method to that starting point and we will converge to one of the roots (so long as you are not in one of the special cases discussed earlier in the chapter). It stands to reason that starting points near each other should all end up at the same root, and for some functions this is true. However, it is not true in general.\nA basin of attraction for a root is the set of \\(x\\) values that converges to that root under Newton iterations. In this problem you will produce coloured plots showing the basins of attraction for all of the following functions. Do this as follows:\n\nFind the actual roots of the function by hand (this should be easy on the functions below).\nAssign each of the roots a different colour.\nPick a starting point on the \\(x\\) axis and use it to start Newton’s Method.\nColour the starting point according to the root that it converges to.\nRepeat this process for many many starting points so you get a coloured picture of the \\(x\\) axis showing where the starting points converge to.\n\nThe set of points that are all the same colour are called the basin of attraction for the root associated with that colour. In Figure 3.13 there is an image of a sample basin of attraction image.\n\n\n\n\n\n\nFigure 3.13: A sample basin of attraction image for a cubic function.\n\n\n\n\nCreate a basin on attraction image for the function \\(f(x) = (x-4)(x+1)\\).\nCreate a basin on attraction image for the function \\(g(x) = (x-1)(x+3)\\).\nCreate a basin on attraction image for the function \\(h(x) = (x-4)(x-1)(x+3)\\).\nFind a non-trivial single-variable function of your own that has an interesting picture of the basins of attraction. In your write up explain why you thought that this was an interesting function in terms of the basins of attraction.\nNow for the fun part! Consider the function \\(f(z) = z^3 - 1\\) where \\(z\\) is a complex variable. That is, \\(z = x + iy\\) where \\(i = \\sqrt{-1}\\). From the Fundamental Theorem of Algebra we know that there are three roots to this polynomial in the complex plane. In fact, we know that the roots are \\(z_0 = 1\\), \\(z_1 = \\frac{1}{2}\\left( -1 + \\sqrt{3} i \\right)\\), and \\(z_2 = \\frac{1}{2} \\left( -1 - \\sqrt{3} i \\right)\\) (you should stop now and check that these three numbers are indeed roots of the polynomial \\(f(z)\\)). Your job is to build a picture of the basins of attraction for the three roots in the complex plane. This picture will naturally be two-dimensional since numbers in the complex plane are two dimensional (each has a real and an imaginary part). When you have your picture give a thorough write up of what you found.\nNow pick your favourite complex-valued function and build a picture of the basins of attraction. Consider this an art project! See if you can come up with the prettiest basin of attraction picture.\n\n\n\n3.8.2 Artillery\nAn artillery officer wishes to fire his cannon on an enemy brigade. He wants to know the angle to aim the cannon in order to strike the target. If we have control over the initial velocity of the cannon ball, \\(v_0\\), and the angle of the cannon above horizontal, \\(\\theta\\), then the initial vertical component of the velocity of the ball is \\(v_y(0) = v_0 \\sin(\\theta)\\) and the initial horizontal component of the velocity of the ball is \\(v_x(0) = v_0 \\cos(\\theta)\\). In this problem we will assume the following:\n\nWe will neglect air resistance1 so, for all time, the differential equations \\(v_y'(t) = -g\\) and \\(v_x'(t) = 0\\) must both hold.\nWe will assume that the position of the cannon is the origin of a coordinate system so \\(s_x(0) = 0\\) and \\(s_y(0) = 0\\).\nWe will assume that the target is at position \\((x_*,y_*)\\) which you can measure accurately relative to the cannon’s position. The landscape is relatively flat but \\(y_*\\) could be a bit higher or a bit lower than the cannon’s position.\n\nUse the given information to write a nonlinear equation2 that relates \\(x_*\\), \\(y_*\\), \\(v_0\\), \\(g\\), and \\(\\theta\\). We know that \\(g = 9.8m/s^2\\) is constant and we will assume that the initial velocity can be adjusted between \\(v_0 = 100m/s\\) and \\(v_0 = 150m/s\\) in increments of \\(10m/s\\). If we then are given a fixed value of \\(x_*\\) and \\(y_*\\) the only variable left to find in your equation is \\(\\theta\\). A numerical root-finding technique can then be applied to your equation to approximate the angle. Create several look up tables for the artillery officer so they can be given \\(v_0\\), \\(x_*\\), and \\(y_*\\) and then use your tables to look up the angle at which to set the cannon. Be sure to indicate when a target is out of range.\nWrite a brief technical report detailing your methods. Support your work with appropriate mathematics and plots. Include your tables at the end of your report.\n\n\n\n\nBurden, Richard L., and J. Douglas Faires. 2010. Numerical Analysis. 9th ed. Brooks Cole.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algebra</span>"
    ]
  },
  {
    "objectID": "nmAlgebra.html#footnotes",
    "href": "nmAlgebra.html#footnotes",
    "title": "3  Algebra",
    "section": "",
    "text": "Strictly speaking, neglecting air resistance is a poor assumption since a cannon ball moves fast enough that friction with the air plays a non-negligible role. However, the assumption of no air resistance greatly simplifies the maths and makes this version of the problem more tractable. The second version of the artillery problem in Chapter 6 will look at the effects of air resistance on the cannon ball.↩︎\nHint: Symbolically work out the amount of time that it takes until the vertical position of the cannon ball reaches \\(y_*\\). Then substitute that time into the horizontal position, and set the horizontal position equation to \\(x_*\\)↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algebra</span>"
    ]
  },
  {
    "objectID": "nmCalculus.html",
    "href": "nmCalculus.html",
    "title": "4  Calculus",
    "section": "",
    "text": "The calculus was the first achievement of modern mathematics and it is difficult to overestimate its importance.\n–Hungarian-American Mathematician John von Neumann\n\nComing in week 3.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Calculus</span>"
    ]
  },
  {
    "objectID": "nmLinAlg.html",
    "href": "nmLinAlg.html",
    "title": "5  Linear Algebra",
    "section": "",
    "text": "You cannot learn too much linear algebra.\n– Every mathematician\n\nComing in week 5.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Linear Algebra</span>"
    ]
  },
  {
    "objectID": "nmODE.html",
    "href": "nmODE.html",
    "title": "6  Ordinary Differential Equations",
    "section": "",
    "text": "The mathematical discipline of differential equations furnishes the explanation of all those elementary manifestations of nature which involve time.\n–Norwegian Mathematician Sophus Lie\n\nComing in week 7.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Ordinary Differential Equations</span>"
    ]
  },
  {
    "objectID": "nmPDE.html",
    "href": "nmPDE.html",
    "title": "7  Partial Differential Equations",
    "section": "",
    "text": "When you open the toolkit of differential equations you see the hammers and saws of engineering and physics for the past two centuries and for the foreseeable future.\n–Benoit Mandelbrot\n\nComing in week 9.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Partial Differential Equations</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Acton, Forman S. 1990. Numerical Methods That\nWork. 1St Edition edition. Washington, D.C: The\nMathematical Association of America.\n\n\nBurden, Richard L., and J. Douglas Faires. 2010. Numerical\nAnalysis. 9th ed. Brooks Cole.\n\n\nButcher, J. C. 2016. Numerical Methods for Ordinary Differential\nEquations. Third edition. Wiley. https://yorsearch.york.ac.uk/permalink/f/1kq3a7l/44YORK_ALMA_DS51336126850001381.\n\n\nGreenbaum, Anne, and Tim P. Chartier. 2012. Numerical Methods:\nDesign, Analysis, and Computer Implementation of Algorithms.\nPrinceton University Press.\n\n\nKincaid, D. R., and E. W. Cheney. 2009. Numerical\nAnalysis: Mathematics of\nScientific Computing. Pure and Applied\nUndergraduate Texts. American Mathematical Society.\n\n\nPress, William H., Saul A. Teukolsky, William T. Vetterling, and Brian\nP. Flannery. 2007. Numerical Recipes: The Art of Scientific\nComputing. Cambridge University Press. https://numerical.recipes/.\n\n\n“Project Euler.” n.d. Accessed December 14, 2023. https://projecteuler.net/.",
    "crumbs": [
      "References"
    ]
  }
]