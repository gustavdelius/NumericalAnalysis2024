<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Numerical Analysis - 8&nbsp; Some Theory</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./references.html" rel="next">
<link href="./nmPDE.html" rel="prev">
<link href="./faviconNA.webp" rel="icon">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="Numerical Analysis - 8&nbsp; Some Theory">
<meta property="og:description" content="">
<meta property="og:site_name" content="Numerical Analysis">
<meta name="twitter:title" content="Numerical Analysis - 8&nbsp; Some Theory">
<meta name="twitter:description" content="">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./theory.html"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Some Theory</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Numerical Analysis</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://maths.york.ac.uk/moodle/course/view.php?id=2652" title="Moodle page" class="quarto-navigation-tool px-1" aria-label="Moodle page"><i class="bi bi-mortarboard-fill"></i></a>
    <a href="https://forms.gle/Z8nYvVonGN98L7nv5" title="Submit a correction" class="quarto-navigation-tool px-1" aria-label="Submit a correction"><i class="bi bi-bug-fill"></i></a>
    <a href="https://github.com/gustavdelius/NumericalAnalysis2024/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="./Numerical-Analysis.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmPython.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Essential Python</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmApprox.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Approximations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmAlgebra.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Algebra</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmCalculus.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Calculus</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmOptimization.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Optimization</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmODE.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Ordinary Differential Equations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmPDE.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Partial Differential Equations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./theory.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Some Theory</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#sec-order" id="toc-sec-order" class="nav-link active" data-scroll-target="#sec-order"><span class="header-section-number">8.1</span> Order of Convergence of Iterative Methods</a>
  <ul>
  <li><a href="#linear-convergence" id="toc-linear-convergence" class="nav-link" data-scroll-target="#linear-convergence"><span class="header-section-number">8.1.1</span> Linear convergence</a></li>
  <li><a href="#quadratic-convergence" id="toc-quadratic-convergence" class="nav-link" data-scroll-target="#quadratic-convergence"><span class="header-section-number">8.1.2</span> Quadratic convergence</a></li>
  <li><a href="#p-th-order-of-convergence" id="toc-p-th-order-of-convergence" class="nav-link" data-scroll-target="#p-th-order-of-convergence"><span class="header-section-number">8.1.3</span> p-th order of convergence</a></li>
  </ul></li>
  <li><a href="#sec-truncation" id="toc-sec-truncation" class="nav-link" data-scroll-target="#sec-truncation"><span class="header-section-number">8.2</span> Truncation Errors</a></li>
  <li><a href="#sec-stiff" id="toc-sec-stiff" class="nav-link" data-scroll-target="#sec-stiff"><span class="header-section-number">8.3</span> Stiff Equations and Stability</a>
  <ul>
  <li><a href="#stiff-equations" id="toc-stiff-equations" class="nav-link" data-scroll-target="#stiff-equations"><span class="header-section-number">8.3.1</span> Stiff equations</a></li>
  <li><a href="#stability-of-solution-methods" id="toc-stability-of-solution-methods" class="nav-link" data-scroll-target="#stability-of-solution-methods"><span class="header-section-number">8.3.2</span> Stability of solution methods</a></li>
  <li><a href="#implicit-methods" id="toc-implicit-methods" class="nav-link" data-scroll-target="#implicit-methods"><span class="header-section-number">8.3.3</span> Implicit methods</a></li>
  </ul></li>
  <li><a href="#sec-stability-heat" id="toc-sec-stability-heat" class="nav-link" data-scroll-target="#sec-stability-heat"><span class="header-section-number">8.4</span> Stability of finite-difference methods for the heat equation</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/gustavdelius/NumericalAnalysis2024/edit/main/theory.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-theory" class="quarto-section-identifier"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Some Theory</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>In this module we have concentrated on experimentation and discovery, not so much on theoretical development. However there are some theoretical concepts that are so central to Numerical Analysis that they deserve to be presented in a more structured way. In this section we will introduce some of these concepts.</p>
<section id="sec-order" class="level2" data-number="8.1">
<h2 data-number="8.1" class="anchored" data-anchor-id="sec-order"><span class="header-section-number">8.1</span> Order of Convergence of Iterative Methods</h2>
<p>We have met several methods that used fixed-point iteration, in particular Newton’s method for finding roots and the gradient descent method for finding minima. In each case we made log-log plots of the absolute error at the (k+1)st iteration against the absolute error at the k-th iteration. From the slopes of the resulting graphs we were able to determine the order of convergence of the method.</p>
<p>The fixed point iteration takes the form <span id="eq-theory_fixed_point"><span class="math display">\[
x_{n+1}=g(n_k).
\tag{8.1}\]</span></span> When <span class="math inline">\(g\)</span> is suitably chosen, the method will converge to a fixed point <span class="math inline">\(x^*\)</span> of <span class="math inline">\(g\)</span> (such that <span class="math inline">\(g(x^*)=x^*\)</span>) and this fixed point is the desired solution to the problem.</p>
<p>The absolute error at step the n-th iteration is <span id="eq-theory_error"><span class="math display">\[
E_n=|x_n-x^*|.
\tag{8.2}\]</span></span> We are interested in how <span class="math inline">\(E_{n+1}\)</span> is related to <span class="math inline">\(E_n\)</span>. We use the following Taylor expansion of <span class="math inline">\(g\)</span> around <span class="math inline">\(x^*\)</span>: <span id="eq-theory_taylor"><span class="math display">\[\begin{split}
x_{n+1}=g(x_n)=g(x^*)&amp;+g'(x^*)(x_n-x^*)\\
&amp;+\frac{g''(x^*)}{2}(x_n-x^*)^2+\cdots\\
&amp;+\frac{g^{(p)}(\xi)}{p!}(x_n-x^*)^p
\end{split} \tag{8.3}\]</span></span> for some <span class="math inline">\(\xi\)</span> between <span class="math inline">\(x^*\)</span> and <span class="math inline">\(x_n\)</span>.</p>
<section id="linear-convergence" class="level3" data-number="8.1.1">
<h3 data-number="8.1.1" class="anchored" data-anchor-id="linear-convergence"><span class="header-section-number">8.1.1</span> Linear convergence</h3>
<p>In the case where <span class="math inline">\(g'(x^*)\neq 0\)</span>, this shows that <span id="eq-theory_linear"><span class="math display">\[
\begin{split}
E_{n+1}&amp;=|x_{n+1}-x^*|=|g'(x^*)||x_n-x^*|+\mathcal{O}(x_n-x^*)^2\\
&amp;=|g'(x^*)|E_n+\mathcal{O}(x_n-x^*)^2.
\end{split}
\tag{8.4}\]</span></span> So as <span class="math inline">\(x_n\to x^*\)</span>, <span id="eq-theory_linear_convergence"><span class="math display">\[
\frac{E_{n+1}}{E_n}\to |g'(x^*)|.
\tag{8.5}\]</span></span> The error decreases by a factor of <span class="math inline">\(|g'(x^*)|\)</span> at each iteration in the long run. If <span class="math inline">\(|g'(x^*)|&lt;1\)</span> then the method is said to have linear convergence or 1st order convergence.</p>
<div id="exm-gradient_descent_order" class="theorem example">
<p><span class="theorem-title"><strong>Example 8.1 (Order of convergence of gradient descent)</strong></span> For the gradient descent method we have <span id="eq-theory_gradient_descent"><span class="math display">\[
g(x)=x-\alpha f'(x),
\tag{8.6}\]</span></span> where <span class="math inline">\(\alpha\)</span> is the learning rate. The fixed point of this method is a minimum of <span class="math inline">\(f\)</span>. The derivative of <span class="math inline">\(g\)</span> is where <span class="math inline">\(\alpha\)</span> is the learning rate. So <span id="eq-theory_gradient_descent_derivative"><span class="math display">\[
g'(x)=1-\alpha f''(x).
\tag{8.7}\]</span></span> Because this is non-zero, the method is only first-order convergent. The learning rate <span class="math inline">\(\alpha\)</span> must be chosen carefully to ensure convergence.</p>
</div>
</section>
<section id="quadratic-convergence" class="level3" data-number="8.1.2">
<h3 data-number="8.1.2" class="anchored" data-anchor-id="quadratic-convergence"><span class="header-section-number">8.1.2</span> Quadratic convergence</h3>
<p>In the case where <span class="math inline">\(g'(x^*)=0\)</span> but <span class="math inline">\(g''(x^*)\neq 0\)</span>, we get from the Taylor expansion in <a href="#eq-theory_taylor" class="quarto-xref">Eq.&nbsp;<span>8.3</span></a> that <span class="math display">\[
\begin{split}
E_{n+1}&amp;=\frac{|g''(x^*)|}{2}|x_n-x^*|^2+\mathcal{O}(x_n-x^*)^3\\
&amp;=\frac{|g''(x^*)|}{2}E_n^2+\mathcal{O}(x_n-x^*)^3.
\end{split}
\]</span> So in the limit as <span class="math inline">\(x_n\to x^*\)</span>, <span class="math display">\[
\frac{E_{n+1}}{E_n^2}\to \frac{|g''(x^*)|}{2}.
\]</span></p>
<div id="exm-newton_order" class="theorem example">
<p><span class="theorem-title"><strong>Example 8.2 (Order of convergence of Newton’s method)</strong></span> For Newton’s method we have <span id="eq-theory_newton"><span class="math display">\[
g(x)=x-\frac{f(x)}{f'(x)}.
\tag{8.8}\]</span></span> The fixed point of this method is a root of <span class="math inline">\(f\)</span>. The derivative of <span class="math inline">\(g\)</span> is <span id="eq-theory_newton_derivative"><span class="math display">\[
g'(x)=1-\frac{f'(x)f'(x)-f(x)f''(x)}{f'(x)^2}=\frac{f(x)f''(x)}{f'(x)^2}.
\tag{8.9}\]</span></span> At the fixed point <span class="math inline">\(x^*\)</span> we have <span class="math inline">\(f(x^*)=0\)</span>, so <span class="math inline">\(g'(x^*)=0\)</span>. The second derivative of <span class="math inline">\(g\)</span> is <span id="eq-theory_newton_second_derivative"><span class="math display">\[
g''(x)=\frac{f(x)f'(x)f''(x)+f(x)^2f'''(x)-2f(x)f''(x)^2}{f'(x)^3}.
\tag{8.10}\]</span></span> This does generally not vanish at the fixed point. Therefore Newton’s method is second-order convergent.</p>
</div>
</section>
<section id="p-th-order-of-convergence" class="level3" data-number="8.1.3">
<h3 data-number="8.1.3" class="anchored" data-anchor-id="p-th-order-of-convergence"><span class="header-section-number">8.1.3</span> p-th order of convergence</h3>
<p>In general, if <span class="math inline">\(g'(x^*)=\cdots=g^{(p-1)}(x^*)=0\)</span> but <span class="math inline">\(g^{(p)}(x^*)\neq 0\)</span>, then the method is said to have p-th order convergence. The error at the n-th iteration is then <span class="math display">\[
E_{n+1}=\frac{|g^{(p)}(x^*)|}{p!}E_n^p+\mathcal{O}((x_n-x^*)^{p+1}).
\]</span> So in the limit as <span class="math inline">\(x_n\to x^*\)</span>, <span class="math display">\[
\frac{E_{n+1}}{E_n^p}\to \frac{|g^{(p)}(x^*)|}{p!}.
\]</span> Generally, if <span class="math display">\[
\lim_{n\to\infty}\frac{E_{n+1}}{E_n^p}=c
\]</span> for some constant <span class="math inline">\(c\)</span> then the method is said to have <strong>p-th order convergence</strong>.</p>
<p>To make the connection with our log-log error plots, we observe that <span class="math display">\[
\log E_{n+1}=\log\left(\frac{E_{n+1}}{E_n^p}\right)+p\log E_n.
\]</span> Because <span class="math inline">\(E_{n+1}/E_n^p\to c\)</span>, if the method has p-th order convergence, then the slope of the log-log plot of the error at the (n+1)st iteration against the error at the n-th iteration will be <span class="math inline">\(p\)</span> and the intercept will be <span class="math inline">\(\log c\)</span>.</p>
</section>
</section>
<section id="sec-truncation" class="level2" data-number="8.2">
<h2 data-number="8.2" class="anchored" data-anchor-id="sec-truncation"><span class="header-section-number">8.2</span> Truncation Errors</h2>
</section>
<section id="sec-stiff" class="level2" data-number="8.3">
<h2 data-number="8.3" class="anchored" data-anchor-id="sec-stiff"><span class="header-section-number">8.3</span> Stiff Equations and Stability</h2>
<section id="stiff-equations" class="level3" data-number="8.3.1">
<h3 data-number="8.3.1" class="anchored" data-anchor-id="stiff-equations"><span class="header-section-number">8.3.1</span> Stiff equations</h3>
<p>A differential equation is called “stiff” if the exact solution has a term that decays very rapidly. This is a problem for numerical methods because the step size must be very small to capture the rapid decay. This is a problem because the step size must be small for the entire solution, not just the rapidly decaying part. This can make the solution very slow to compute.</p>
<p>An example of such a rapidly decaying term would be a term of the form <span class="math inline">\(e^{-\gamma t}\)</span> with <span class="math inline">\(\gamma\)</span> large. As an example consider the ODE <span class="math display">\[
x'=-10x+\sin t.
\]</span> This is similar to equations we solved in <a href="nmODE.html" class="quarto-xref"><span>Chapter 6</span></a> just with a larger negative coefficient in front of <span class="math inline">\(x\)</span>. The solution to this equation is <span class="math display">\[
x(t)=Ce^{-100t}+\frac{100}{10001}\sin t-\frac{1}{10001}\cos t.
\]</span> The term <span class="math inline">\(e^{-100t}\)</span> decays very rapidly. We refer to such a term in the solution as a “transient” because it becomes irrelevant after a short time.</p>
</section>
<section id="stability-of-solution-methods" class="level3" data-number="8.3.2">
<h3 data-number="8.3.2" class="anchored" data-anchor-id="stability-of-solution-methods"><span class="header-section-number">8.3.2</span> Stability of solution methods</h3>
<p>To test the stability of a method we can apply it to a simple ODE with a known solution. We can then compare the numerical solution to the exact solution. If the numerical solution is stable, then it will converge to the exact solution as the step size goes to zero. If the numerical solution is unstable, then it will diverge from the exact solution as the step size goes to zero.</p>
<p>The test equation that is always used for this purpose of studying the stability of a numerical method is the linear ODE <span class="math display">\[
x'=\lambda x.
\]</span> The exact solution to this equation is <span class="math inline">\(x(t)=x_(0)_0e^{\lambda t}\)</span>. So for negative <span class="math inline">\(\lambda\)</span> the solution decays, and for positive <span class="math inline">\(\lambda\)</span> the solution grows. The stability of a numerical method can be tested by applying it to this equation and comparing the numerical solution to the exact solution.</p>
<div id="exm-euler_stability" class="theorem example">
<p><span class="theorem-title"><strong>Example 8.3 (Stability of Euler’s method)</strong></span> Euler’s method uses the formula <span class="math inline">\(x_{n+1}=x_n+h f(t_n,x_n)\)</span>. Applying this to the test equation <span class="math inline">\(x'=\lambda x\)</span> gives <span class="math display">\[
x_{n+1}=x_n+h\lambda x_n=(1+h\lambda)x_n.
\]</span> So <span class="math display">\[
x_{n+1}=(1+h\lambda)x_n=(1+h\lambda)^2x_{n-1}=\cdots=(1+h\lambda)^{n+1}x_0.
\]</span> Because we know the exact solution, we can calculate the absolute error that Euler’s method produces: <span class="math display">\[
E_n:=|x_n-x(t_n)|=|x_0(1+h\lambda)^n-x_0e^{\lambda t_n}|.
\]</span> In the case where <span class="math inline">\(\lambda&lt;0\)</span> we have that the exact solution decays to zero as <span class="math inline">\(n\to\infty\)</span>. So the error will be determined by the behaviour of the first term: <span class="math display">\[
\begin{split}
\lim_{n\to\infty}E_n&amp;=\lim_{n\to\infty}|x_0(1+h\lambda)^n|\\
&amp;=\begin{cases}
0&amp;\text{if }|1+h\lambda|&lt;1\\
\infty&amp;\text{if }|1+h\lambda|&gt;1.
\end{cases}
\end{split}
\]</span> The error grows exponentially unless <span class="math inline">\(|1+h\lambda|&lt;1\)</span>. This is the stability condition for Euler’s method. It requires us to choose a step size <span class="math display">\[
h&lt;\frac{2}{|\lambda|}
\]</span></p>
</div>
<p>In general, for a method that, when applied to the test equation <span class="math inline">\(x'=\lambda x\)</span>, gives <span class="math display">\[
x_{n+1}=Q(h\lambda)x_n
\]</span> the stability condition is that <span class="math display">\[|Q(h\lambda)|&lt;1.\]</span> Values of <span class="math inline">\(h\lambda =: z\)</span> for which <span class="math inline">\(|Q(z)|&lt;1\)</span> form the *Region of absolute stability** of the method. This is a region in the complex plane, because while the stepsize <span class="math inline">\(h\)</span> is of course always real, in applications the transient term may be oscillatory, corresponding to a complex <span class="math inline">\(\lambda\)</span>.</p>
<p>::: {#exm-midpoint_stability} #### Stability of the midpoint method The midpoint method uses the formula <span class="math display">\[
x_{n+1}=x_n+hf(t_n+\frac{h}{2},x_n+\frac{h}{2}f(t_n,x_n)).
\]</span> Applying this to the test equation <span class="math inline">\(x'=\lambda x\)</span> gives <span class="math display">\[
x_{n+1}=x_n+h\lambda \left(x_n+\frac{h}{2}\lambda x_n\right)
=x_n\left(1+h\lambda+\frac{(h\lambda)^2}{2}\right).
\]</span></p>
<p>The region of absolute stability is the set of <span class="math inline">\(z\in\mathbb{C}\)</span> for which <span class="math display">\[
\left|1+z+\frac{z^2}{2}\right|&lt;1.
\]</span></p>
</section>
<section id="implicit-methods" class="level3" data-number="8.3.3">
<h3 data-number="8.3.3" class="anchored" data-anchor-id="implicit-methods"><span class="header-section-number">8.3.3</span> Implicit methods</h3>
<p>Implicit methods tend to have a larger region of absolute stability, often including the entire left half plane, in which case they are called “unconditionally stable”. Such methods are of course particularly useful for stiff equations because they do not need a particular small step size to remain stable.</p>
<p>We demonstrate this in the case of the backward Euler method, which uses the formula <span class="math display">\[
x_{n+1}=x_n+hf(t_{n+1},x_{n+1}).
\]</span> Applying this to the test equation <span class="math inline">\(x'=\lambda x\)</span> gives <span class="math display">\[
x_{n+1}=x_n+h\lambda x_{n+1}.
\]</span> So <span class="math display">\[
x_{n+1}=\frac{x_n}{1-h\lambda}.
\]</span> The region of absolute stability is the set of <span class="math inline">\(z\in\mathbb{C}\)</span> for which <span class="math display">\[
\left|\frac{1}{1-z}\right|&lt;1,
\]</span> or, equivalently, <span class="math display">\[
|z-1|&gt;1.
\]</span> This is almost the entire complex plane, except for the circle of radius 1 around the point <span class="math inline">\(z=1\)</span>. In particular it contains the entire left half plane, so stiff equations do not require any particular choice of step size for the backward Euler method to be stable.</p>
</section>
</section>
<section id="sec-stability-heat" class="level2" data-number="8.4">
<h2 data-number="8.4" class="anchored" data-anchor-id="sec-stability-heat"><span class="header-section-number">8.4</span> Stability of finite-difference methods for the heat equation</h2>
<p>While exploring the explicit finite-difference method for solving the 1d heat equation, we encountered the stability condition <span class="math display">\[
a=\frac{D\Delta t}{(\Delta x)^2}\leq \frac{1}{2}.
\]</span> We now want to understand where this condition comes from.</p>
<p>We start by setting up the notation for solving the heat equation <span class="math inline">\(u_t=Du_xx\)</span> using the explicit finite-difference method. We discretize the spatial variable <span class="math inline">\(x\)</span> into <span class="math inline">\(N\)</span> points <span class="math inline">\(x_0,\ldots,x_N\)</span> with <span class="math inline">\(\Delta x=(x_N-x_0)/N\)</span>. We discretize the time variable <span class="math inline">\(t\)</span> into <span class="math inline">\(M\)</span> points <span class="math inline">\(t_0,\ldots,t_M\)</span> with <span class="math inline">\(\Delta t=(t_M-t_0)/M\)</span>. We denote the approximation of <span class="math inline">\(u(t_n,x_i)\)</span> by <span class="math inline">\(U_i^n\)</span>. The initial condition sets <span class="math inline">\(U_i^0=u(t_0,x_i)\)</span>. We work with homogeneous Dirichlet boundary conditions, so <span class="math inline">\(U_0^n=U_N^n=0\)</span> for all <span class="math inline">\(n\)</span>.</p>
<p>The approximations at the remaining points is then calculated by the formula <span class="math display">\[
U_i^{n+1}=U_i^n+a(U_{i+1}^n-2U_i^n+U_{i-1}^n)
\]</span> for <span class="math inline">\(i=1,\ldots,N-1\)</span>. You derived this in <a href="nmPDE.html#sec-heat1d" class="quarto-xref"><span>Section 7.2.1</span></a> using the finite-difference formulae for the derivatives from <a href="nmCalculus.html#sec-differentiation" class="quarto-xref"><span>Section 4.2</span></a>. We rewrite this in matrix notation: <span class="math display">\[
\begin{pmatrix}U_1^{n+1}\\\vdots\\U_{N-1}^{n+1}\end{pmatrix}=\begin{pmatrix}1-2a&amp;a&amp;&amp;\\
a&amp;1-2a&amp;a&amp;&amp;\\
&amp;\ddots&amp;\ddots&amp;\ddots&amp;\\
&amp;&amp;a&amp;1-2a\end{pmatrix}\begin{pmatrix}U_1^{n}\\\vdots\\U_{N-1}^{n}\end{pmatrix}.
\]</span> The matrix is tridiagonal, with <span class="math inline">\(1-2a\)</span> on the diagonal and <span class="math inline">\(a\)</span> on the two off-diagonals. We denote the matrix by <span class="math inline">\(A\)</span> and the two vectors by <span class="math inline">\(\mathbf{U}_{n+1}\)</span> and <span class="math inline">\(\mathbf{U}_{n}\)</span> respectively. So we have the formula <span class="math display">\[
\mathbf{U}_{n+1}=A\mathbf{U}_n.
\]</span> The solution at time <span class="math inline">\(t_n\)</span> is then given by <span class="math display">\[
\mathbf{U}_n=A^n\mathbf{U}_0.
\]</span></p>
<p>We want to understand how errors evolve over time. If errors grow exponentially over time then we call the method unstable and the method is not useful.</p>
<p>Let us assume that at some step, for convenience let us choose step <span class="math inline">\(0\)</span>, an error <span class="math inline">\(\mathbf{\epsilon}\)</span> is introduced: <span class="math display">\[
\tilde{\mathbf{U}}_0=\mathbf{U}_0+\mathbf{\epsilon}.
\]</span> Then after <span class="math inline">\(n\)</span> steps we have <span class="math display">\[
\tilde{\mathbf{U}}_n=A^n\tilde{\mathbf{U}}_0=A^n(\mathbf{U}_0+\mathbf{\epsilon})=A^n\mathbf{U}_0+A^n\mathbf{\epsilon}=\mathbf{U}_n+A^n\mathbf{\epsilon}.
\]</span> So the error at time <span class="math inline">\(t_n\)</span> is <span class="math display">\[
\mathbf{\epsilon}^n=A^n\mathbf{\epsilon}.
\]</span> To see if the error grows exponentially over time, we expand the initial error in terms of the eigenvectors of the matrix <span class="math inline">\(A\)</span>: <span class="math display">\[
\mathbf{\epsilon}=\sum_i\epsilon_i\mathbf{v}_i,
\]</span> where <span class="math display">\[
A\mathbf{v}_i=\lambda_i\mathbf{v}_i
\]</span> and the sum is over all eigenvectors <span class="math inline">\(\mathbf{v}_i\)</span> of <span class="math inline">\(A\)</span>. Then <span class="math display">\[
\mathbf{\epsilon}^n=\sum_i\epsilon_i\lambda_i^n\mathbf{v}_i.
\]</span> This shows that if all eigenvalues have absolute value less than 1, then the method is stable. If at least one eigenvalue has absolute value greater than 1, then the corresponding component of the error will grow exponentially with time and the method is unstable.</p>
<p>The eigenvalues of the matrix <span class="math inline">\(A\)</span> are the roots of the characteristic polynomial <span class="math display">\[
\det(A-\lambda I)=0.
\]</span></p>
<p>There is a nice method to determine the eigenvalues of the matrix <span class="math inline">\(A\)</span>, using Fourier analysis. We will not discuss this in this module and instead will just look at the simple example.</p>
<div id="exm-heat_stability" class="theorem example">
<p><span class="theorem-title"><strong>Example 8.4</strong></span> Consider the heat equation on the spatial domain <span class="math inline">\(x\in[0,1]\)</span> and divide this into three subintervals, so that our spatial grid consists of <span class="math inline">\(x_0=0,x_1=1/3,x_2=2/3\)</span> and <span class="math inline">\(x_3=1\)</span>. The matrix <span class="math inline">\(A\)</span> is then <span class="math display">\[
A=\begin{pmatrix}1-2a&amp;a&amp;\\
a&amp;1-2a
\end{pmatrix}.
\]</span> The characteristic polynomial is <span class="math display">\[
\begin{split}
\det(A-\lambda I)&amp;=\begin{vmatrix}1-2a-\lambda&amp;a\\
a&amp;1-2a-\lambda
\end{vmatrix}\\
&amp;=(1-2a-\lambda)^2-a^2\\
&amp;=\lambda^2-2(1-2a)\lambda+(1-2a)^2-a^2.
\end{split}
\]</span> The roots of this polynomial are <span class="math display">\[
\lambda_\pm=1-2a\pm a.
\]</span> We need both of these to have a magnitude less than 1 for the method to be stable. This gives us an upper bound on the allowd <span class="math inline">\(a\)</span>. The eigenvalue whose magnitude will increase above <span class="math inline">\(1\)</span> first as <span class="math inline">\(a\)</span> increases is <span class="math inline">\(\lambda_-=1-3a\)</span>, which has magnitude <span class="math inline">\(1\)</span> when <span class="math inline">\(a=2/3\)</span>. So the stability condition is <span class="math inline">\(a\leq 2/3\)</span>.</p>
<p>In case you are wondering why this does not agree with the stability condition <span class="math inline">\(a&lt;1/2\)</span> that we found experimentally in <a href="nmPDE.html#sec-heat1d" class="quarto-xref"><span>Section 7.2.1</span></a>, this is because as the dimension of the matrix <span class="math inline">\(A\)</span> increases, the eigenvalues move further away from the origin. This is a general feature of matrices, and is why the stability condition is more restrictive for larger matrices.</p>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./nmPDE.html" class="pagination-link  aria-label=" &lt;span="" differential="" equations&lt;="" span&gt;"="">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Partial Differential Equations</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./references.html" class="pagination-link" aria-label="References">
        <span class="nav-page-text">References</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/gustavdelius/NumericalAnalysis2024/edit/main/theory.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li></ul></div></div></div></footer></body></html>