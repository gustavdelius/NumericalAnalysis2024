<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Numerical Analysis - 5&nbsp; Optimization</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./nmODE.html" rel="next">
<link href="./nmCalculus.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="Numerical Analysis - 5&nbsp; Optimization">
<meta property="og:description" content="">
<meta property="og:site_name" content="Numerical Analysis">
<meta name="twitter:title" content="Numerical Analysis - 5&nbsp; Optimization">
<meta name="twitter:description" content="">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./nmOptimization.html"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Optimization</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Numerical Analysis</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://maths.york.ac.uk/moodle/course/view.php?id=2652" title="Moodle page" class="quarto-navigation-tool px-1" aria-label="Moodle page"><i class="bi bi-mortarboard-fill"></i></a>
    <a href="https://forms.gle/Z8nYvVonGN98L7nv5" title="Submit a correction" class="quarto-navigation-tool px-1" aria-label="Submit a correction"><i class="bi bi-bug-fill"></i></a>
    <a href="https://github.com/gustavdelius/NumericalAnalysis2024/" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="./Numerical-Analysis.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmPython.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Essential Python</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmApprox.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Approximations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmAlgebra.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Algebra</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmCalculus.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Calculus</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmOptimization.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Optimization</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmODE.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Ordinary Differential Equations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmPDE.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Partial Differential Equations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./nmLinAlg.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Linear Algebra</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#sec-1D-optimization" id="toc-sec-1D-optimization" class="nav-link active" data-scroll-target="#sec-1D-optimization"><span class="header-section-number">5.1</span> Single Variable Optimization</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/gustavdelius/NumericalAnalysis2024/edit/main/nmOptimization.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-optim" class="quarto-section-identifier"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Optimization</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<blockquote class="blockquote">
<p><em>It is not enough to do your best; you must know what to do, and then do your best.</em><br>
–<a href="https://en.wikipedia.org/wiki/W._Edwards_Deming">W. Edwards Deming</a></p>
</blockquote>
<p>In applied mathematics we are often not interested in all solutions of a problem but in the optimal solution. Optimization permeates many areas of mathematics and science. In this section we will look at a few examples of optimization problems and the numerical methods that can be used to solve them.</p>
<hr>
<div id="exr-3.48" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 5.1</strong></span> Here is an atypically easy optimisation problem that you can quickly do by hand:</p>
<p>A piece of cardboard measuring 20cm by 20cm is to be cut so that it can be folded into a box without a lid (see <a href="#fig-3.8" class="quarto-xref">Figure&nbsp;<span>5.1</span></a>). We want to find the size of the cut, <span class="math inline">\(x\)</span>, that maximizes the volume of the box.</p>
<ol type="1">
<li><p>Write a function for the volume of the box resulting from a cut of size <span class="math inline">\(x\)</span>. What is the domain of your function?</p></li>
<li><p>We know that we want to maximize this function so go through the full Calculus exercise to find the maximum:</p>
<ul>
<li><p>take the derivative</p></li>
<li><p>set it to zero</p></li>
<li><p>find the critical points</p></li>
<li><p>test the critical points and the boundaries of the domain using the extreme value theorem to determine the <span class="math inline">\(x\)</span> that gives the maximum.</p></li>
</ul></li>
</ol>
<div id="fig-3.8" class="quarto-figure quarto-figure-left quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-3.8-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/Optimization/CardboardBox.png" style="height:6cm" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-3.8-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.1: Folds to make a cardboard box
</figcaption>
</figure>
</div>
</div>
<hr>
<div class="{exm-3.49} page-columns page-full">
<p>In the previous exercise it was easy to find the maximum of the function by hand. However, in many cases it is not so easy. The equation that arises from setting the derivative to zero is often not solvable analytically. In these cases we need to use numerical methods to find the maximum. Take for example the function <span class="math display">\[f(x) = e^{-x^2} + \sin(x^2)\]</span> on the domain <span class="math inline">\(0 \le x \le 1.5\)</span>. This function is shown in <a href="#fig-opt-1" class="quarto-xref">Figure&nbsp;<span>5.2</span></a>.</p>
<div id="cell-fig-opt-1" class="cell page-columns page-full" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="fl">1.5</span>,<span class="dv">100</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> np.exp(<span class="op">-</span>x<span class="op">**</span><span class="dv">2</span>) <span class="op">+</span> np.sin(x<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'$x$'</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'$f(x)$'</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>plt.plot(x,f)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display page-columns page-full">
<div id="fig-opt-1" class="quarto-figure quarto-figure-left quarto-float anchored page-columns page-full" alt="Graph of example function">
<figure class="quarto-float quarto-float-fig figure page-columns page-full">
<div aria-describedby="fig-opt-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca" class="page-columns page-full">
<img src="nmOptimization_files/figure-html/fig-opt-1-output-1.png" alt="Graph of example function" width="598" height="431" class="figure-img column-page-right">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-opt-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.2: Graph of the function <span class="math inline">\(f(x) = e^{-x^2} + \sin(x^2)\)</span>.
</figcaption>
</figure>
</div>
</div>
</div>
<p>The maximum of this function can not be determined analytically but graphically we see that it is near <span class="math inline">\(x \approx 1.14\)</span>. We will use this function as a test case for our numerical optimization methods.</p>
</div>
<p>The intuition of numerical optimization schemes is typically to visualize the function that you are trying to minimize or maximize and think about either climbing the hill to the top (maximization) or descending the hill to the bottom (minimization).</p>
<hr>
<div id="exr-3.49" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 5.2</strong></span> If you were blind folded and standing on a hillside, could you find the top of the hill? (assume no trees and no cliffs …this is not supposed to be dangerous) How would you do it? Explain your technique clearly.</p>
</div>
<hr>
<div id="exr-3.50" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 5.3</strong></span> If you were blind folded and standing on a crater on the moon could you find the lowest point? How would you do it? Remember that you can hop as far as you like … because gravity … but sometimes that’s not a great thing because you could hop too far.</p>
</div>
<hr>
<section id="sec-1D-optimization" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="sec-1D-optimization"><span class="header-section-number">5.1</span> Single Variable Optimization</h2>
<p>The preceding thought exercises have given you intuition about finding optima in a two-dimensional landscape. But first we will reduce back to one-dimensional optimization problems before generalising to multiple dimensions in the next section.</p>
<div id="exr-3.51" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 5.4</strong></span> Try to turn your intuitions into algorithms. If <span class="math inline">\(f(x)\)</span> is the function that you are trying to maximize then turn your ideas from the previous exercises into step-by-step algorithms which could be coded. Then try out your codes on the function <span class="math display">\[\begin{equation}
f(x) = e^{-x^2} + \sin(x^2)
\end{equation}\]</span> to see if your algorithms can find the local maximum near <span class="math inline">\(x \approx 1.14\)</span>. Try to generate several different algorithms.</p>
</div>
<hr>
<!----

Some of the most common algorithms are listed below. Read through them and see which one(s) you ended up recreating.

### Optimization via Numerical Root Finding
Let $f(x)$ be the objective function which you are seeking to maximize (or minimize).

-   Find the derivative of your objective function.

-   Set the derivative to zero and use a numerical root finding method to find the critical point.

-   Use the extreme value theorem to determine if the critical point or one of the endpoints is the maximum (or minimum).

------------------------------------------------------------------------

::: {#exr-3.55}
 Write code to implement the 1D numerical root finding optimization algorithm and use it to solve @exr-3.48. Compare your answer to the analytic solution.
:::

------------------------------------------------------------------------

### Gradient Descent/Ascent

Let $f(x)$ be the objective function which you are seeking to minimize (or maximize).

-   Find the derivative of your objective function, $f'(x)$.

-   Pick a starting point, $x_0$.

-   Pick a small control parameter, $\alpha$ (in machine learning this parameter is called the "learning rate" for the gradient descent algorithm).

-   Use the iteration $x_{n+1} = x_n + \alpha f'(x_n)$ if you are maximizing. Use the iteration $x_{n+1} = x_n - \alpha f'(x_n)$ if you are minimizing.

-   Iterate (decide on a good stopping rule)



------------------------------------------------------------------------

::: {#exr-3.57}
What is the Gradient Ascent/Descent algorithm doing geometrically? Draw a picture and be prepared to explain to your peers.
:::

------------------------------------------------------------------------

::: {#exr-3.53}
 Write code to implement the 1D gradient descent algorithm and use it to solve @exr-3.48. Compare your answer to the analytic solution.

:::

------------------------------------------------------------------------

### Derivative Free Optimization
Let $f(x)$ be the objective function which you are seeking to maximize (or minimize).

-   Pick a starting point, $x_0$, and find the value of your objective function at this point, $f(x_0)$.

-   Pick a small step size (say, $\Delta x \approx 0.01$).

-   Calculate the objective function one step to the left and one step to the right from your starting point. Which ever point is larger (if you are seeking a maximum) is the point that you keep for your next step.

-   Iterate (decide on a good stopping rule)


------------------------------------------------------------------------

::: {#exr-3.52}
 Write code to implement the 1D derivative free optimization algorithm and use it to solve @exr-3.48. Compare your answer to the analytic solution.

:::

------------------------------------------------------------------------


### Brute Force Search
Let $f(x)$ be the objective function which you are seeking to maximize (or minimize).

-   Pick many (perhaps several thousand!) different $x$ values.

-   Find the value of the objective function at every one of these points (Hint: use lists, not loops)

-   Keep the $x$ value that has the largest (or smallest if you are minimizing) value of the objective function.



------------------------------------------------------------------------

::: {#exr-3.54}
 Write code to implement the 1D brute force search algorithm and use it to solve @exr-3.48. Compare your answer to the analytic solution.

:::

------------------------------------------------------------------------

::: {#exr-3.56}
 In this exercise we will compare an contrast the four methods proposed in the previous subsections.

1.  What are the advantages to each of the methods proposed?

2.  What are the disadvantages to each of the methods proposed?

3.  Which method, do you suppose, will be faster in general? Why?

4.  Which method, do you suppose, will be slower in general? Why?

:::

------------------------------------------------------------------------

::: {#exr-3.56b}
Try out your four algorithms to find the maximum of the function 
$$f(x) = (sin(4x)+1)(25-(x-5)^2)$$
on the domain $0 \le x \le 8$. What do you observe?

The above function has multiple local maxima. Can you come up with a method that works well for such functions?
:::

------------------------------------------------------------------------

## Multivariable Optimization

Now let us look at multi-variable optimization. The analytic process for finding optimal solutions is essentially the same as for single variable:

-   Write a function that models a scenario in multiple variables,

-   find the gradient vector (presuming that the function is differentiable),

-   set the gradient vector equal to the zero vector and solve for the critical point(s), and

-   interpret your answer in the context of the problem.

Let us see if you can extend your intuition from single variable to multivariable. This particular subsection is intentionally quite brief. If you want more details on multivariable optimization it would be wise to take a full course in optimization.

------------------------------------------------------------------------

::: {#exr-3.61}
 The derivative free optimization method discussed in the single variable optimization section just said that you should pick two points and pick the one that takes you furthest uphill.

1.  Why is it insufficient to choose just two points if we are dealing with a function of two variables? Hint: think about contour line.

2.  For a function of two variables, how many points should you use to compare and determine the direction of "uphill?"

3.  Extend your answer from part (2) to $n$ dimensions. How many points should we compare if we are in $n$ dimensions and need to determine which direction is "uphill?"

4.  Back in the case of a two-variable function, you should have decided that three points was best. Explain an algorithm for moving one point at a time so that your three points eventually converge to a nearby local maximum. It may be helpful to make a surface plot or a contour plot of a well-known function just as a visual.

The code below will demonstrate how to make a contour plot.

``` python         
import numpy as np
import matplotlib.pyplot as plt
xdomain = np.linspace(-4,4,100)
ydomain = np.linspace(-4,4,100)
X, Y = np.meshgrid(xdomain,ydomain)
f = lambda x, y: np.sin(x)*np.exp(-np.sqrt(x**2+y**2))
plt.contour(X,Y,f(X,Y))
plt.grid()
plt.show()
```

:::

------------------------------------------------------------------------

::: {#exr-3.62}
 Now let us tackle the gradient ascent/descent algorithm. You should recall that the gradient vector points in the direction of maximum change. How can you use this fact to modify the gradient ascent/descent algorithm given previously? Clearly write your algorithm so that a classmate could turn it into code.

:::

------------------------------------------------------------------------

::: {#exr-3.63}
 How does the Monte Carlo algorithm extend to a two-variable optimization problem? Clearly write your algorithm.

:::

------------------------------------------------------------------------

::: {#exr-3.64}
 Try out the gradient descent/ascent and Monte Carlo algorithms on the function $f(x,y) = \sin(x)\cos(y) + 0.1 x^2$ which has many local extrema and no global maximum. We are not going to code the multidimensional derivative free optimization routine in this section.

:::

------------------------------------------------------------------------

The derivative free, gradient ascent/descent, and Monte Carlo techniques still have good analogues in higher dimensions. We just need to be a bit careful since in higher dimensions there is much more room to move. Below we will give the full description of the gradient ascent/descent algorithm. We do not give the full description of the derivative free or Monte Carlo algorithms since there are many ways to implement them. The interested reader should see a course in mathematical optimization or machine learning.

------------------------------------------------------------------------

::: {#def-3.9}
### Gradient Descent Algorithm
We want to solve the problem 
\begin{equation}
\text{minimize } f(x_1, x_2, \ldots, x_n) \text{ subject to }(x_1, x_2, \ldots, x_n) \in S.
\end{equation}


1.  Choose an arbitrary starting point $\boldsymbol{x}_0 = (x_1,x_2,\ldots,x_n)\in S$.

2.  We are going to define a difference equation that gives successive guesses for the optimal value: 
\begin{equation}
\boldsymbol{x}_{n+1} = \boldsymbol{x}_n - \alpha \nabla f(\boldsymbol{x}_n).
\end{equation}
 The difference equation says to follow the negative gradient a certain distance from your present point (why are we doing this). Note that the value of $\alpha$ is up to you so experiment with a few values (you should probably take $\alpha \le 1$ ...why?).

3.  Repeat the iterative process in step b until two successive points are *close enough* to each other.

:::

------------------------------------------------------------------------

Take Note: If you are looking to maximize your objective function then in the Monte-Carlo search you should examine if $z$ is greater than your current largest value. For gradient descent you should actually do a gradient *ascent* instead and follow the positive gradient instead of the negative gradient.

------------------------------------------------------------------------

::: {#exr-3.65}
 The functions like $f(x,y) = \sin(x)\cos(y)$ have many local extreme values which makes optimization challenging. Implement your Gradient Descent code on this function to find the local minimum $(-\pi/2,0)$. Start somewhere near $(-\pi/2,0)$ and show by way of example that your gradient descent code may not converge to this particular local minimum. Why is this important?

:::

------------------------------------------------------------------------

## Optimization with `numpy` and `scipy`

As you have seen in this section there are many tools built into `numpy` and `scipy` that will do some of our basic numerical computations. The same is true for numerical optimization problems. Keep in mind throughout the remainder of this section that the whole topic of numerical optimization is still an active area of research and there is much more to the story that what we will see here. However, the Python tools that we will use are highly optimized and tend to work quite well.

------------------------------------------------------------------------

::: {#exr-3.77}
 Let us solve a very simple function minimization problem to get started. Consider the function $f(x) = (x-3)^2 - 5$. A moment's thought reveals that the global minimum of this parabolic function occurs at $(3,-5)$. We can have `scipy.optimize.minimize()` find this value for us numerically. The routine is much like Newton's Method in that we give it a starting point *near* where we think the optimum will be and it will iterate through some algorithm (like a derivative free optimization routine) to approximate the minimum.

``` python         
import numpy as np
from scipy.optimize import minimize
f = lambda x: (x-3)**2 - 5
minimize(f,2)
```

1.  Implement the code above then spend some time playing around with the minimize command to minimize more challenging functions.

2.  Explain what all of the output information is from the `.minimize()` command.

:::

------------------------------------------------------------------------

::: {#exr-3.78}
 There is not a function called `scipy.optimize.maximize()`. Instead, Python expects you to rewrite every maximization problem as a minimization problem. How do you do that?

:::

------------------------------------------------------------------------

::: {#exr-3.79}
 Solve @exr-3.48 using `scipy.optimize.minimize()`.

:::

------------------------------------------------------------------------

## Least Squares Curve Fitting

In this section we will change our focus a bit to look at a different question from algebra, and, in turn, reveal a hidden numerical optimization problem where the `scipy.optimize.minimize()` tool will come in quite handy.

Here is the primary question of interest:\
*If we have a few data points and a reasonable guess for the type of function fitting the points, how would we determine the actual function?*

You may recognize this as the basic question of regression from statistics. What we will do here is pose the statistical question of which curve best fits a data set as an optimization problem. Then we will use the tools that we have built so far to solve the optimization problem.

------------------------------------------------------------------------

::: {#exr-3.80}
 Consider the function $f(x)$ that goes exactly through the points $(0,1)$, $(1,4)$, and $(2,13)$.

1.  Find a function that goes through these points exactly. Be able to defend your work.

2.  Is your function unique? That is to say, is there another function out there that also goes exactly through these points?

:::

------------------------------------------------------------------------

::: {#exr-3.81}
 Now let us make a minor tweak to the previous exercise. Let us say that we have the data points $(0,1.07)$, $(1,3.9)$, $(2,14.8)$, and $(3,26.8)$. Notice that these points are *close* to the points we had in the previous exercise, but all of the $y$ values have a little noise in them and we have added a fourth point. If we suspect that a function $f(x)$ that *best* fits this data is quadratic then $f(x) = ax^2 + bx + c$ for some constants $a$, $b$, and $c$.

1.  Plot the four points along with the function $f(x)$ for arbitrarily chosen values of $a$, $b$, and $c$.

2.  Work with your group to systematically change $a$, $b$, and $c$ so that you get a good visual match to the data. The Python code below will help you get started.

``` python         
import numpy as np
import matplotlib.pyplot as plt
xdata = np.array([0, 1, 2, 3])
ydata = np.array([1.07, 3.9, 14.8, 26.8])
a = # conjecture a value of a
b = # conjecture a value of b
c = # conjecture a value of c
x = # build an x domain starting at 0 and going through 4 
guess = a*x**2 + b*x + c
# make a plot of the data
# make a plot of your function on top of the data
```

![Initial attempt at matching data with a quadratic.](https://numericalmethodssullivan.github.io/images/Ch03_DataMatch.png){#fig-3.11 alt="Initial attempt at matching data with a quadratic."}

As an alternative to loading the data manually we could download the data from the book's github page. All datasets in the text can be loaded in this way. We will be using the `pandas` library (a Python data science library) to load the `.csv` files.

``` python         
import numpy as np
import pandas as pd
URL1 = 'https://raw.githubusercontent.com/NumericalMethodsSullivan'
URL2 = '/NumericalMethodsSullivan.github.io/master/data/'
URL = URL1+URL2
data = np.array( pd.read_csv(URL+'Exercise3_datafit1.csv') )
# Exercise3_datafit1.csv
xdata = data[:,0]
ydata = data[:,1]
```

:::

------------------------------------------------------------------------

::: {#exr-3.82}
 Now let us be a bit more systematic about things from the previous exercise. Let us say that you have a pretty good guess that $b \approx 2$ and $c \approx 0.7$. We need to get a good estimate for $a$.

1.  Pick an arbitrary starting value for $a$ then for each of the four points find the error between the predicted $y$ value and the actual $y$ value. These errors are called the *residuals*.

2.  Square all four of your errors and add them up. (Pause, ponder, and discuss: why are we squaring the errors before we sum them?)

3.  Now change your value of $a$ to several different values and record the sum of the square errors for each of your values of $a$. It may be worth while to use a spreadsheet to keep track of your work here.

4.  Make a plot with the value of $a$ on the horizontal axis and the value of the sum of the square errors on the vertical axis. Use your plot to defend the optimal choice for $a$.

:::

------------------------------------------------------------------------

::: {#exr-3.83}
 We are going to revisit part (3) of the previous exercise. Write a loop that tries many values of $a$ in very small increments and calculates the sum of the squared errors. The following partial Python code should help you get started. In the resulting plot you should see a clear local minimum. What does that minimum tell you about solving this problem?

``` python         
import numpy as np
import matplotlib.pyplot as plt
xdata = np.array([0, 1, 2, 3])
ydata = np.array([1.07, 3.9, 14.8, 26.8])
b = 2
c = 0.75
A = # give a numpy array of values for a
SumSqRes = [] # this is storage for the sum of the sq. residuals
for a in A:
  guess = a*xdata**2 + b*xdata + c
  residuals = # write code to calculate the residuals
  SumSqRes.append( ??? ) # calculate the sum of the squ. residuals
plt.plot(A,SumSqRes,'r*')
plt.grid()
plt.xlabel('Value of a')
plt.ylabel('Sum of squared residuals')
plt.show()
```

:::

------------------------------------------------------------------------

Now let us formalize the process that we have described in the previous exercises.

::: {#def-3.10}

#### Least Squares Regression
Let 
\begin{equation}
S = \{ (x_0, y_0), \, (x_1, y_1), \, \ldots, \, (x_n, y_n) \}
\end{equation}
 be a set of $n+1$ ordered pairs in $\mathbb{R}^2$. If we guess that a function $f(x)$ is a best choice to fit the data and if $f(x)$ depends on parameters $a_0, a_n, \ldots, a_n$ then

1.  Pick initial values for the parameters $a_0, a_1, \ldots, a_n$ so that the function $f(x)$ *looks like* it is close to the data (this is strictly a visual step ...take care that it may take some playing around to guess the initial values of the parameters)

2.  Calculate the square error between the data point and the prediction from the function $f(x)$ 
\begin{equation}
\text{error for the point $x_i$: } e_i = \left( y_i - f(x_i) \right)^2.
\end{equation}
 Note that squaring the error has the advantages of removing the sign, accentuating errors larger than 1, and decreasing errors that are less than 1.

3.  As a measure of the total error between the function and the data, sum the squared errors 
\begin{equation}
\text{sum of square errors } = \sum_{i=1}^n \left( y_i - f(x_i) \right)^2.
\end{equation}
 (Take note that if there were a continuum of points instead of a discrete set then we would integrate the square errors instead of taking a sum.)

4.  Change the parameters $a_0, a_1, \ldots$ so as to minimize the sum of the square errors.

:::

------------------------------------------------------------------------

::: {#exr-3.84}
 In @exr-3.10 the last step is a bit vague. That was purposeful since there are many techniques that could be used to minimize the sum of the square errors. However, if we just think about the sum of the squared residuals as a function then we can apply `scipy.optimize.minimize()` to that function in order to return the values of the parameters that best minimize the sum of the squared residuals. The following blocks of Python code implement the idea in a very streamlined way. Go through the code and comment each line to describe exactly what it does.

``` python         
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize 
xdata = np.array([0, 1, 2, 3])
ydata = np.array([1.07, 3.9, 14.8, 26.8])

def SSRes(parameters):
  # In the next line of code we want to build our 
  # quadratic approximation y = ax^2 + bx + c
  # We are sending in a list of parameters so 
  # a = parameters[0], b = parameters[1], and c = parameters[2]
  yapprox = parameters[0]*xdata**2 + \
            parameters[1]*xdata + \
            parameters[2]
  residuals = np.abs(ydata-yapprox)
  return np.sum(residuals**2)


BestParameters = minimize(SSRes,[2,2,0.75])
print("The best values of a, b, and c are: \n",BestParameters.x)
# If you want to print the diagnositc then use the line below:
# print("The minimization diagnostics are: \n",BestParameters)
```

``` python         
plt.plot(xdata,ydata,'bo',markersize=5)
x = np.linspace(0,4,100)
y = BestParameters.x[0]*x**2 + \
    BestParameters.x[1]*x + \
    BestParameters.x[2]
plt.plot(x,y,'r--')
plt.grid()
plt.xlabel('x')
plt.ylabel('y')
plt.title('Best Fit Quadratic')
plt.show()
```

![Best fit quadratic function.](https://numericalmethodssullivan.github.io/images/Ch03_BestQuadratic.png){#fig-3.12 alt="Best fit quadratic function."}
:::

------------------------------------------------------------------------

::: {#exr-3.85}
In your group choose a function and then choose 10 points on that function. Add a small bit of error into the $y$-values of your points. Give your 10 points to another group. Upon receiving your new points:

-   Plot your points.

-   Make a guess about the basic form of the function that might best fit the data. Your general form will likely have several parameters (just like the quadratic had the parameters $a$, $b$, and $c$).

-   Modify the code from above to find the best collection of parameters minimize the sum of the squares of the residuals between your function and the data.

-   Plot the data along with your best fit function. If you are not satisfied with how it fit then make another guess on the type of function and repeat the process.

-   Finally, go back to the group who gave you your points and check your work.

:::

------------------------------------------------------------------------

::: {#exr-3.86}
 For each dataset associated with this exercise give a functional form that might be a good model for the data. Be sure to choose the most general form of your guess. For example, if you choose "quadratic" then your functional guess is $f(x) = ax^2 + bx + c$, if you choose "exponential" then your functional guess should be something like $f(x) = ae^{b(x-c)}+d$, or if you choose "sinusoidal" then your guess should be something like $f(x) = a\sin(bx) + c\cos(dx) + e$. Once you have a guess of the function type create a plot showing your data along with your guess for a reasonable set of parameters. Then write a function that leverages `scipy.optimize.minimize()` to find the best set of parameters so that your function best fits the data. Note that if `scipy.optimize.minimize()` does not converge then try the alternative `scipy` function `scipy.optimize.fmin()`. Also note that you likely need to be very close to the optimal parameters to get the optimizer to work properly.

You can load the data with the following script.

``` python         
import numpy as np
import pandas as pd
URL1 = 'https://raw.githubusercontent.com/NumericalMethodsSullivan'
URL2 = '/NumericalMethodsSullivan.github.io/master/data/'
URL = URL1+URL2
datasetA = np.array( pd.read_csv(URL+'Exercise3_datafit2.csv') )
datasetB = np.array( pd.read_csv(URL+'Exercise3_datafit3.csv') )
datasetC = np.array( pd.read_csv(URL+'Exercise3_datafit4.csv') )
# Exercise3_datafit1.csv, 
# Exercise3_datafit2.csv, 
# Exercise3_datafit3.csv
```

As a nudge in the right direction, in the left-hand pane of @fig-3.13 the function appears to be exponential. Hence we should choose a function of the form $f(x) = ae^{b(x-c)}+d$. Moreover, we need to pick good approximations of the parameters to start the optimization process. In the left-hand pane of @fig-3.13 the data appears to start near $x=1970$ so our initial guess for $c$ might be $c \approx 1970$. To get initial guesses for $a$, $b$, and $d$ we can observe that the expected best fit curve will approximately go through the points $(1970,15000)$, $(1990,40000)$, and $(2000,75000)$. With this information we get the equations $a+d \approx 15000$, $ae^{20b}+d \approx 40000$ and $ae^{30b}+d \approx 75000$ and work to get reasonable approximations for $a,b,$ and $d$ to feed into the `scipy.optimize.minimize()` command.

![Raw data for least squares function matching problems.](https://numericalmethodssullivan.github.io/images/Ch03_datamatching.png){#fig-3.13 alt="Raw data for least squares function matching problems."}

:::

------------------------------------------------------------------------

## Algorithm Summaries

::: {#exr-3.93}
 Explain in clear language how the derivative free optimization method works on a single-variable function.

:::

------------------------------------------------------------------------

::: {#exr-3.94}
 Explain in clear language how the gradient descent/ascent optimization method works on a single-variable function.

:::

------------------------------------------------------------------------

::: {#exr-3.95}
 Explain in clear language how the Monte Carlo search optimization method works on a single-variable function.

:::

------------------------------------------------------------------------

::: {#exr-3.96}
 Explain in clear language how you find the optimal set of parameters given a set of data and a proposed general function type.

:::

------------------------------------------------------------------------

## Problems


::: {#exr-3.106}
 For each of the following functions write code to numerically approximate the local maximum or minimum that is closest to $x=0$. You may want to start with a plot of the function just to get a feel for where the local extreme value(s) might be.

1.  $\displaystyle f(x) = \frac{x}{1+x^4} + \sin(x)$

2.  $\displaystyle g(x) = \left(x-1\right)^3\cdot\left(x-2\right)^2+e^{-0.5\cdot x}$

:::

------------------------------------------------------------------------

::: {#exr-3.58}
 (This exercise is modified from [@Meerschaert])\
A pig weighing 200 pounds gains 5 pounds per day and costs
45 cents a day to keep. The market price for pigs is 65 cents per pound, but is
falling 1 cent per day. When should the pig be sold to maximize the profit?

Write the expression for the profit $P(t)$ as a function of time $t$ and maximize this analytically (by hand). Then solve the problem with all three methods outlined in @sec-1D-optimization.

:::

------------------------------------------------------------------------

::: {#exr-3.59}
 (This exercise is modified from [@Meerschaert])\
Reconsider the pig @exr-3.58 but now suppose that the weight of the pig after $t$ days is 
\begin{equation}
w = \frac{800}{1+3e^{-t/30}} \text{ pounds}.
\end{equation}
 When should the pig be sold and how much profit do you make on the pig when you sell it? Write this situation as a single variable mathematical model. You should notice that the algebra and calculus for solving this problem is no longer really a desirable way to go. Use an appropriate numerical technique to solve this problem.

:::

------------------------------------------------------------------------

::: {#exr-3.107}
Go back to your old Calculus textbook or homework and find your favourite optimization problem. State the problem, create the mathematical model, and use any of the numerical optimization techniques in this chapter to get an approximate solution to the problem.

:::

------------------------------------------------------------------------

::: {#exr-3.108}
 In the code below you can download several sets of noisy data from measurements of elementary single variable functions.

1.  Make a hypothesis about which type of function would best model the data. Be sure to choose the most general (parametrized) form of your function.

2.  Use appropriate tools to find the parameters for the function that best fits the data. Report you sum of square residuals for each function.

The functions that you propose must be continuous functions.

``` python         
import numpy as np
import pandas as pd
URL1 = 'https://raw.githubusercontent.com/NumericalMethodsSullivan'
URL2 = '/NumericalMethodsSullivan.github.io/master/data/'
URL = URL1+URL2
datasetA = np.array( pd.read_csv(URL+'Exercise3_datafit5.csv') )
datasetB = np.array( pd.read_csv(URL+'Exercise3_datafit6.csv') )
datasetC = np.array( pd.read_csv(URL+'Exercise3_datafit7.csv') )
datasetD = np.array( pd.read_csv(URL+'Exercise3_datafit8.csv') )
datasetE = np.array( pd.read_csv(URL+'Exercise3_datafit9.csv') )
datasetF = np.array( pd.read_csv(URL+'Exercise3_datafit10.csv') )
datasetG = np.array( pd.read_csv(URL+'Exercise3_datafit11.csv') )
datasetH = np.array( pd.read_csv(URL+'Exercise3_datafit12.csv') )
# Exercise3_datafit5.csv - Exercise3_datafit12.csv
```

:::

------------------------------------------------------------------------

::: {#exr-3.109}
 (**The Goat Problem**) This is a classic problem in recreational mathematics that has a great approximate solution where we can leverage some of our numerical analysis skills. Grab a pencil and a piece of paper so we can draw a picture.

-   Draw a coordinate plane

-   Draw a circle with radius 1 unit centred at the point $(0,1)$. This circle will obviously be tangent to the $x$ axis.

-   Draw a circle with radius $r$ centred at the point $(0,0)$. We will take $0 < r < 2$ so there are two intersections of the two circles.

    -   Label the left-hand intersection of the two circles as point $A$. (Point $A$ should be in the second quadrant of your coordinate plane.)

    -   Label the right-hand intersection of the circles as point $B$. (Point $B$ should be in the first quadrant of your coordinate plane.)

-   Label the point $(0,0)$ as the point $P$.

A rancher has built a circular fence of radius 1 unit centred at the point $(0,1)$ for his goat to graze. He tethers his goat at point $P$ on the far south end of the circular fence. He wants to make the length of the goat's chain, $r$, just long enough so that it can graze half of the area of the fenced region. How long should he make the chain?

Hints:

-   It would be helpful to write equations for both circles. Then you can use the equations to find the coordinates of the intersection points $A$ and $B$.

    -   You can either solve for the intersection points algebraically or you can use a numerical root finding technique to find the intersection points.

    -   In any case, the intersection points will (obviously) depend on the value of $r$

-   Set up an integral to find the area grazed by the goat.

    -   You will likely need to use a numerical integration technique to evaluate the integral.

-   Write code to narrow down on the best value of $r$ where the integral evaluates to half the area of the fenced region.

:::

------------------------------------------------------------------------

## Projects

In this section we propose several ideas for projects related to numerical optimisation. These projects are meant to be open ended, to encourage creative mathematics, to push your coding skills, and to require you to write and communicate your mathematics.

### Edge Detection in Images

Edge detection is the process of finding the boundaries or edges of objects in an image. There are many approaches to performing edge detection, but one method that is quite robust is to use the gradient vector in the following way:

-   First convert the image to gray scale.

-   Then think of the gray scale image as a plot of a multivariable function $G(x,y)$ where the ordered pair $(x,y)$ is the pixel location and the output $G(x,y)$ is the value of the gray scale at that point.

-   At each pixel calculate the gradient of the function $G(x,y)$ numerically.

-   If the magnitude of the gradient is larger than some threshold then the function $G(x,y)$ is steep at that location and it is possible that there is an edge (a transition from one part of the image to a different part) at that point. Hence, if $\|\nabla G(x,y)\| > \delta$ for some threshold $\delta$ then we can mark the point $(x,y)$ as an edge point.

**Your Tasks:**

1.  Choose several images on which to do edge detection. You should take your own images, but if you choose not to be sure that you cite the source(s) of your images.

2.  Write Python code that performs edge detection as described above on the image. In the end you should produce side-by-side plots of the original picture and the image showing only the edges. To calculate the gradient use a centred difference scheme for the first derivatives 
\begin{equation}
 f'(x) \approx \frac{f(x+h)-f(x-h)}{2h}. 
\end{equation}
 In an image we can take $h=1$ (why?), and since the gradient is two dimensional we get 
\begin{equation}
 \nabla G(x,y) \approx \left< \frac{G(x+1,y)-G(x-1,y)}{2} \, , \, \frac{G(x,y+1)-G(x,y-1)}{2} \right>. 
\end{equation}
 @fig-3.14 depicts what this looks like when we zoom in to a pixel and its immediate neighbours. The pixel labelled `G[i,j]` is the pixel at which we want to evaluate the gradient, and the surrounding pixels are labelled by their indices relative to `[i,j]`.

![The gradient computation on a single pixel using a central difference scheme for the first derivative.](figures/Optimization/GrayGradient.png){#fig-3.14 alt="The gradient computation on a single pixel using a central difference scheme for the first derivative."}

3.  There are many ways to approximate numerical first derivatives. The simplest approach is what you did in part (2) -- using a centred difference scheme. However, pixels are necessarily tightly packed in an image and the immediate neighbours of a point may not have enough contrast to truly detect edges. If you examine @fig-3.14 you will notice that we only use 4 of the 8 neighbours of the pixel `[i,j]`. Also notice that we did not reach out any further than a single pixel. Your job now is to build several other approaches to calculating the gradient vector, implement them to perform edge detection, and show the resulting images. For each method you need to give the full mathematical details for how you calculated the gradient as well as give a list of pros and cons for using the new numerical gradient for edge detection based on what you see in your images. As an example, you could use a centred difference scheme that looks two pixels away instead of at the immediate neighbouring pixels 
\begin{equation}
 f'(x) \approx \frac{??? f(x-2) + ??? f(x+2)}{???}. 
\end{equation}
 Of course you would need to determine the coefficients in this approximation scheme.\
    Another idea could use a centred difference scheme that uses pixels that are immediate neighbours AND pixels that are two units away 
\begin{equation}
 f'(x) \approx \frac{??? f(x-2) + ??? f(x-1) + ??? f(x+1) + ??? f(x+2)}{???}. 
\end{equation}
\
    In any case, you will need to use Taylor Series to derive coefficients in the formulas for the derivatives as well as the order of the error. There are many ways to approximate the first derivatives so be creative. In your exploration you are not restricted to using just the first derivative. There could be some argument for using the second derivatives and/or the Hessian matrix of the gray scale image function $G(x,y)$ and using some function of the concavity as a means of edge detection. Explore and have fun!

The following code will allow you to read an image into Python as an `np.array()`.

``` python         
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import image
I = np.array(image.plt.imread('ImageName.jpg'))
plt.imshow(I)
plt.axis("off")
plt.show()
```

You should notice that the image, `I`, is a three dimensional array. The three layers are the red, green, and blue channels of the image. To flatten the image to gray scale you can apply the rule 
\begin{equation}
 \text{grayscale value} = 0.3 \text{Red} + 0.59 \text{Green} + 0.11 \text{Blue}. 
\end{equation}
 The output should be a 2 dimensional `numpy` array which you can show with the following Python code.

``` python         
plt.imshow(G, cmap='gray') # "cmap" stands for "color map"
plt.axis("off")
plt.show()
```

@fig-3.15 shows the result of different threshold values applied to the simplest numerical gradient computations. The image was taken by the author.

![Edge detection using different thresholds for the value of the gradient on the grayscale image](figures/Optimization/EdgeDetection.png){#fig-3.15 alt="Edge detection using different thresholds for the value of the gradient on the grayscale image"}
---->
<p>More will appear after our session on Tuesday.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./nmCalculus.html" class="pagination-link  aria-label=" &lt;span="">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Calculus</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./nmODE.html" class="pagination-link" aria-label="<span class='chapter-number'>6</span>&nbsp; <span class='chapter-title'>Ordinary Differential Equations</span>">
        <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Ordinary Differential Equations</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/gustavdelius/NumericalAnalysis2024/edit/main/nmOptimization.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li></ul></div></div></div></footer></body></html>